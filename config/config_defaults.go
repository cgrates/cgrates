/*
Real-time Online/Offline Charging System (OCS) for Telecom & ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/

package config

const CGRATES_CFG_JSON = `
{

// Real-time Online/Offline Charging System (OCS) for Telecom & ISP environments
// Copyright (C) ITsysCOM GmbH
//
// This file contains the default configuration hardcoded into CGRateS.
// This is what you get when you load CGRateS with an empty configuration file.

"general": {
	"node_id": "",						// identifier of this instance in the cluster, if empty it will be autogenerated
	"logger":"*syslog",					// controls the destination of logs <*syslog|*stdout>
	"log_level": 6,						// control the level of messages logged (0-emerg to 7-debug)
	"rounding_decimals": 5,					// system level precision for floats
	"dbdata_encoding": "*msgpack",				// encoding used to store object data in strings: <*msgpack|*json>
	"tpexport_dir": "/var/spool/cgrates/tpe",		// path towards export folder for offline TariffPlans
	"poster_attempts": 3,					// number of attempts before considering post request failed (eg: *http_post, CDR exports)
	"failed_posts_dir": "/var/spool/cgrates/failed_posts",	// directory path where we store failed requests
	"failed_posts_ttl": "5s",				// time to wait before writing the failed posts in a single file
	"default_request_type": "*rated",			// default request type to consider when missing from requests: <""|*prepaid|*postpaid|*pseudoprepaid|*rated>
	"default_category": "call",				// default category to consider when missing from requests
	"default_tenant": "cgrates.org",			// default tenant to consider when missing from requests
	"default_timezone": "Local",				// default timezone for timestamps where not specified <""|UTC|Local|$IANA_TZ_DB>
	"default_caching": "*reload",				// default actions to do when caching items
	"caching_delay": "0s",					// add delay before cache reload
	"min_call_duration": "0s",				// only authorize calls with allowed duration higher than this
	"max_call_duration": "3h",				// maximum call duration a prepaid call can last
	"connect_attempts": 5,					// initial server connect attempts
	"reconnects": -1,					// number of retries in case of connection lost
	"max_reconnect_interval": "", 				// time to wait in between reconnect attempts
	"connect_timeout": "1s",				// consider connection unsuccessful on timeout, 0 to disable the feature
	"reply_timeout": "2s",					// consider connection down for replies taking longer than this value
	"locking_timeout": "0",					// timeout internal locks to avoid deadlocks
	"digest_separator": ",",				// separator to use in replies containing data digests
	"digest_equal": ":",					// equal symbol used in case of digests
	"rsr_separator": ";",					// separator used within RSR fields
	"max_parallel_conns": 100				// the maximum number of connection used by the *parallel strategy
},


"cores": {
	"caps": 0,			// maximum concurrent request allowed ( 0 to disabled )
	"caps_strategy": "*busy",	// strategy in case of concurrent requests reached	
	"caps_stats_interval": "0",	// the interval duration we sample for caps stats ( 0 to disabled )
	"shutdown_timeout": "1s"	// the duration to wait until all services are stopped
},


"rpc_conns": {
	//"*localhost": {
		//"conns": [	// rpc connections definitions
			//{
				//"address": "127.0.0.1:2012",
				//"transport":"*json",
				//"connect_attempts": 5,
				//"reconnects": -1,
				//"max_reconnect_interval": "",
				//"connect_timeout":"1s",
				//"reply_timeout":"2s",
				//"tls":false,
				//"client_key":"",
				//"client_certificate":"",
				//"ca_certificate":""
			//}
		//]
	//}
},


"data_db": {					// database used to store runtime data (eg: accounts)
	"db_type": "*redis",			// data_db type: <*redis|*mongo>
	"db_host": "127.0.0.1",			// data_db host address
	"db_port": 6379, 			// data_db port to reach the database
	"db_name": "10", 			// data_db database name to connect to
	"db_user": "cgrates", 			// username to use when connecting to data_db
	"db_password": "", 			// password to use when connecting to data_db
	"remote_conns":[],			// the conns that are queried when the items are not found in local DB 
	"remote_conn_id": "",			// the ID to be sent to remote_conns to identify the connection
	"replication_conns":[],			// the conns the items are replicated
	"replication_filtered": false, 		// if this is enabled the replication will be made only to the conns that received a get
	"replication_cache": "", 		// the caching action that is executed on the replication_conns when the items are replicated 
	"items":{
		"*accounts": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*reverse_destinations": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*destinations": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*rating_plans": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*rating_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*actions": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*action_plans": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*account_action_plans": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*action_triggers": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*shared_groups": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*timings": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*resource_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*resources": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*ranking_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*trend_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*trends": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*statqueue_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*statqueues": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*threshold_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*thresholds": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*filters": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*route_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*attribute_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*charger_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*dispatcher_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*dispatcher_hosts": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*load_ids": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*versions": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*resource_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*stat_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*threshold_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*route_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*attribute_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*charger_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*dispatcher_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*reverse_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*sessions_backup": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false}, 
	},
	"opts":{
		"redisMaxConns": 10,			// the connection pool size
		"redisConnectAttempts": 20,		// the maximum amount of dial attempts
		"redisSentinel": "",			// the name of sentinel when used
		"redisCluster": false,			// if enabled the datadb will try to connect to the redis cluster
		"redisClusterSync": "5s",		// the sync interval for the redis cluster
		"redisClusterOndownDelay": "0",		// the delay before executing the commands if the redis cluster is in the CLUSTERDOWN state
		"redisConnectTimeout": "0",		// the amount of wait time until timeout for a connection attempt
		"redisReadTimeout": "0",		// the amount of wait time until timeout for reading operations
		"redisWriteTimeout": "0",   		// the amount of wait time until timeout for writing operations
		"redisPoolPipelineWindow": "150Âµs",	// duration after which internal pipelines are flushed (0 disables implicit pipelining)
		"redisPoolPipelineLimit": 0,        	// maximum number of commands that can be pipelined before flushing (0 means no limit)
		"redisTLS": false,			// if true it will use a tls connection and use the redisClientCertificate, redisClientKey and redisCACertificate for tls connection
		"redisClientCertificate":"",		// path to client certificate
		"redisClientKey":"",			// path to client key
		"redisCACertificate":"",		// path to CA certificate (populate for self-signed certificate otherwise let it empty)
		"mongoQueryTimeout":"10s",		// timeout for query when mongo is used
		"mongoConnScheme": "mongodb"		// scheme for MongoDB connection <mongodb|mongodb+srv>
	}
},


"stor_db": {					// database used to store offline tariff plans and CDRs
	"db_type": "*mysql",			// stor database type to use: <*mongo|*mysql|*postgres|*internal>
	"db_host": "127.0.0.1",			// the host to connect to
	"db_port": 3306,			// the port to reach the stor_db
	"db_name": "cgrates",			// stor database name
	"db_user": "cgrates",			// username to use when connecting to stor_db
	"db_password": "CGRateS.org",		// password to use when connecting to stor_db
	"string_indexed_fields": [],		// indexes on cdrs table to speed up queries, used in case of *mongo and *internal
	"prefix_indexed_fields":[],		// prefix indexes on cdrs table to speed up queries, used in case of *internal
	"opts": {
		"sqlMaxOpenConns": 100,		// maximum database connections opened, not applying for mongo
		"sqlMaxIdleConns": 10,		// maximum database connections idle, not applying for mongo
		"sqlConnMaxLifetime": "0", 	// maximum amount of time a connection may be reused (0 for unlimited), not applying for mongo
		"mysqlDSNParams": {},           // DSN extra paramss
		"mongoQueryTimeout": "10s",	// timeout for query when mongo is used
		"mongoConnScheme": "mongodb",	// scheme for MongoDB connection <mongodb|mongodb+srv>
		"mysqlLocation": "Local",	// the location the time from mysql is retrieved
		"pgSSLMode": "disable",		// determines whether or with what priority a secure SSL TCP/IP connection will be negotiated with the server
		//"pgSSLCert": "",		// file name of the client SSL certificate, replacing the default ~/.postgresql/postgresql.crt
		//"pgSSLKey": "",		// location for the secret key used for the client certificate
		//"pgSSLPassword": "",		// specifies the password for the secret key specified in pgSSLKey
		//"pgSSLCertMode": "allow",	// determines whether a client certificate may be sent to the server, and whether the server is required to request one
		//"pgSSLRootCert": "",		// name of a file containing SSL certificate authority (CA) certificate(s)
		"pgSchema": ""			// postgres schema to use
	},
	"items":{
		"*session_costs": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*cdrs": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_timings": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_destinations": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_rates": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_destination_rates": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_rating_plans": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_rating_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_shared_groups": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_actions": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_action_plans": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_action_triggers": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_account_actions": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_resources": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_stats": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_rankings": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_trends": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_thresholds": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_filters": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_routes": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_attributes": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_chargers": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*versions": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_dispatcher_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false},
		"*tp_dispatcher_hosts": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate":false}
	}
},


"listen": {
	"rpc_json": "127.0.0.1:2012",		// RPC JSON listening address
	"rpc_gob": "127.0.0.1:2013",		// RPC GOB listening address
	"http": "127.0.0.1:2080",		// HTTP listening address
	"rpc_json_tls" : "127.0.0.1:2022",	// RPC JSON TLS listening address
	"rpc_gob_tls": "127.0.0.1:2023",	// RPC GOB TLS listening address
	"http_tls": "127.0.0.1:2280"		// HTTP TLS listening address
},


"tls": {
	"server_certificate" : "",	// path to server certificate
	"server_key":"",		// path to server key
	"client_certificate" : "",	// path to client certificate
	"client_key":"",		// path to client key
	"ca_certificate":"",		// path to CA certificate (populate for self-signed certificate otherwise let it empty)
	"server_policy":4,		// server_policy determines the TLS Client Authentication (0-NoClientCert, 1-RequestClientCert, 2-RequireAnyClientCert, 3-VerifyClientCertIfGiven, 4-RequireAndVerifyClientCert)
	"server_name":""
},


"http": {						// HTTP server configuration
	"json_rpc_url": "/jsonrpc",			// JSON RPC relative URL ("" to disable)
	"registrars_url": "/registrar",			// registrar service relative URL
	"prometheus_url": "/prometheus",		// endpoint for prometheus metrics
	"ws_url": "/ws",				// WebSockets relative URL ("" to disable)
	"freeswitch_cdrs_url": "/freeswitch_json",	// Freeswitch CDRS relative URL ("" to disable)
	"http_cdrs": "/cdr_http",			// CDRS relative URL ("" to disable)
	"pprof_path": "/debug/pprof/",			// endpoint for serving runtime profiling data for pprof visualization
	"use_basic_auth": false,			// use basic authentication
	"auth_users": {},				// basic authentication usernames and base64-encoded passwords (eg: { "username1": "cGFzc3dvcmQ=", "username2": "cGFzc3dvcmQy "})
	"client_opts":{
		"skipTlsVerify": false, 		// if enabled Http Client will accept any TLS certificate

		// configuration options for http.Transport
		"tlsHandshakeTimeout": "10s",
		"disableKeepAlives": false,
		"disableCompression": false,
		"maxIdleConns": 100,
		"maxIdleConnsPerHost": 2,
		"maxConnsPerHost": 0,
		"idleConnTimeout": "90s",
		"responseHeaderTimeout": "0",
		"expectContinueTimeout": "0",
		"forceAttemptHttp2": true,

		// configuration options for net.Dialer
		"dialTimeout": "30s",
		"dialFallbackDelay": "300ms",
		"dialKeepAlive": "30s"
	}
},


"schedulers": {
	"enabled": false,		// start Scheduler service: <true|false>
	"cdrs_conns": [],		// connections to CDRs for *cdrlog actions <""|*internal|$rpc_conns_id>
	"thresholds_conns": [],		// connections to ThresholdS for *reset_threshold action <""|*internal|$rpc_conns_id>
	"stats_conns": [],		// connections to StatS for *reset_stat_queue action: <""|*internal|$rpc_conns_id>
	"filters": [],			// only execute actions matching these filters
	"dynaprepaid_actionplans": []	// actionPlans to be executed in case of *dynaprepaid request type
},


"caches":{
	"partitions": {
		"*destinations": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},		// destination caching
		"*reverse_destinations": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// reverse destinations index caching
		"*rating_plans": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},		// rating plans caching
		"*rating_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// rating profiles caching
		"*actions": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},		// actions caching
		"*action_plans": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},		// action plans caching
		"*account_action_plans": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// account action plans index caching
		"*action_triggers": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// action triggers caching
		"*shared_groups": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},		// shared groups caching
		"*timings": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},		// timings caching
		"*resource_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// control resource profiles caching
		"*resources": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},		// control resources caching
		"*event_resources": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false},				// matching resources to events
		"*trend_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// control trend profiles caching
		"*trends": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},		// control trends caching
		"*ranking_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// ranking profiles
		"*statqueue_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// statqueue profiles
		"*statqueues": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},		// statqueues with metrics
		"*threshold_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// control threshold profiles caching
		"*thresholds": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},		// control thresholds caching
		"*filters": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},		// control filters caching
		"*route_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// control route profile caching
		"*attribute_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// control attribute profile caching
		"*charger_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// control charger profile caching
		"*dispatcher_profiles": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// control dispatcher profile caching
		"*dispatcher_hosts": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},	// control dispatcher hosts caching
		"*resource_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false}, 		// control resource filter indexes caching
		"*stat_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false}, 			// control stat filter indexes caching
		"*threshold_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false}, 		// control threshold filter indexes caching
		"*route_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false}, 			// control route filter indexes caching
		"*attribute_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false}, 		// control attribute filter indexes caching
		"*charger_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false}, 			// control charger filter indexes caching
		"*dispatcher_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false}, 		// control dispatcher filter indexes caching
		"*reverse_filter_indexes" : {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false}, 			// control reverse filter indexes caching used only for set and remove filters 
		"*dispatcher_routes": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false}, 			// control dispatcher routes caching
		"*dispatcher_loads": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false},				// control dispatcher load( in case of *ratio ConnParams is present)
		"*dispatchers": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false}, 				// control dispatcher interface
		"*diameter_messages": {"limit": -1, "ttl": "3h", "static_ttl": false, "remote":false, "replicate": false},			// diameter messages caching
		"*radius_packets": {"limit": -1, "ttl": "3h", "static_ttl": false, "remote":false, "replicate": false},				// radius packets caching
		"*rpc_responses": {"limit": 0, "ttl": "2s", "static_ttl": false, "remote":false, "replicate": false},				// RPC responses caching
		"*closed_sessions": {"limit": -1, "ttl": "10s", "static_ttl": false, "remote":false, "replicate": false},			// closed sessions cached for CDRs
		"*event_charges": {"limit": 0, "ttl": "10s", "static_ttl": false, "remote":false, "replicate": false},				// events proccessed by ChargerS
		"*cdr_ids": {"limit": -1, "ttl": "10m", "static_ttl": false, "remote":false, "replicate": false},				// protects CDRs against double-charging
		"*load_ids": {"limit": -1, "ttl": "", "static_ttl": false, "precache": false, "remote":false, "replicate": false},		// control the load_ids for items
		"*rpc_connections": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false},				// RPC connections caching
		"*uch": {"limit": -1, "ttl": "3h", "static_ttl": false, "remote":false, "replicate": false},					// User cache
		"*stir": {"limit": -1, "ttl": "3h", "static_ttl": false, "remote":false, "replicate": false},					// stirShaken cache keys
		"*apiban":{"limit": -1, "ttl": "2m", "static_ttl": false, "remote":false, "replicate": false}, 
		"*sentrypeer":{"limit": -1, "ttl": "86400s", "static_ttl": true, "remote":false, "replicate": false},
		"*caps_events": {"limit": -1, "ttl": "", "static_ttl": false, "remote":false, "replicate": false},				// caps cached samples
		"*replication_hosts": {"limit": 0, "ttl": "", "static_ttl": false, "remote":false, "replicate": false},				// the replication hosts cache(used when replication_filtered is enbled)
	},
	"replication_conns": [],
	"remote_conns": []	// the conns that are queried when the items are not found in cache
},


"filters": {			// Filters configuration (*new)
	"stats_conns": [],	// connections to StatS for <*stats> filters, empty to disable stats functionality: <""|*internal|$rpc_conns_id>
	"resources_conns": [],	// connections to ResourceS for <*resources> filters, empty to disable stats functionality: <""|*internal|$rpc_conns_id>
	"apiers_conns": [],	// connections to RALs for <*accounts> filters, empty to disable stats functionality: <""|*internal|$rpc_conns_id>
	"trends_conns": [],	// connections to TrendS for <*trends> filters, empty to disable trends functionality: <""|*internal|$rpc_conns_id>
},


"rals": {
	"enabled": false,			// enable Rating/Accounting service: <true|false>
	"thresholds_conns": [],			// connections to ThresholdS for account/balance updates, empty to disable thresholds functionality: <""|*internal|$rpc_conns_id>
	"stats_conns": [],			// connections to StatS for account/balance updates, empty to disable stats functionality: <""|*internal|$rpc_conns_id>
	"sessions_conns": [],			// connections to SessionS for actions requiring them: <""|*internal|$rpc_conns_id>
	"rp_subject_prefix_matching": false,	// enables prefix matching for the rating profile subject
	"remove_expired":true,			// enables automatic removal of expired balances
	"max_computed_usage": {			// do not compute usage higher than this, prevents memory overload
		"*any": "189h",
		"*voice": "72h",
		"*data": "107374182400",
		"*sms": "10000",
		"*mms": "10000"
	},
	"max_increments": 1000000,
	"fallback_depth": 3,
	"balance_rating_subject":{		// default rating subject in case that balance rating subject is empty
		"*any": "*zero1ns",
		"*voice": "*zero1s"
	}

},


"cdrs": {				// CDRs config
	"enabled": false,		// start the CDR Server:  <true|false>
	"extra_fields": [],		// extra fields to store in CDRs for non-generic CDRs (ie: FreeSWITCH JSON)
	"store_cdrs": true,		// store cdrs in StorDB
	"session_cost_retries": 5,	// number of queries to session_costs before recalculating CDR
	"chargers_conns": [],		// connection to ChargerS for CDR forking, empty to disable billing for CDRs: <""|*internal|$rpc_conns_id>
	"rals_conns": [],		// connections to RALs for cost calculation: <""|*internal|$rpc_conns_id>
	"attributes_conns": [],		// connection to AttributeS for altering *raw CDRs, empty to disable attributes functionality: <""|*internal|$rpc_conns_id>
	"thresholds_conns": [],		// connection to ThresholdS for CDR reporting, empty to disable thresholds functionality: <""|*internal|$rpc_conns_id>
	"stats_conns": [],		// connections to StatS for CDR reporting, empty to disable stats functionality: <""|*internal|$rpc_conns_id>
	"online_cdr_exports":[],	// list of CDRE profiles to use for real-time CDR exports
	"scheduler_conns": [],		// connections to SchedulerS in case of *dynaprepaid request
	"ees_conns": []			// connections to EventExporter
},


"ers": {					// EventReaderService
	"enabled": false,			// starts the EventReader service: <true|false>
	"sessions_conns": ["*internal"],	// RPC Connections IDs
	"ees_conns": [],			// connection for routing processed and invalid messages through EEs
	"concurrent_events": 1,			// number of events to generate concurrently on CGRateS side
	"partial_cache_ttl": "1s",		// the duration to cache partial records when not pairing
	"readers": [
		{
			"id": "*default",					// identifier of the EventReader profile
			"type": "*none",					// reader type <*file_csv>
			"run_delay": "0",					// sleep interval in seconds between consecutive runs, -1 to use automation via inotify or 0 to disable running all together
			"concurrent_requests": 1024,				// maximum simultaneous requests/files to process, 0 for unlimited
			"source_path": "/var/spool/cgrates/ers/in",		// read data from this path
			"processed_path": "/var/spool/cgrates/ers/out",		// move processed data here
			"tenant": "",						// tenant used by import
			"timezone": "",						// timezone for timestamps where not specified <""|UTC|Local|$IANA_TZ_DB>
			"filters": [],						// limit parsing based on the filters
			"flags": [],						// flags to influence the event processing
			"reconnects": -1,					// number of retries in case of connection lost
			"ees_success_ids": [],					// ids of exporters used for moving the successfully processed event
			"ees_failed_ids": [],					// ids of exporters used for moving the unprocessed event
			"max_reconnect_interval": "5m", 			// time to wait in between reconnect attempts
			"opts": {
				// Partial
				// "partialPath": "/",				// the path were the partial events will be sent
				"partialCacheAction": "*none",			// the action that will be executed for the partial CSVs that are not matched<*none|*post_cdr|*dump_to_file>
				"partialOrderField": "~*req.AnswerTime",	// the field after what the events are order when merged
				// "partialcsvFieldSeparator": ","		// separator used when dumping the fields
				
				// FileCSV 
				"csvRowLength": 0,				// Number of fields from csv file, -1 to disable checking, 0 to inherit the lenght of first record
				"csvFieldSeparator": ",",			// separator used when reading the fields
				"csvHeaderDefineChar": ":", 			// the starting character for header definition used in case of CSV files
				// "csvLazyQuotes": false,			// if a quote may appear in an unquoted field and a non-doubled quote may appear in a quoted field

				// FileXML
				// "xmlRootPath": "",				// path towards one event in case of XML CDRs
				
				// AMQP and AMQPv1
				// "amqpQueueID": "cgrates_cdrs",               // identifier for the primary queue where messages are consumed (0.9.1/1.0)
				
				// "amqpUsername": "",                          // username for SASL PLAIN auth, exclusive to AMQP 1.0, often representing the policy name
				// "amqpPassword": "",                          // password for authentication, exclusive to AMQP 1.0

				// "amqpConsumerTag": "cgrates",                // unique tag for the consumer, useful for message tracking and consumer management (0.9.1)
				// "amqpExchange": "",                          // name of the primary exchange where messages will be published (0.9.1)
				// "amqpExchangeType": "",                      // type of the primary exchange (direct, topic, fanout, headers) (0.9.1)
				// "amqpRoutingKey": "",                        // key used for routing messages to the primary queue (0.9.1)

				// Kafka
				// "kafkaTopic": "cgrates",			// the topic from were the events are read
				// "kafkaGroupID": "cgrates",			// the group that reads the events
				// "kafkaMaxWait": "1ms",			// the maximum amount of time to wait for new data to come
				// "kafkaTLS": false, 				// if true it will try to authenticate the client
				// "kafkaCAPath": "",				// path to certificate authority pem
				// "kafkaSkipTLSVerify": false,			// if true it will skip certificate verification

				// SQL
				// "sqlDBName": "cgrates", 			// the name of the database from were the events are read
				// "sqlTableName": "cdrs",			// the name of the table from were the events are read
				// "pgSSLMode": "disable",			// the ssl mode for postgres db

				// SQS and S3
				// "awsRegion": "",
				// "awsKey": "",
				// "awsSecret": "",
				// "awsToken": "",

				// SQS
				// "sqsQueueID": "cgrates_cdrs", 		// the queue id for SQS readers from were the events are read
				
				// S3
				// "s3BucketID": "cgrates_cdrs", 		// the bucket id for S3 readers from were the events are read

				// nats
				// "natsJetStream": false,			// controls if the nats reader uses the JetStream
				// "natsConsumerName": "cgrates",		// in case of JetStream the name of the consumer
				// "natsStreamName": "cdrs",			// the name of the NATS JetStream stream from which the consumer will read messages
				"natsSubject": "cgrates_cdrs",			// the subject from were the events are read
				// "natsQueueID": "",				// the queue id the consumer listen to
				// "natsJWTFile": "",				// the path to the JWT file( can be the chained file or the user file)
				// "natsSeedFile": "",				// the path to the seed files( if the JWT file is mention this is used as seedFile for the JWT user mentioned above)
				// "natsCertificateAuthority": "",		// the path to a custom certificate authority file( used by tls)
				// "natsClientCertificate": "",			// the path to a client certificate( used by tls)
				// "natsClientKey": "",				// the path to a client key( used by tls)
				// "natsJetStreamMaxWait": "5s",		// the maximum amount of time to wait for a response
			},
			"fields":[						// import fields template, tag will match internally CDR field, in case of .csv value will be represented by index of the field value
				{"tag": "ToR", "path": "*cgreq.ToR", "type": "*variable", "value": "~*req.2", "mandatory": true},
				{"tag": "OriginID", "path": "*cgreq.OriginID", "type": "*variable", "value": "~*req.3", "mandatory": true},
				{"tag": "RequestType", "path": "*cgreq.RequestType", "type": "*variable", "value": "~*req.4", "mandatory": true},
				{"tag": "Tenant", "path": "*cgreq.Tenant", "type": "*variable", "value": "~*req.6", "mandatory": true},
				{"tag": "Category", "path": "*cgreq.Category", "type": "*variable", "value": "~*req.7", "mandatory": true},
				{"tag": "Account", "path": "*cgreq.Account", "type": "*variable", "value": "~*req.8", "mandatory": true},
				{"tag": "Subject", "path": "*cgreq.Subject", "type": "*variable", "value": "~*req.9", "mandatory": true},
				{"tag": "Destination", "path": "*cgreq.Destination", "type": "*variable", "value": "~*req.10", "mandatory": true},
				{"tag": "SetupTime", "path": "*cgreq.SetupTime", "type": "*variable", "value": "~*req.11", "mandatory": true},
				{"tag": "AnswerTime", "path": "*cgreq.AnswerTime", "type": "*variable", "value": "~*req.12", "mandatory": true},
				{"tag": "Usage", "path": "*cgreq.Usage", "type": "*variable", "value": "~*req.13", "mandatory": true},
			],
			"partial_commit_fields": [],
			"cache_dump_fields": []
		}
	]
},

"ees": {						// EventExporterService
	"enabled": false,				// starts the EventReader service: <true|false>
	"attributes_conns":[],				// RPC Connections IDs
	"cache": {
		"*file_csv": {"limit": -1, "ttl": "5s", "static_ttl": false},
	},
	"exporters": [
		{
			"id": "*default",					// identifier of the EventReader profile
			"type": "*none",					// exporter type 
			"export_path": "/var/spool/cgrates/ees",		// path where the exported events will be placed
			"failed_posts_dir": "/var/spool/cgrates/failed_posts",	// directory path where we store failed requests
			"concurrent_requests": 0,				// maximum simultaneous requests to process, 0 for unlimited
			"timezone": "",						// timezone for timestamps where not specified <""|UTC|Local|$IANA_TZ_DB>
			"filters": [],						// limit parsing based on the filters
			"flags": [],						// flags to influence the event processing
			"attribute_ids": [],					// select Attribute profiles instead of discovering them
			"attribute_context": "",				// context used to discover matching Attribute profiles
			"synchronous": false,					// block processing until export has a result
			"attempts": 1,						// export attempts
			"opts": {

				// CSV
				// "csvFieldSeparator": ",",			// separator used when reading the fields

				
 				// Elasticsearch options
				// "elsCloud":true,			// ExportPath will be  an CLoud ID deployment
				// "elsApiKey": "",			// Base64-encoded token for authorization; if set, overrides username/password and service token.
				// "elsUsername":"",			// Username for HTTP Basic Authentication.
				// "elsPassword":"",			// Password for HTTP Basic Authentication.
				// "elsServiceToken":""			// Service token for authorization; if set, overrides username/password.
				// "elsCertificateFingerPrint":""	// SHA256 hex fingerprint given by Elasticsearch on first launch.
				// "elsDiscoverNodesOnStart":false,	// Discover nodes when initializing the client. Default: false.
				// "elsDiscoverNodesInterval":"10s",	// Discover nodes periodically. Default: disabled.
				// "elsEnableDebugLogger":"false",	// Enable the debug logging.
				// "elsLogger":"",			// The logger type can either be elsJson,elsColor and elsText
				// "elsCompressRequestBody":false,	// Enable compression on requests
				// "elsCompressRequestBodyLevel":0,	// Default: gzip.DefaultCompression, 9:BestCompression,-2:HuffmanOnly,1:BestSpeed
				// "elsRetryOnStatus":[],		// List of status codes for retry. Default: 502, 503, 504.
				// "elsMaxRetries": 0,			// Default: 3.
				// "elsDisableRetry": false,		// Default: false.


				// "elsIndex": "",			// ElsIndex
				// "elsIfPrimaryTerm": 0,		// ElsIfPrimaryTerm
 				// "elsIfSeqNo": 0,			// ElsIfSeqNo
				// "elsOpType": "",			// ElsOpType
				// "elsPipeline": "",			// ElsPipeline
				// "elsRouting": "",			// ElsRouting
				// "elsTimeout": "",			// ElsTimeout
				// "elsVersion": 0,			// ElsVersionLow
				// "elsVersionType": "",		// ElsVersionType
				// "elsWaitForActiveShards": "",	// ElsWaitForActiveShards


				// SQL
				// "sqlMaxIdleConns": 0,	// SQLMaxIdleConns    
				// "sqlMaxOpenConns": 0,	// SQLMaxOpenConns
				// "sqlConnMaxLifetime": "0",	// SQLConnMaxLifetime 
				// "mysqlDSNParams": {},        // DSN params


				// "sqlTableName":"cdrs", 	// the name of the table from where the events are exported
				// "sqlDBName": "cgrates",	// the name of the database from where the events are exported
				// "pgSSLMode": "disable",	// the SSLMode for postgres
				
				
				// Kafka
				// "kafkaTopic": "cgrates_cdrs",	// the topic from where the events are exported
				// "kafkaBatchSize": 100,		// limit on how many messages will be buffered before being sent
				// "kafkaTLS": false,			// if true, it will try to authenticate the server
				// "kafkaCAPath": "", 			// path to certificate authority pem
				// "kafkaSkipTLSVerify: false, 		// if true it will skip certificate verification


				// AMQP
				// "amqpQueueID": "cgrates_cdrs",	// the queue id for AMQP exporters from were the events are exported
				// "amqpRoutingKey": "",		// RoutingKey, amqp 0.9.1 exclusive
				// "amqpExchange": "",			// Exchange, amqp 0.9.1 exclusive
				// "amqpExchangeType": "",		// ExchangeType, amqp 0.9.1 exclusive
				// "amqpUsername": "",			// amqp 1.0 exclusive, used for SASL PLAIN auth, usually represents the policy name
				// "amqpPassword": "",			// amqp 1.0 exclusive, used for SASL PLAIN auth, populated with one of its policy's keys


				// SQS and S3
				// "awsRegion": "",	// AWSRegion
				// "awsKey": "",	// AWSKey
				// "awsSecret": "",	// AWSSecret
				// "awsToken": "",	// AWSToken

				//SQS
				// "sqsQueueID": "cgrates_cdrs", 	// the queue id for SQS exporters from were the events are exported

				// S3
				// "s3BucketID": "cgrates_cdrs", 	// the bucket id for S3 readers from where the events that are  exported
				// "s3FolderPath": "",			// S3FolderPath 

				// Nats
				// "natsJetStream": false,		// controls if the nats poster uses the JetStream
				// "natsSubject": "cgrates_cdrs",	// the subject were the events are exported
				// "natsJWTFile": "",			// the path to the JWT file( can be the chained file or the user file)
				// "natsSeedFile": "",			// the path to the seed files( if the JWT file is mention this is used as seedFile for the JWT user mentioned above)
				// "natsCertificateAuthority": "",	// the path to a custom certificate authority file( used by tls)
				// "natsClientCertificate": "",		// the path to a client certificate( used by tls)
				// "natsClientKey": "",			// the path to a client key( used by tls)
				// "natsJetStreamMaxWait": "5s",	// the maximum amount of time to wait for a response

				//RPC
				// "rpcCodec": "",  		// for compression, encoding and decoding <internalRPC | BIRPC | JSON/HTTP/GOB>
				// "serviceMethod": "", 	// the method that should be called trough RPC
				// "keyPath": "" , 		// path to server key 
				// "certPath": "", 		// path to client certificate
				// "caPath": "",  		// path to CA certificate
				// "tls": false, 		
				// "connIDs": [],  		// connections for connManager to this exporter
				// "rpcConnTimeout" : "1s", 	// connection unsuccessful on timeout
				// "rpcReplyTimeout":"2s", 	// connection down at replies if taking longer that this value
				// "rpcAPIOpts": {},
			},					// extra options for exporter
			"fields":[]				// import fields template, tag will match internally CDR field, in case of .csv value will be represented by index of the field value
		}
	]
},


"sessions": {
	"enabled": false,			// starts the session service: <true|false>
	"listen_bijson": "127.0.0.1:2014",	// address where to listen for bidirectional JSON-RPC requests
	"listen_bigob": "",			// address where to listen for bidirectional GOB-RPC requests
	"chargers_conns": [],			// connections to ChargerS for session forking <""|*internal|$rpc_conns_id>
	"rals_conns": [],			// connections to RALs for rating/accounting <""|*internal|$rpc_conns_id>
	"cdrs_conns": [],			// connections to CDRs for CDR posting <""|*internal|$rpc_conns_id>
	"resources_conns": [],			// connections to ResourceS for resources monitoring <""|*internal|$rpc_conns_id>
	"thresholds_conns": [],			// connections to ThresholdS for reporting session events <""|*internal|$rpc_conns_id>
	"stats_conns": [],			// connections to StatS for reporting session events <""|*internal|$rpc_conns_id>
	"routes_conns": [],			// connections to RouteS for querying routes for event <""|*internal|$rpc_conns_id>
	"attributes_conns": [],			// connections to AttributeS for altering event fields <""|*internal|$rpc_conns_id>
	"replication_conns": [],		// replicate sessions towards these session services
	"debit_interval": "0s",			// interval to perform debits on.
	"store_session_costs": false,		// enable storing of the session costs within CDRs
	"default_usage":{			// the usage if the event is missing the usage field
			"*any": "3h",
			"*voice": "3h",
			"*data": "1048576",
			"*sms": "1",
	},
	"session_ttl": "0s",			// time after a session with no updates is terminated, not defined by default
	//"session_ttl_max_delay": "",		// activates session_ttl randomization and limits the maximum possible delay
	//"session_ttl_last_used": "",		// tweak LastUsed for sessions timing-out, not defined by default
	//"session_ttl_usage": "",		// tweak Usage for sessions timing-out, not defined by default
	//"session_last_usage": "",		// tweak LastUsage for session timing-out, not defined by default
	"session_indexes": [],			// index sessions based on these fields for GetActiveSessions API
	"client_protocol": 2.0,			// version of protocol to use when acting as JSON-PRC client <"0","1.0","2.0">
	"channel_sync_interval": "0",		// sync channels to detect stale sessions (0 to disable)
	"stale_chan_max_extra_usage": "0",	// add random usage below max for stale channels
	"terminate_attempts": 5,		// attempts to get the session before terminating it
	"alterable_fields": [],			// the session fields that can be updated
	//"min_dur_low_balance": "5s",		// threshold which will trigger low balance warnings for prepaid calls (needs to be lower than debit_interval)
	"stir": {
		"allowed_attest": ["*any"],	// the default attest for stir/shaken authentication <*any|A|B|C>
		"payload_maxduration": "-1", 	// the duration that stir header is valid after it was created
		"default_attest": "A",		// the default attest level if not mentioned in API
		"publickey_path": "",		// the path to the public key 
		"privatekey_path": "",		// the path to the private key
	},
	"scheduler_conns": [],			// connections to SchedulerS in case of *dynaprepaid request
	"backup_interval": "0s",		// backup active sessions regularly to dataDB: "0" - disables it; "-1" - dump at shutdown; <""|$dur>
},


"asterisk_agent": {
	"enabled": false,			// starts the Asterisk agent: <true|false>
	"sessions_conns": ["*birpc_internal"],
	"create_cdr": false,			// create CDR out of events and sends it to CDRS component
	"asterisk_conns":[			// instantiate connections to multiple Asterisk servers
		{
			"address": "127.0.0.1:8088",
			"user": "cgrates",
			"password": "CGRateS.org",
			"connect_attempts": 3,
			"reconnects": 5,
			"max_reconnect_interval": ""
		}
	]
},


"freeswitch_agent": {
	"enabled": false,				// starts the FreeSWITCH agent: <true|false>
	"sessions_conns": ["*birpc_internal"],
	"subscribe_park": true,				// subscribe via fsock to receive park events
	"create_cdr": false,				// creates CDR out of events and sends them to CDRS component
	"extra_fields": [],				// extra fields to store in auth/CDRs when creating them
	"low_balance_ann_file": "",			// file to be played when low balance is reached for prepaid calls
	"empty_balance_context": "",			// if defined, prepaid calls will be transferred to this context on empty balance
	"empty_balance_ann_file": "",			// file to be played before disconnecting prepaid calls on empty balance (applies only if no context defined)
	"max_wait_connection": "2s",			// maximum duration to wait for a connection to be retrieved from the pool
	"active_session_delimiter": ",",		// delimiter for 'show channels' responses and requests
	"event_socket_conns":[				// instantiate connections to multiple FreeSWITCH servers
		{
			"address": "127.0.0.1:8021", 	// FreeSWITCH server address and port
			"password": "ClueCon",  	// authentication password for FreeSWITCH
			"reconnects": 5, 		// max reconnect attempts before giving up ("-1" for no limit)
			"max_reconnect_interval": "",	// max time between reconnects ("0" for no limit)
			"reply_timeout": "1m",		// max wait time for FreeSWITCH replies
			"alias":""
		}
	]
},


"kamailio_agent": {
	"enabled": false,				// starts Kamailio agent: <true|false>
	"sessions_conns": ["*birpc_internal"],
	"create_cdr": false,				// create CDR out of events and sends them to CDRS component
	"timezone": "",					// timezone of the Kamailio server
	"evapi_conns":[					// instantiate connections to multiple Kamailio servers
		{
			"address": "127.0.0.1:8448",
			"reconnects": 5,
			"max_reconnect_interval": ""
		}
	]
},


"diameter_agent": {
	"enabled": false,						// enables the diameter agent: <true|false>
	"listen": "127.0.0.1:3868",					// address where to listen for diameter requests <x.y.z.y/x1.y1.z1.y1:1234>
	"listen_net": "tcp",						// transport type for diameter <tcp|sctp>
	"dictionaries_path": "/usr/share/cgrates/diameter/dict/",	// path towards directory holding additional dictionaries to load
	"sessions_conns": ["*birpc_internal"],
	"origin_host": "CGR-DA",					// diameter Origin-Host AVP used in replies
	"origin_realm": "cgrates.org",					// diameter Origin-Realm AVP used in replies
	"vendor_id": 0,							// diameter Vendor-Id AVP used in replies
	"product_name": "CGRateS",					// diameter Product-Name AVP used in replies
	"synced_conn_requests": false,					// process one request at the time per connection
	"asr_template": "",						// enable AbortSession message being sent to client on DisconnectSession
	"rar_template": "",						// template used to build the Re-Auth-Request
	"forced_disconnect": "*none",					// the request to send to diameter on DisconnectSession <*none|*asr|*rar>
	"request_processors": []					// list of processors to be applied to diameter messages
},


"radius_agent": {
	"enabled": false,					// enables the radius agent: <true|false>
	"listeners":[
		{
			"network": "udp",			// network to listen on <udp|tcp>
			"auth_address": "127.0.0.1:1812",	// address where to listen for radius authentication requests <x.y.z.y:1234>
			"acct_address": "127.0.0.1:1813"	// address where to listen for radius accounting requests <x.y.z.y:1234>
		}
	],	
	"client_secrets": {					// hash containing secrets for clients connecting here <*default|$client_ip>
		"*default": "CGRateS.org"
	},
	"client_dictionaries": {				// per client path towards directory holding additional dictionaries to load (extra to RFC)
		"*default": [					// key represents the client IP or catch-all <*default|$client_ip>
			"/usr/share/cgrates/radius/dict/",
		]
	},
	"client_da_addresses": { 				// configuration for clients capable of handling Dynamic Authorization (CoA/DM) requests.
		// "nasIdentifier": { 				// identifier for the NAS, typically the host from the initial RADIUS packet.
		// 	"transport": "udp", 			// transport protocol for Dynamic Authorization requests, defaults to UDP.
		// 	"host": "", 				// optionally specify an alternative host for DA requests. Defaults to the NAS identifier if empty.
		// 	"port": 3799, 				// port for Dynamic Authorization requests, default is 3799.
		// 	"flags": [] 				// additional options, currently supports *log for logging DA requests before sending.
		// }
	},
	"requests_cache_key": "",				// used to choose the cache key of a RADIUS packet <RSRParsers>
	"sessions_conns": ["*internal"],
	"dmr_template": "*dmr",					// template used to build the Disconnect-Request packet
	"coa_template": "*coa",					// template used to build the CoA-Request packet
	"request_processors": []				// request processors to be applied to Radius messages
},


"http_agent": [						// HTTP Agents, ie towards cnc.to MVNE platform
],


"dns_agent": {
	"enabled": false,				// enables the DNS agent: <true|false>
	"listeners":[
		{
			"address": "127.0.0.1:53",	// address where to listen for DNS requests <x.y.z.y:1234>
			"network": "udp"		// network to listen on <udp|tcp|tcp-tls>
		}
	],
	"sessions_conns": ["*internal"],
	"timezone": "",					// timezone of the events if not specified  <UTC|Local|$IANA_TZ_DB>
	"request_processors": []			// request processors to be applied to DNS messages
},


"attributes": {					// AttributeS config
	"enabled": false,			// starts attribute service: <true|false>
	"stats_conns": [],			// connections to StatS, empty to disable: <""|*internal|$rpc_conns_id>
	"resources_conns": [],			// connections to ResourceS, empty to disable: <""|*internal|$rpc_conns_id>
	"apiers_conns": [],			// connections to ApierS, empty to disable: <""|*internal|$rpc_conns_id>
	"indexed_selects": true,		// enable profile matching exclusively on indexes
	//"string_indexed_fields": [],		// query indexes based on these fields for faster processing
	"prefix_indexed_fields": [],		// query indexes based on these fields for faster processing
	"suffix_indexed_fields": [],		// query indexes based on these fields for faster processing
	"nested_fields": false,			// determines which field is checked when matching indexed filters(true: all; false: only the one on the first level)
	"any_context": true,			// if we match the *any context
	"opts": {
		"*profileIDs": [],
		"*profileRuns": 0,		// number of runs a profile will process the event
		"*processRuns": 1,		// number of run loops when processing event
		"*profileIgnoreFilters": false
	}
},


"chargers": {				// ChargerS config
	"enabled": false,		// starts charger service: <true|false>.
	"attributes_conns": [],		// connections to AttributeS for event fields altering <""|127.0.0.1:2013>
	"indexed_selects": true,	// enable profile matching exclusively on indexes
	//"string_indexed_fields": [],	// query indexes based on these fields for faster processing
	"prefix_indexed_fields": [],	// query indexes based on these fields for faster processing
	"suffix_indexed_fields": [],	// query indexes based on these fields for faster processing
	"nested_fields": false,		// determines which field is checked when matching indexed filters(true: all; false: only the one on the first level)
},


"resources": {				// ResourceS config
	"enabled": false,		// starts ResourceLimiter service: <true|false>.
	"store_interval": "",		// dump cache regularly to dataDB, 0 - dump at start/shutdown: <""|$dur>
	"thresholds_conns": [],		// connections to ThresholdS for resource reporting, empty to disable thresholds functionality: <""|*internal|$rpc_conns_id>
	"indexed_selects": true,	// enable profile matching exclusively on indexes
	//"string_indexed_fields": [],	// query indexes based on these fields for faster processing
	"prefix_indexed_fields": [],	// query indexes based on these fields for faster processing
	"suffix_indexed_fields": [],	// query indexes based on these fields for faster processing
	"nested_fields": false,		// determines which field is checked when matching indexed filters(true: all; false: only the one on the first level)
	"opts": {
		"*usageID": "",
		// "*usageTTL": "72h",
		"*units": 1,
	},
},


"stats": {				// StatS config
	"enabled": false,		// starts Stat service: <true|false>.
	"store_interval": "",		// dump cache regularly to dataDB, 0 - dump at start/shutdown: <""|$dur>
	"store_uncompressed_limit": 0,	// used to compress data
	"thresholds_conns": [],		// connections to ThresholdS for StatUpdates, empty to disable thresholds functionality: <""|*internal|$rpc_conns_id>
	"ees_conns": [],			// connections to EEs for StatUpdates, empty to disable export functionality: <""|*internal|$rpc_conns_id>
	"ees_exporter_ids": [],		// list of EventExporter profiles to use for real-time StatUpdate exports
	"indexed_selects": true,	// enable profile matching exclusively on indexes
	//"string_indexed_fields": [],	// query indexes based on these fields for faster processing
	"prefix_indexed_fields": [],	// query indexes based on these fields for faster processing
	"suffix_indexed_fields": [],	// query indexes based on these fields for faster processing
	"nested_fields": false,		// determines which field is checked when matching indexed filters(true: all; false: only the one on the first level)
	"opts": {
		"*profileIDs": [],
		"*profileIgnoreFilters": false,
	}
},


"trends":{							// TrendS config
	"enabled": false,				// starts TrendS service: <true|false>.
	"store_interval": "", 			// dump cache regularly to dataDB, 0 - dump at start/shutdown: <""|$dur>
	"store_uncompressed_limit": 0,	// used to compress metrics
	"stats_conns": [],				// connections to StatS, empty to disable stats functionality: <""|*internal|$rpc_conns_id>
	"scheduled_ids": {},			// autoload these trend ids on start
	"thresholds_conns": [],			// connections to ThresholdS for trendSummary reporting, empty to disable thresholds functionality: <""|*internal|$rpc_conns_id>
 	"ees_conns": [],			 	// connections to EEs for trendSummary, empty to disable export functionality: <""|*internal|$rpc_conns_id>
	"ees_exporter_ids": []			// list of EventExporter profiles to use for real-time trendSummary exports 
},


 "rankings":{					// RankingS config
	"enabled": false,			// starts  RankingS service: <true|false>.
	"store_interval": "",		// dump cache regularly to dataDB, 0 - dump at start/shutdown: <""|$dur>
 	"stats_conns": [],			// connections to StatS, empty to disable stats functionality: <""|*internal|$rpc_conns_id>
	"scheduled_ids": {},		// autoload these ranking ids on start
	"thresholds_conns": [],		// connections to ThresholdS for rankingSummary reporting, empty to disable thresholds functionality: <""|*internal|$rpc_conns_id>
 	"ees_conns": [],			// connections to EEs for rankingSummary events, empty to disable export functionality: <""|*internal|$rpc_conns_id>
	"ees_exporter_ids": []		// list of EventExporter profiles to use for real-time rankingSummary exports 
},


"thresholds": {					// ThresholdS
	"enabled": false,			// starts ThresholdS service: <true|false>.
	"store_interval": "",			// dump cache regularly to dataDB, 0 - dump at start/shutdown: <""|$dur>
	"indexed_selects": true,		// enable profile matching exclusively on indexes
	"sessions_conns":[],			// connections to SessionS <*internal|$rpc_conns_id>
	//"string_indexed_fields": [],		// query indexes based on these fields for faster processing
	"prefix_indexed_fields": [],		// query indexes based on these fields for faster processing
	"suffix_indexed_fields": [],		// query indexes based on these fields for faster processing
	"nested_fields": false,			// determines which field is checked when matching indexed filters(true: all; false: only the one on the first level)
	"opts": {
		"*profileIDs": [],
		"*profileIgnoreFilters": false,
	},
},


"routes": {				// RouteS config
	"enabled": false,		// starts RouteS service: <true|false>.
	"indexed_selects": true,	// enable profile matching exclusively on indexes
	//"string_indexed_fields": [],	// query indexes based on these fields for faster processing
	"prefix_indexed_fields": [],	// query indexes based on these fields for faster processing
	"suffix_indexed_fields": [],	// query indexes based on these fields for faster processing
	"nested_fields": false,		// determines which field is checked when matching indexed filters(true: all; false: only the one on the first level)
	"attributes_conns": [],		// connections to AttributeS for altering events before route queries: <""|*internal|$rpc_conns_id>
	"resources_conns": [],		// connections to ResourceS for *res sorting, empty to disable functionality: <""|*internal|$rpc_conns_id>
	"stats_conns": [],		// connections to StatS for *stats sorting, empty to disable stats functionality: <""|*internal|$rpc_conns_id>
	"rals_conns": [],		// connections to Rater for calculating cost, empty to disable stats functionality: <""|*internal|$rpc_conns_id>
	"default_ratio":1,		// default ratio used in case of *load strategy
	"opts": {
		"*context": "*routes",
		// "*profileCount": 1,
		"*ignoreErrors": false,
		"*maxCost": "",
		// "*limit": 1,
		// "*offset": 1,
	},
},


"loaders": [							// LoaderS config
	{
		"id": "*default",				// identifier of the Loader
		"enabled": false,				// starts as service: <true|false>.
		"tenant": "",					// tenant used in filterS.Pass
		"dry_run": false,				// do not send the CDRs to CDRS, just parse them
		"run_delay": "0",				// sleep interval in seconds between consecutive runs, -1 to use automation via inotify or 0 to disable running all together
		"lockfile_path": ".cgr.lck",			// Filename containing concurrency lock in case of delayed processing
		"caches_conns": ["*internal"],
		"field_separator": ",",				// separator used in case of csv files
		"tp_in_dir": "/var/spool/cgrates/loader/in",	// absolute path towards the directory where the TPs are stored
		"tp_out_dir": "/var/spool/cgrates/loader/out",	// absolute path towards the directory where processed TPs will be moved
		"data":[					// data profiles to load
			{
				"type": "*attributes",		// data source type
				"file_name": "Attributes.csv",	// file name in the tp_in_dir
				"fields": [
					{"tag": "TenantID", "path": "Tenant", "type": "*variable", "value": "~*req.0", "mandatory": true},
					{"tag": "ProfileID", "path": "ID", "type": "*variable", "value": "~*req.1", "mandatory": true},
					{"tag": "Contexts", "path": "Contexts", "type": "*variable", "value": "~*req.2"},
					{"tag": "FilterIDs", "path": "FilterIDs", "type": "*variable", "value": "~*req.3"},
					{"tag": "ActivationInterval", "path": "ActivationInterval", "type": "*variable", "value": "~*req.4"},
					{"tag": "AttributeFilterIDs", "path": "AttributeFilterIDs", "type": "*variable", "value": "~*req.5"},
					{"tag": "Path", "path": "Path", "type": "*variable", "value": "~*req.6"},
					{"tag": "Type", "path": "Type", "type": "*variable", "value": "~*req.7"},
					{"tag": "Value", "path": "Value", "type": "*variable", "value": "~*req.8"},
					{"tag": "Blocker", "path": "Blocker", "type": "*variable", "value": "~*req.9"},
					{"tag": "Weight", "path": "Weight", "type": "*variable", "value": "~*req.10"},
				],
			},
			{
				"type": "*filters",		// data source type
				"file_name": "Filters.csv",	// file name in the tp_in_dir
				"fields": [
					{"tag": "Tenant", "path": "Tenant", "type": "*variable", "value": "~*req.0", "mandatory": true},
					{"tag": "ID", "path": "ID", "type": "*variable", "value": "~*req.1", "mandatory": true},
					{"tag": "Type", "path": "Type", "type": "*variable", "value": "~*req.2"},
					{"tag": "Element", "path": "Element", "type": "*variable", "value": "~*req.3"},
					{"tag": "Values", "path": "Values", "type": "*variable", "value": "~*req.4"},
					{"tag": "ActivationInterval", "path": "ActivationInterval", "type": "*variable", "value": "~*req.5"},
				],
			},
			{
				"type": "*resources",		// data source type
				"file_name": "Resources.csv",	// file name in the tp_in_dir
				"fields": [
					{"tag": "Tenant", "path": "Tenant", "type": "*variable", "value": "~*req.0", "mandatory": true},
					{"tag": "ID", "path": "ID", "type": "*variable", "value": "~*req.1", "mandatory": true},
					{"tag": "FilterIDs", "path": "FilterIDs", "type": "*variable", "value": "~*req.2"},
					{"tag": "ActivationInterval", "path": "ActivationInterval", "type": "*variable", "value": "~*req.3"},
					{"tag": "TTL", "path": "UsageTTL", "type": "*variable", "value": "~*req.4"},
					{"tag": "Limit", "path": "Limit", "type": "*variable", "value": "~*req.5"},
					{"tag": "AllocationMessage", "path": "AllocationMessage", "type": "*variable", "value": "~*req.6"},
					{"tag": "Blocker", "path": "Blocker", "type": "*variable", "value": "~*req.7"},
					{"tag": "Stored", "path": "Stored", "type": "*variable", "value": "~*req.8"},
					{"tag": "Weight", "path": "Weight", "type": "*variable", "value": "~*req.9"},
					{"tag": "ThresholdIDs", "path": "ThresholdIDs", "type": "*variable", "value": "~*req.10"},
				],
			},
			{
				"type": "*stats",		// data source type
				"file_name": "Stats.csv",	// file name in the tp_in_dir
				"fields": [
					{"tag": "Tenant", "path": "Tenant", "type": "*variable", "value": "~*req.0", "mandatory": true},
					{"tag": "ID", "path": "ID", "type": "*variable", "value": "~*req.1", "mandatory": true},
					{"tag": "FilterIDs", "path": "FilterIDs", "type": "*variable", "value": "~*req.2"},
					{"tag": "ActivationInterval", "path": "ActivationInterval", "type": "*variable", "value": "~*req.3"},
					{"tag": "QueueLength", "path": "QueueLength", "type": "*variable", "value": "~*req.4"},
					{"tag": "TTL", "path": "TTL", "type": "*variable", "value": "~*req.5"},
					{"tag": "MinItems", "path": "MinItems", "type": "*variable", "value": "~*req.6"},
					{"tag": "MetricIDs", "path": "MetricIDs", "type": "*variable", "value": "~*req.7"},
					{"tag": "MetricFilterIDs", "path": "MetricFilterIDs", "type": "*variable", "value": "~*req.8"},
					{"tag": "Blocker", "path": "Blocker", "type": "*variable", "value": "~*req.9"},
					{"tag": "Stored", "path": "Stored", "type": "*variable", "value": "~*req.10"},
					{"tag": "Weight", "path": "Weight", "type": "*variable", "value": "~*req.11"},
					{"tag": "ThresholdIDs", "path": "ThresholdIDs", "type": "*variable", "value": "~*req.12"},
				],
			},
			{
				"type": "*thresholds",		// data source type
				"file_name": "Thresholds.csv",	// file name in the tp_in_dir
				"fields": [
					{"tag": "Tenant", "path": "Tenant", "type": "*variable", "value": "~*req.0", "mandatory": true},
					{"tag": "ID", "path": "ID", "type": "*variable", "value": "~*req.1", "mandatory": true},
					{"tag": "FilterIDs", "path": "FilterIDs", "type": "*variable", "value": "~*req.2"},
					{"tag": "ActivationInterval", "path": "ActivationInterval", "type": "*variable", "value": "~*req.3"},
					{"tag": "MaxHits", "path": "MaxHits", "type": "*variable", "value": "~*req.4"},
					{"tag": "MinHits", "path": "MinHits", "type": "*variable", "value": "~*req.5"},
					{"tag": "MinSleep", "path": "MinSleep", "type": "*variable", "value": "~*req.6"},
					{"tag": "Blocker", "path": "Blocker", "type": "*variable", "value": "~*req.7"},
					{"tag": "Weight", "path": "Weight", "type": "*variable", "value": "~*req.8"},
					{"tag": "ActionIDs", "path": "ActionIDs", "type": "*variable", "value": "~*req.9"},
					{"tag": "Async", "path": "Async", "type": "*variable", "value": "~*req.10"},
				],
			},
			{
				"type": "*routes",		// data source type
				"file_name": "Routes.csv",	// file name in the tp_in_dir
				"fields": [
					{"tag": "Tenant", "path": "Tenant", "type": "*variable", "value": "~*req.0", "mandatory": true},
					{"tag": "ID", "path": "ID", "type": "*variable", "value": "~*req.1", "mandatory": true},
					{"tag": "FilterIDs", "path": "FilterIDs", "type": "*variable", "value": "~*req.2"},
					{"tag": "ActivationInterval", "path": "ActivationInterval", "type": "*variable", "value": "~*req.3"},
					{"tag": "Sorting", "path": "Sorting", "type": "*variable", "value": "~*req.4"},
					{"tag": "SortingParameters", "path": "SortingParameters", "type": "*variable", "value": "~*req.5"},
					{"tag": "RouteID", "path": "RouteID", "type": "*variable", "value": "~*req.6"},
					{"tag": "RouteFilterIDs", "path": "RouteFilterIDs", "type": "*variable", "value": "~*req.7"},
					{"tag": "RouteAccountIDs", "path": "RouteAccountIDs", "type": "*variable", "value": "~*req.8"},
					{"tag": "RouteRatingPlanIDs", "path": "RouteRatingPlanIDs", "type": "*variable", "value": "~*req.9"},
					{"tag": "RouteResourceIDs", "path": "RouteResourceIDs", "type": "*variable", "value": "~*req.10"},
					{"tag": "RouteStatIDs", "path": "RouteStatIDs", "type": "*variable", "value": "~*req.11"},
					{"tag": "RouteWeight", "path": "RouteWeight", "type": "*variable", "value": "~*req.12"},
					{"tag": "RouteBlocker", "path": "RouteBlocker", "type": "*variable", "value": "~*req.13"},
					{"tag": "RouteParameters", "path": "RouteParameters", "type": "*variable", "value": "~*req.14"},
					{"tag": "Weight", "path": "Weight", "type": "*variable", "value": "~*req.15"},
				],
			},
			{
				"type": "*chargers",		// data source type
				"file_name": "Chargers.csv",	// file name in the tp_in_dir
				"fields": [
					{"tag": "Tenant", "path": "Tenant", "type": "*variable", "value": "~*req.0", "mandatory": true},
					{"tag": "ID", "path": "ID", "type": "*variable", "value": "~*req.1", "mandatory": true},
					{"tag": "FilterIDs", "path": "FilterIDs", "type": "*variable", "value": "~*req.2"},
					{"tag": "ActivationInterval", "path": "ActivationInterval", "type": "*variable", "value": "~*req.3"},
					{"tag": "RunID", "path": "RunID", "type": "*variable", "value": "~*req.4"},
					{"tag": "AttributeIDs", "path": "AttributeIDs", "type": "*variable", "value": "~*req.5"},
					{"tag": "Weight", "path": "Weight", "type": "*variable", "value": "~*req.6"},
				],
			},
			{
				"type": "*dispatchers",			// data source type
				"file_name": "DispatcherProfiles.csv",	// file name in the tp_in_dir
				"fields": [
					{"tag": "Tenant", "path": "Tenant", "type": "*variable", "value": "~*req.0", "mandatory": true},
					{"tag": "ID", "path": "ID", "type": "*variable", "value": "~*req.1", "mandatory": true},
					{"tag": "Contexts", "path": "Contexts", "type": "*variable", "value": "~*req.2"},
					{"tag": "FilterIDs", "path": "FilterIDs", "type": "*variable", "value": "~*req.3"},
					{"tag": "ActivationInterval", "path": "ActivationInterval", "type": "*variable", "value": "~*req.4"},
					{"tag": "Strategy", "path": "Strategy", "type": "*variable", "value": "~*req.5"},
					{"tag": "StrategyParameters", "path": "StrategyParameters", "type": "*variable", "value": "~*req.6"},
					{"tag": "ConnID", "path": "ConnID", "type": "*variable", "value": "~*req.7"},
					{"tag": "ConnFilterIDs", "path": "ConnFilterIDs", "type": "*variable", "value": "~*req.8"},
					{"tag": "ConnWeight", "path": "ConnWeight", "type": "*variable", "value": "~*req.9"},
					{"tag": "ConnBlocker", "path": "ConnBlocker", "type": "*variable", "value": "~*req.10"},
					{"tag": "ConnParameters", "path": "ConnParameters", "type": "*variable", "value": "~*req.11"},
					{"tag": "Weight", "path": "Weight", "type": "*variable", "value": "~*req.12"},
				],
			},
			{
				"type": "*dispatcher_hosts",		// data source type
				"file_name": "DispatcherHosts.csv",	// file name in the tp_in_dir
				"fields": [
					{"tag": "Tenant", "path": "Tenant", "type": "*variable", "value": "~*req.0", "mandatory": true},
					{"tag": "ID", "path": "ID", "type": "*variable", "value": "~*req.1", "mandatory": true},
					{"tag": "Address", "path": "Address", "type": "*variable", "value": "~*req.2"},
					{"tag": "Transport", "path": "Transport", "type": "*variable", "value": "~*req.3"},
					{"tag": "ConnectAttempts", "path": "ConnectAttempts", "type": "*variable", "value":"~*req.4"},
					{"tag": "Reconnects", "path": "Reconnects", "type": "*variable", "value":"~*req.5"},
					{"tag": "MaxReconnectInterval", "path": "MaxReconnectInterval", "type": "*variable", "value":"~*req.6"},
					{"tag": "ConnectTimeout", "path": "ConnectTimeout", "type": "*variable", "value":"~*req.7"},
					{"tag": "ReplyTimeout", "path": "ReplyTimeout", "type": "*variable", "value":"~*req.8"},
					{"tag": "TLS", "path": "TLS", "type": "*variable", "value": "~*req.9"},
					{"tag": "ClientKey", "path": "ClientKey", "type": "*variable", "value":"~*req.10"},
					{"tag": "ClientCertificate", "path": "ClientCertificate", "type": "*variable", "value":"~*req.11"},
					{"tag": "CaCertificate", "path": "CaCertificate", "type": "*variable", "value":"~*req.12"},
				],
			},
		],
	},
],


"mailer": {
	"server": "localhost",					// the server to use when sending emails out
	"auth_user": "cgrates",					// authenticate to email server using this user
	"auth_password": "CGRateS.org",				// authenticate to email server with this password
	"from_address": "cgr-mailer@localhost.localdomain"	// from address used when sending emails out
},


"suretax": {
	"url": "",				// API url
	"client_number": "",			// client number, provided by SureTax
	"validation_key": "",			// validation key provided by SureTax
	"business_unit": "",			// clientâs Business Unit
	"timezone": "Local",			// convert the time of the events to this timezone before sending request out <UTC|Local|$IANA_TZ_DB>
	"include_local_cost": false,		// sum local calculated cost with tax one in final cost
	"return_file_code": "0",		// default or Quote purposes <0|Q>
	"response_group": "03",			// determines how taxes are grouped for the response <03|13>
	"response_type": "D4",			// determines the granularity of taxes and (optionally) the decimal precision for the tax calculations and amounts in the response
	"regulatory_code": "03",		// provider type
	"client_tracking": "~*req.CGRID",	// template extracting client information out of StoredCdr; <RSRParsers>
	"customer_number": "~*req.Subject",	// template extracting customer number out of StoredCdr; <RSRParsers>
	"orig_number":  "~*req.Subject", 	// template extracting origination number out of StoredCdr; <RSRParsers>
	"term_number": "~*req.Destination",	// template extracting termination number out of StoredCdr; <RSRParsers>
	"bill_to_number": "",			// template extracting billed to number out of StoredCdr; <RSRParsers>
	"zipcode": "",				// template extracting billing zip code out of StoredCdr; <RSRParsers>
	"plus4": "",				// template extracting billing zip code extension out of StoredCdr; <RSRParsers>
	"p2pzipcode": "",			// template extracting secondary zip code out of StoredCdr; <RSRParsers>
	"p2pplus4": "",				// template extracting secondary zip code extension out of StoredCdr; <RSRParsers>
	"units": "1",				// template extracting number of âlinesâ or unique charges contained within the revenue out of StoredCdr; <RSRParsers>
	"unit_type": "00",			// template extracting number of unique access lines out of StoredCdr; <RSRParsers>
	"tax_included": "0",			// template extracting tax included in revenue out of StoredCdr; <RSRParsers>
	"tax_situs_rule": "04",			// template extracting tax situs rule out of StoredCdr; <RSRParsers>
	"trans_type_code": "010101",		// template extracting transaction type indicator out of StoredCdr; <RSRParsers>
	"sales_type_code": "R",			// template extracting sales type code out of StoredCdr; <RSRParsers>
	"tax_exemption_code_list": "",		// template extracting tax exemption code list out of StoredCdr; <RSRParsers>
},


"loader": {						// loader for tariff plans out of .csv files
	"tpid": "",					// tariff plan identificator
	"data_path": "./",				// path towards tariff plan files
	"disable_reverse": false,			// disable reverse computing
	"field_separator": ",",				// separator used in case of csv files
	"caches_conns":["*localhost"],
	"scheduler_conns": ["*localhost"],
	"gapi_credentials": ".gapi/credentials.json", 	// the path to the credentials for google API or the credentials.json file content
	"gapi_token": ".gapi/token.json" 		// the path to the token for google API or the token.json file content
},


"migrator": {
	"out_datadb_type": "redis",
	"out_datadb_host": "127.0.0.1",
	"out_datadb_port": "6379",
	"out_datadb_name": "10",
	"out_datadb_user": "cgrates",
	"out_datadb_password": "",
	"out_datadb_encoding" : "msgpack",
	"out_stordb_type": "mysql",
	"out_stordb_host": "127.0.0.1",
	"out_stordb_port": "3306",
	"out_stordb_name": "cgrates",
	"out_stordb_user": "cgrates",
	"out_stordb_password": "",
	"users_filters":[],
	"out_datadb_opts":{
		"redisMaxConns": 10,			// the connection pool size
		"redisConnectAttempts": 20,		// the maximum amount of dial attempts
		"redisSentinel": "",
		"redisCluster": false,
		"redisClusterSync": "5s",
		"redisClusterOndownDelay": "0",
		"redisConnectTimeout": "0",		// the amount of wait time until timeout for a connection attempt
		"redisReadTimeout": "0",		// the amount of wait time until timeout for reading operations
		"redisWriteTimeout": "0",   		// the amount of wait time until timeout for writing operations
		"redisPoolPipelineWindow": "150Âµs",	// duration after which internal pipelines are flushed (0 disables implicit pipelining)
		"redisPoolPipelineLimit": 0,		// maximum number of commands that can be pipelined before flushing (0 means no limit)
		"redisTLS": false,			// enable TLS when connecting to Redis and use the redisClientCertificate, redisClientKey and redisCACertificate for TLS connection
		"redisClientCertificate":"",		// path to client certificate
		"redisClientKey":"",			// path to client key
		"redisCACertificate":"",		// path to CA certificate (populate for self-signed certificate otherwise let it empty)
		"mongoConnScheme": "mongodb"		// scheme for MongoDB connection <mongodb|mongodb+srv>
	},
	"out_stordb_opts":{
		"mongoConnScheme": "mongodb"		// scheme for MongoDB connection <mongodb|mongodb+srv>
	},
},


"dispatchers":{				// DispatcherS config
	"enabled": false,		// starts DispatcherS service: <true|false>.
	"indexed_selects": true,	// enable profile matching exclusively on indexes
	//"string_indexed_fields": [],	// query indexes based on these fields for faster processing
	"prefix_indexed_fields": [],	// query indexes based on these fields for faster processing
	"suffix_indexed_fields": [],	// query indexes based on these fields for faster processing
	"nested_fields": false,		// determines which field is checked when matching indexed filters(true: all; false: only the one on the first level)
	"attributes_conns": [],		// connections to AttributeS for API authorization, empty to disable auth functionality: <""|*internal|$rpc_conns_id>
	"any_subsystem": true,		// if we match the *any subsystem
	"prevent_loops": false,
},


"registrarc":{
    "rpc":{
        "enabled": false,
        "registrars_conns": [],
        "hosts": [],  
        "refresh_interval": "5m",
    },
    "dispatchers":{
        "enabled": false,
        "registrars_conns": [],
        "hosts": [],  
        "refresh_interval": "5m",
    },
},


"analyzers":{						// AnalyzerS config
	"enabled": false,				// starts AnalyzerS service: <true|false>.
 	"db_path": "/var/spool/cgrates/analyzers",	// path to the folder where to store the information
	"index_type": "*scorch",			// the type of index for the storage: <*scorch|*boltdb|*leveldb|*mossdb>
	"ttl": "24h",					// time to wait before removing the API capture
	"cleanup_interval": "1h",			// the interval we clean the db
},


"apiers": {
	"enabled": false,
	"caches_conns":["*internal"],
	"scheduler_conns": [],		// connections to SchedulerS for reloads
	"attributes_conns": [],		// connections to AttributeS for CDRExporter
	"ees_conns": [],		// connections to EEs
},


"sip_agent": {					// SIP Agents, only used for redirections
	"enabled": false,			// enables the SIP agent: <true|false>
	"listen": "127.0.0.1:5060",		// address where to listen for SIP requests <x.y.z.y:1234>
	"listen_net": "udp",			// network to listen on <udp|tcp|tcp-tls>
	"sessions_conns": ["*internal"],
	"timezone": "",				// timezone of the events if not specified  <UTC|Local|$IANA_TZ_DB>
	"retransmission_timer": "1s",		// the duration to wait to receive an ACK before resending the reply
	"request_processors": []		// request processors to be applied to SIP messages
},


"janus_agent": {
	"enabled": false,				// enables the Janus agent: <true|false>
	"url": "/janus",
	"sessions_conns": ["*internal"],
	"janus_conns": [{				// instantiate connections to multiple Janus Servers
		"address": "127.0.0.1:8088",		// janus API address 
		"type": "*ws",				// type of the transport to interact via janus API
		"admin_address": "localhost:7188",	// janus admin address used to retrive more information for sessions and handles
		"admin_password": "",			// secret to pass restriction to communicate to the endpoint
	}],
	"request_processors": [],			// request processors to be applied to Janus messages
},


"templates": {
	"*err": [
		{"tag": "SessionId", "path": "*rep.Session-Id", "type": "*variable",
			"value": "~*req.Session-Id", "mandatory": true},
		{"tag": "OriginHost", "path": "*rep.Origin-Host", "type": "*variable",
			"value": "~*vars.OriginHost", "mandatory": true},
		{"tag": "OriginRealm", "path": "*rep.Origin-Realm", "type": "*variable",
				"value": "~*vars.OriginRealm", "mandatory": true},
	],
	"*cca": [
		{"tag": "SessionId", "path": "*rep.Session-Id", "type": "*variable",
			"value": "~*req.Session-Id", "mandatory": true},
		{"tag": "ResultCode", "path": "*rep.Result-Code", "type": "*constant",
			"value": "2001"},
		{"tag": "OriginHost", "path": "*rep.Origin-Host", "type": "*variable",
			"value": "~*vars.OriginHost", "mandatory": true},
		{"tag": "OriginRealm", "path": "*rep.Origin-Realm", "type": "*variable",
			"value": "~*vars.OriginRealm", "mandatory": true},
		{"tag": "AuthApplicationId", "path": "*rep.Auth-Application-Id", "type": "*variable",
			 "value": "~*vars.*appid", "mandatory": true},
		{"tag": "CCRequestType", "path": "*rep.CC-Request-Type", "type": "*variable",
			"value": "~*req.CC-Request-Type", "mandatory": true},
		{"tag": "CCRequestNumber", "path": "*rep.CC-Request-Number", "type": "*variable",
			"value": "~*req.CC-Request-Number", "mandatory": true},
	],
	"*asr": [
		{"tag": "SessionId", "path": "*diamreq.Session-Id", "type": "*variable",
			"value": "~*req.Session-Id", "mandatory": true},
		{"tag": "OriginHost", "path": "*diamreq.Origin-Host", "type": "*variable",
			"value": "~*req.Destination-Host", "mandatory": true},
		{"tag": "OriginRealm", "path": "*diamreq.Origin-Realm", "type": "*variable",
			"value": "~*req.Destination-Realm", "mandatory": true},
		{"tag": "DestinationRealm", "path": "*diamreq.Destination-Realm", "type": "*variable",
			"value": "~*req.Origin-Realm", "mandatory": true},
		{"tag": "DestinationHost", "path": "*diamreq.Destination-Host", "type": "*variable",
			"value": "~*req.Origin-Host", "mandatory": true},
		{"tag": "AuthApplicationId", "path": "*diamreq.Auth-Application-Id", "type": "*variable",
			"value": "~*vars.*appid", "mandatory": true},
	],
	"*rar": [
		{"tag": "SessionId", "path": "*diamreq.Session-Id", "type": "*variable",
			"value": "~*req.Session-Id", "mandatory": true},
		{"tag": "OriginHost", "path": "*diamreq.Origin-Host", "type": "*variable",
			"value": "~*req.Destination-Host", "mandatory": true},
		{"tag": "OriginRealm", "path": "*diamreq.Origin-Realm", "type": "*variable",
			"value": "~*req.Destination-Realm", "mandatory": true},
		{"tag": "DestinationRealm", "path": "*diamreq.Destination-Realm", "type": "*variable",
			"value": "~*req.Origin-Realm", "mandatory": true},
		{"tag": "DestinationHost", "path": "*diamreq.Destination-Host", "type": "*variable",
			"value": "~*req.Origin-Host", "mandatory": true},
		{"tag": "AuthApplicationId", "path": "*diamreq.Auth-Application-Id", "type": "*variable",
			 "value": "~*vars.*appid", "mandatory": true},
		{"tag": "ReAuthRequestType", "path": "*diamreq.Re-Auth-Request-Type", "type": "*constant",
			"value": "0"},
	],
	"*dmr": [  // used by RadiusAgent when sending Disconnect message towards the client
		{"tag": "User-Name", "path": "*radDAReq.User-Name", "type": "*variable", 
			"value": "~*oreq.User-Name"},
		{"tag": "NAS-IP-Address", "path": "*radDAReq.NAS-IP-Address", "type": "*variable", 
			"value": "~*oreq.NAS-IP-Address"},
		{"tag": "Acct-Session-Id", "path": "*radDAReq.Acct-Session-Id", "type": "*variable", 
			"value": "~*oreq.Acct-Session-Id"},
		{"tag": "Reply-Message", "path": "*radDAReq.Reply-Message", "type": "*variable", 
			"value": "~*req.DisconnectCause"}
	],
	"*coa": [ // used by RadiusAgent when sending ChangeOfAuthorization message towards the client
		{"tag": "User-Name", "path": "*radDAReq.User-Name", "type": "*variable", 
			"value": "~*oreq.User-Name"},
		{"tag": "NAS-IP-Address", "path": "*radDAReq.NAS-IP-Address", "type": "*variable", 
			"value": "~*oreq.NAS-IP-Address"},
		{"tag": "Acct-Session-Id", "path": "*radDAReq.Acct-Session-Id", "type": "*variable", 
			"value": "~*oreq.Acct-Session-Id"},
		{"tag": "Filter-Id", "path": "*radDAReq.Filter-Id", "type": "*variable", 
			"value": "~*req.CustomFilter"}
	],
	"*errSip": [
		{"tag": "Request", "path": "*rep.Request", "type": "*constant",
			"value": "SIP/2.0 500 Internal Server Error", "mandatory": true},
	],
	"*cdrLog": [ // cdrLog template is used in ActionS to build the event that is sent to CDRs in case of *cdrLog actionType
		{"tag": "ToR", "path": "*cdr.ToR", "type": "*variable",
			"value": "~*req.BalanceType", "mandatory": true},
		{"tag": "OriginHost", "path": "*cdr.OriginHost", "type": "*constant",
			"value": "127.0.0.1", "mandatory": true},
		{"tag": "RequestType", "path": "*cdr.RequestType", "type": "*constant",
			"value": "*none", "mandatory": true},
		{"tag": "Tenant", "path": "*cdr.Tenant", "type": "*variable",
			"value": "~*req.Tenant", "mandatory": true},
		{"tag": "Account", "path": "*cdr.Account", "type": "*variable",
			"value": "~*req.Account", "mandatory": true},
		{"tag": "Subject", "path": "*cdr.Subject", "type": "*variable",
			"value": "~*req.Account", "mandatory": true},
		{"tag": "Cost", "path": "*cdr.Cost", "type": "*variable",
			"value": "~*req.Cost", "mandatory": true},
		{"tag": "Source", "path": "*cdr.Source", "type": "*constant",
			"value": "*cdrLog", "mandatory": true},
		{"tag": "Usage", "path": "*cdr.Usage", "type": "*constant",
			"value": "1", "mandatory": true},
		{"tag": "RunID", "path": "*cdr.RunID", "type": "*variable",
			"value": "~*req.ActionType", "mandatory": true},
		{"tag": "SetupTime", "path": "*cdr.SetupTime", "type": "*constant",
			"value": "*now", "mandatory": true},
		{"tag": "AnswerTime", "path": "*cdr.AnswerTime", "type": "*constant",
			"value": "*now", "mandatory": true},
		{"tag": "PreRated", "path": "*cdr.PreRated", "type": "*constant",
			"value": "true", "mandatory": true}
	]
},


"configs": {
	"enabled": false,
	"url": "/configs/",				// configs url 
	"root_dir": "/var/spool/cgrates/configs",	// root directory in case of calling /configs request
},


"apiban": {
	"keys": []
},

"sentrypeer":{
	 "client_id":"",
	 "client_secret":"",
	 "token_url":"https://authz.sentrypeer.com/oauth/token",
	 "ips_url":"https://sentrypeer.com/api/ip-addresses",
	 "numbers_url":"https://sentrypeer.com/api/phone-numbers",
	 "audience":"https://sentrypeer.com/api",
	 "grant_type":"client_credentials"
}

}`
