
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>utils: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cgrates/cgrates/utils/apitpdata.go (100.0%)</option>
				
				<option value="file1">github.com/cgrates/cgrates/utils/basic_auth.go (100.0%)</option>
				
				<option value="file2">github.com/cgrates/cgrates/utils/birpcint_client.go (100.0%)</option>
				
				<option value="file3">github.com/cgrates/cgrates/utils/cgrevent.go (100.0%)</option>
				
				<option value="file4">github.com/cgrates/cgrates/utils/cgrrecordwriter.go (100.0%)</option>
				
				<option value="file5">github.com/cgrates/cgrates/utils/concureqs.go (100.0%)</option>
				
				<option value="file6">github.com/cgrates/cgrates/utils/concureqs_gob_codec.go (0.0%)</option>
				
				<option value="file7">github.com/cgrates/cgrates/utils/concureqs_json_codec.go (0.0%)</option>
				
				<option value="file8">github.com/cgrates/cgrates/utils/consts.go (100.0%)</option>
				
				<option value="file9">github.com/cgrates/cgrates/utils/coreutils.go (82.4%)</option>
				
				<option value="file10">github.com/cgrates/cgrates/utils/dataconverter.go (97.4%)</option>
				
				<option value="file11">github.com/cgrates/cgrates/utils/dataprovider.go (87.5%)</option>
				
				<option value="file12">github.com/cgrates/cgrates/utils/dateseries.go (100.0%)</option>
				
				<option value="file13">github.com/cgrates/cgrates/utils/errors.go (95.2%)</option>
				
				<option value="file14">github.com/cgrates/cgrates/utils/json_codec.go (0.0%)</option>
				
				<option value="file15">github.com/cgrates/cgrates/utils/logger.go (20.0%)</option>
				
				<option value="file16">github.com/cgrates/cgrates/utils/map.go (100.0%)</option>
				
				<option value="file17">github.com/cgrates/cgrates/utils/mapstorage.go (45.5%)</option>
				
				<option value="file18">github.com/cgrates/cgrates/utils/navigablemap.go (100.0%)</option>
				
				<option value="file19">github.com/cgrates/cgrates/utils/nmdata.go (100.0%)</option>
				
				<option value="file20">github.com/cgrates/cgrates/utils/nmslice.go (100.0%)</option>
				
				<option value="file21">github.com/cgrates/cgrates/utils/orderedmap.go (100.0%)</option>
				
				<option value="file22">github.com/cgrates/cgrates/utils/orderednavigablemap.go (93.8%)</option>
				
				<option value="file23">github.com/cgrates/cgrates/utils/pathitem.go (88.0%)</option>
				
				<option value="file24">github.com/cgrates/cgrates/utils/pathitemlist.go (57.1%)</option>
				
				<option value="file25">github.com/cgrates/cgrates/utils/reflect.go (75.0%)</option>
				
				<option value="file26">github.com/cgrates/cgrates/utils/researchreplace.go (100.0%)</option>
				
				<option value="file27">github.com/cgrates/cgrates/utils/rpc_params.go (72.7%)</option>
				
				<option value="file28">github.com/cgrates/cgrates/utils/rsrfield.go (76.4%)</option>
				
				<option value="file29">github.com/cgrates/cgrates/utils/server.go (1.7%)</option>
				
				<option value="file30">github.com/cgrates/cgrates/utils/set.go (100.0%)</option>
				
				<option value="file31">github.com/cgrates/cgrates/utils/slice.go (81.6%)</option>
				
				<option value="file32">github.com/cgrates/cgrates/utils/struct.go (40.3%)</option>
				
				<option value="file33">github.com/cgrates/cgrates/utils/value_formula.go (52.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "fmt"
        "sort"
        "strings"
        "time"
)

// Used to extract ids from stordb
type TPDistinctIds []string

func (tpdi TPDistinctIds) String() string <span class="cov8" title="1">{
        return strings.Join(tpdi, FIELDS_SEP)
}</span>

type PaginatorWithSearch struct {
        *Paginator
        Search string // Global matching pattern in items returned, partially used in some APIs
}

// Paginate stuff around items returned
type Paginator struct {
        Limit  *int // Limit the number of items returned
        Offset *int // Offset of the first item returned (eg: use Limit*Page in case of PerPage items)

}

func (pgnt *Paginator) PaginateStringSlice(in []string) (out []string) <span class="cov8" title="1">{
        if len(in) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">var limit, offset int
        if pgnt.Limit != nil &amp;&amp; *pgnt.Limit &gt; 0 </span><span class="cov8" title="1">{
                limit = *pgnt.Limit
        }</span>
        <span class="cov8" title="1">if pgnt.Offset != nil &amp;&amp; *pgnt.Offset &gt; 0 </span><span class="cov8" title="1">{
                offset = *pgnt.Offset
        }</span>
        <span class="cov8" title="1">if limit == 0 &amp;&amp; offset == 0 </span><span class="cov8" title="1">{
                return in
        }</span>
        <span class="cov8" title="1">if offset &gt; len(in) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if offset != 0 &amp;&amp; limit != 0 </span><span class="cov8" title="1">{
                limit = limit + offset
        }</span>
        <span class="cov8" title="1">if limit == 0 || limit &gt; len(in) </span><span class="cov8" title="1">{
                limit = len(in)
        }</span>
        <span class="cov8" title="1">ret := in[offset:limit]
        out = make([]string, len(ret))
        for i, itm := range ret </span><span class="cov8" title="1">{
                out[i] = itm
        }</span>
        <span class="cov8" title="1">return</span>
}

// TPDestination represents one destination in storDB
type TPDestination struct {
        TPid     string   // Tariff plan id
        ID       string   // Destination id
        Prefixes []string // Prefixes attached to this destination
}

// This file deals with tp_* data definition

type TPRate struct {
        TPid      string      // Tariff plan id
        ID        string      // Rate id
        RateSlots []*RateSlot // One or more RateSlots
}

// Needed so we make sure we always use SetDurations() on a newly created value
func NewRateSlot(connectFee, rate float64, rateUnit, rateIncrement, grpInterval string) (*RateSlot, error) <span class="cov8" title="1">{
        rs := &amp;RateSlot{
                ConnectFee:         connectFee,
                Rate:               rate,
                RateUnit:           rateUnit,
                RateIncrement:      rateIncrement,
                GroupIntervalStart: grpInterval,
        }
        if err := rs.SetDurations(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return rs, nil</span>
}

type RateSlot struct {
        ConnectFee            float64 // ConnectFee applied once the call is answered
        Rate                  float64 // Rate applied
        RateUnit              string  //  Number of billing units this rate applies to
        RateIncrement         string  // This rate will apply in increments of duration
        GroupIntervalStart    string  // Group position
        rateUnitDur           time.Duration
        rateIncrementDur      time.Duration
        groupIntervalStartDur time.Duration
        tag                   string // load validation only
}

// Used to set the durations we need out of strings
func (rs *RateSlot) SetDurations() error <span class="cov8" title="1">{
        var err error
        if rs.rateUnitDur, err = ParseDurationWithNanosecs(rs.RateUnit); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if rs.rateIncrementDur, err = ParseDurationWithNanosecs(rs.RateIncrement); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if rs.groupIntervalStartDur, err = ParseDurationWithNanosecs(rs.GroupIntervalStart); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func (rs *RateSlot) RateUnitDuration() time.Duration <span class="cov8" title="1">{
        return rs.rateUnitDur
}</span>
func (rs *RateSlot) RateIncrementDuration() time.Duration <span class="cov8" title="1">{
        return rs.rateIncrementDur
}</span>
func (rs *RateSlot) GroupIntervalStartDuration() time.Duration <span class="cov8" title="1">{
        return rs.groupIntervalStartDur
}</span>

type TPDestinationRate struct {
        TPid             string             // Tariff plan id
        ID               string             // DestinationRate profile id
        DestinationRates []*DestinationRate // Set of destinationid-rateid bindings
}

type DestinationRate struct {
        DestinationId    string // The destination identity
        RateId           string // The rate identity
        Rate             *TPRate
        RoundingMethod   string
        RoundingDecimals int
        MaxCost          float64
        MaxCostStrategy  string
}

type ApierTPTiming struct {
        TPid      string // Tariff plan id
        ID        string // Timing id
        Years     string // semicolon separated list of years this timing is valid on, *any supported
        Months    string // semicolon separated list of months this timing is valid on, *any supported
        MonthDays string // semicolon separated list of month's days this timing is valid on, *any supported
        WeekDays  string // semicolon separated list of week day names this timing is valid on *any supported
        Time      string // String representing the time this timing starts on
}

type TPTiming struct {
        ID        string
        Years     Years
        Months    Months
        MonthDays MonthDays
        WeekDays  WeekDays
        StartTime string
        EndTime   string
}

func NewTiming(ID, years, mounths, mounthdays, weekdays, time string) (rt *TPTiming) <span class="cov8" title="1">{
        rt = &amp;TPTiming{}
        rt.ID = ID
        rt.Years.Parse(years, INFIELD_SEP)
        rt.Months.Parse(mounths, INFIELD_SEP)
        rt.MonthDays.Parse(mounthdays, INFIELD_SEP)
        rt.WeekDays.Parse(weekdays, INFIELD_SEP)
        times := strings.Split(time, INFIELD_SEP)
        rt.StartTime = times[0]
        if len(times) &gt; 1 </span><span class="cov8" title="1">{
                rt.EndTime = times[1]
        }</span>
        <span class="cov8" title="1">return</span>
}

type TPRatingPlan struct {
        TPid               string                 // Tariff plan id
        ID                 string                 // RatingPlan profile id
        RatingPlanBindings []*TPRatingPlanBinding // Set of destinationid-rateid bindings
}

type TPRatingPlanBinding struct {
        DestinationRatesId string    // The DestinationRate identity
        TimingId           string    // The timing identity
        Weight             float64   // Binding priority taken into consideration when more DestinationRates are active on a time slot
        timing             *TPTiming // Not exporting it via JSON
}

func (self *TPRatingPlanBinding) SetTiming(tm *TPTiming) <span class="cov8" title="1">{
        self.timing = tm
}</span>

func (self *TPRatingPlanBinding) Timing() *TPTiming <span class="cov8" title="1">{
        return self.timing
}</span>

type TPRatingProfile struct {
        TPid                  string                // Tariff plan id
        LoadId                string                // Gives ability to load specific RatingProfile based on load identifier, hence being able to keep history also in stordb
        Tenant                string                // Tenant's Id
        Category              string                // TypeOfRecord
        Subject               string                // Rating subject, usually the same as account
        RatingPlanActivations []*TPRatingActivation // Activate rate profiles at specific time
}

// Used as key in nosql db (eg: redis)
func (rpf *TPRatingProfile) KeyId() string <span class="cov8" title="1">{
        return ConcatenatedKey(META_OUT,
                rpf.Tenant, rpf.Category, rpf.Subject)
}</span>

func (rpf *TPRatingProfile) GetId() string <span class="cov8" title="1">{
        return ConcatenatedKey(rpf.LoadId, META_OUT,
                rpf.Tenant, rpf.Category, rpf.Subject)
}</span>

func (rpf *TPRatingProfile) SetRatingProfileID(id string) error <span class="cov8" title="1">{
        ids := strings.Split(id, CONCATENATED_KEY_SEP)
        if len(ids) != 4 </span><span class="cov8" title="1">{
                return fmt.Errorf("Wrong TPRatingProfileId: %s", id)
        }</span>
        <span class="cov8" title="1">rpf.LoadId = ids[0]
        rpf.Tenant = ids[1]
        rpf.Category = ids[2]
        rpf.Subject = ids[3]
        return nil</span>
}

type AttrSetRatingProfile struct {
        Tenant                string                // Tenant's Id
        Category              string                // TypeOfRecord
        Subject               string                // Rating subject, usually the same as account
        Overwrite             bool                  // Overwrite if exists
        RatingPlanActivations []*TPRatingActivation // Activate rating plans at specific time
        Cache                 *string
}

type AttrGetRatingProfile struct {
        Tenant   string // Tenant's Id
        Category string // TypeOfRecord
        Subject  string // Rating subject, usually the same as account
}

func (self *AttrGetRatingProfile) GetID() string <span class="cov8" title="1">{
        return ConcatenatedKey(META_OUT, self.Tenant, self.Category, self.Subject)
}</span>

type TPRatingActivation struct {
        ActivationTime   string // Time when this profile will become active, defined as unix epoch time
        RatingPlanId     string // Id of RatingPlan profile
        FallbackSubjects string // So we follow the api
}

// Helper to return the subject fallback keys we need in dataDb
func FallbackSubjKeys(tenant, tor, fallbackSubjects string) []string <span class="cov8" title="1">{
        var sslice sort.StringSlice
        if len(fallbackSubjects) != 0 </span><span class="cov8" title="1">{
                for _, fbs := range strings.Split(fallbackSubjects, string(FALLBACK_SEP)) </span><span class="cov8" title="1">{
                        newKey := ConcatenatedKey(META_OUT, tenant, tor, fbs)
                        i := sslice.Search(newKey)
                        if i &lt; len(sslice) &amp;&amp; sslice[i] != newKey </span><span class="cov8" title="1">{
                                // not found so insert it
                                sslice = append(sslice, "")
                                copy(sslice[i+1:], sslice[i:])
                                sslice[i] = newKey
                        }</span> else<span class="cov8" title="1"> if i == len(sslice) </span><span class="cov8" title="1">{
                                // not found and at the end
                                sslice = append(sslice, newKey)
                        }</span> // newKey was found
                }
        }
        <span class="cov8" title="1">return sslice</span>
}

type AttrSetDestination struct {
        Id        string
        Prefixes  []string
        Overwrite bool
}

type AttrTPRatingProfileIds struct {
        TPid     string // Tariff plan id
        Tenant   string // Tenant's Id
        Category string // TypeOfRecord
        Subject  string // Rating subject, usually the same as account
}

type TPActions struct {
        TPid    string      // Tariff plan id
        ID      string      // Actions id
        Actions []*TPAction // Set of actions this Actions profile will perform
}

type TPAction struct {
        Identifier      string // Identifier mapped in the code
        BalanceId       string // Balance identification string (account scope)
        BalanceUuid     string // Balance identification string (global scope)
        BalanceType     string // Type of balance the action will operate on
        Units           string // Number of units to add/deduct
        ExpiryTime      string // Time when the units will expire
        Filter          string // The condition on balances that is checked before the action
        TimingTags      string // Timing when balance is active
        DestinationIds  string // Destination profile id
        RatingSubject   string // Reference a rate subject defined in RatingProfiles
        Categories      string // category filter for balances
        SharedGroups    string // Reference to a shared group
        BalanceWeight   string // Balance weight
        ExtraParameters string
        BalanceBlocker  string
        BalanceDisabled string
        Weight          float64 // Action's weight
}

type TPSharedGroups struct {
        TPid         string
        ID           string
        SharedGroups []*TPSharedGroup
}

type TPSharedGroup struct {
        Account       string
        Strategy      string
        RatingSubject string
}

type TPActionPlan struct {
        TPid       string            // Tariff plan id
        ID         string            // ActionPlan id
        ActionPlan []*TPActionTiming // Set of ActionTiming bindings this profile will group
}

type TPActionTiming struct {
        ActionsId string  // Actions id
        TimingId  string  // Timing profile id
        Weight    float64 // Binding's weight
}

type TPActionTriggers struct {
        TPid           string             // Tariff plan id
        ID             string             // action trigger id
        ActionTriggers []*TPActionTrigger // Set of triggers grouped in this profile
}

type TPActionTrigger struct {
        Id                    string  // group id
        UniqueID              string  // individual id
        ThresholdType         string  // This threshold type
        ThresholdValue        float64 // Threshold
        Recurrent             bool    // reset executed flag each run
        MinSleep              string  // Minimum duration between two executions in case of recurrent triggers
        ExpirationDate        string  // Trigger expiration
        ActivationDate        string  // Trigger activation
        BalanceId             string  // The id of the balance in the account
        BalanceType           string  // Type of balance this trigger monitors
        BalanceDestinationIds string  // filter for balance
        BalanceWeight         string  // filter for balance
        BalanceExpirationDate string  // filter for balance
        BalanceTimingTags     string  // filter for balance
        BalanceRatingSubject  string  // filter for balance
        BalanceCategories     string  // filter for balance
        BalanceSharedGroups   string  // filter for balance
        BalanceBlocker        string  // filter for balance
        BalanceDisabled       string  // filter for balance
        ActionsId             string  // Actions which will execute on threshold reached
        Weight                float64 // weight
}

type TPAccountActions struct {
        TPid             string // Tariff plan id
        LoadId           string // LoadId, used to group actions on a load
        Tenant           string // Tenant's Id
        Account          string // Account name
        ActionPlanId     string // Id of ActionPlan profile to use
        ActionTriggersId string // Id of ActionTriggers profile to use
        AllowNegative    bool
        Disabled         bool
}

// Returns the id used in some nosql dbs (eg: redis)
func (aa *TPAccountActions) KeyId() string <span class="cov8" title="1">{
        return ConcatenatedKey(aa.Tenant, aa.Account)
}</span>

func (aa *TPAccountActions) GetId() string <span class="cov8" title="1">{
        return aa.LoadId + CONCATENATED_KEY_SEP + aa.Tenant + CONCATENATED_KEY_SEP + aa.Account
}</span>

func (aa *TPAccountActions) SetAccountActionsId(id string) error <span class="cov8" title="1">{
        ids := strings.Split(id, CONCATENATED_KEY_SEP)
        if len(ids) != 3 </span><span class="cov8" title="1">{
                return fmt.Errorf("Wrong TP Account Action Id: %s", id)
        }</span>
        <span class="cov8" title="1">aa.LoadId = ids[0]
        aa.Tenant = ids[1]
        aa.Account = ids[2]
        return nil</span>
}

type AttrGetAccount struct {
        Tenant  string
        Account string
}

type AttrGetAccounts struct {
        Tenant     string
        AccountIDs []string
        Offset     int // Set the item offset
        Limit      int // Limit number of items retrieved
        Filter     map[string]bool
}

type ArgsCache struct {
        DestinationIDs        []string
        ReverseDestinationIDs []string
        RatingPlanIDs         []string
        RatingProfileIDs      []string
        ActionIDs             []string
        ActionPlanIDs         []string
        AccountActionPlanIDs  []string
        ActionTriggerIDs      []string
        SharedGroupIDs        []string
        ResourceProfileIDs    []string
        ResourceIDs           []string
        StatsQueueIDs         []string
        StatsQueueProfileIDs  []string
        ThresholdIDs          []string
        ThresholdProfileIDs   []string
        FilterIDs             []string
        SupplierProfileIDs    []string
        AttributeProfileIDs   []string
        ChargerProfileIDs     []string
        DispatcherProfileIDs  []string
        DispatcherHostIDs     []string
        DispatcherRoutesIDs   []string
}

// Data used to do remote cache reloads via api
type AttrReloadCache struct {
        ArgsCache
        FlushAll bool // If provided, cache flush will be executed before any action
}

// InitAttrReloadCache initialize AttrReloadCache with empty string slice
func InitAttrReloadCache() (rpl AttrReloadCache) <span class="cov8" title="1">{
        rpl.DestinationIDs = []string{}
        rpl.ReverseDestinationIDs = []string{}
        rpl.RatingPlanIDs = []string{}
        rpl.RatingProfileIDs = []string{}
        rpl.ActionIDs = []string{}
        rpl.ActionPlanIDs = []string{}
        rpl.AccountActionPlanIDs = []string{}
        rpl.ActionTriggerIDs = []string{}
        rpl.SharedGroupIDs = []string{}
        rpl.ResourceProfileIDs = []string{}
        rpl.ResourceIDs = []string{}
        rpl.StatsQueueIDs = []string{}
        rpl.StatsQueueProfileIDs = []string{}
        rpl.ThresholdIDs = []string{}
        rpl.ThresholdProfileIDs = []string{}
        rpl.FilterIDs = []string{}
        rpl.SupplierProfileIDs = []string{}
        rpl.AttributeProfileIDs = []string{}
        rpl.ChargerProfileIDs = []string{}
        rpl.DispatcherProfileIDs = []string{}
        rpl.DispatcherHostIDs = []string{}
        rpl.DispatcherRoutesIDs = []string{}
        return
}</span>

type CacheKeys struct {
}

type AttrExpFileCdrs struct {
        CdrFormat           *string  // Cdr output file format &lt;CdreCdrFormats&gt;
        FieldSeparator      *string  // Separator used between fields
        ExportId            *string  // Optional exportid
        ExportDir           *string  // If provided it overwrites the configured export directory
        ExportFileName      *string  // If provided the output filename will be set to this
        ExportTemplate      *string  // Exported fields template  &lt;""|fld1,fld2|*xml:instance_name&gt;
        CgrIds              []string // If provided, it will filter based on the cgrids present in list
        MediationRunIds     []string // If provided, it will filter on mediation runid
        TORs                []string // If provided, filter on TypeOfRecord
        CdrHosts            []string // If provided, it will filter cdrhost
        CdrSources          []string // If provided, it will filter cdrsource
        ReqTypes            []string // If provided, it will fiter reqtype
        Tenants             []string // If provided, it will filter tenant
        Categories          []string // If provided, it will filter çategory
        Accounts            []string // If provided, it will filter account
        Subjects            []string // If provided, it will filter the rating subject
        DestinationPrefixes []string // If provided, it will filter on destination prefix
        OrderIdStart        *int64   // Export from this order identifier
        OrderIdEnd          *int64   // Export smaller than this order identifier
        TimeStart           string   // If provided, it will represent the starting of the CDRs interval (&gt;=)
        TimeEnd             string   // If provided, it will represent the end of the CDRs interval (&lt;)
        SkipErrors          bool     // Do not export errored CDRs
        SkipRated           bool     // Do not export rated CDRs
        SuppressCgrIds      bool     // Disable CgrIds reporting in reply/ExportedCgrIds and reply/UnexportedCgrIds
        Paginator
}

func (aefc *AttrExpFileCdrs) AsCDRsFilter(timezone string) (*CDRsFilter, error) <span class="cov8" title="1">{
        cdrFltr := &amp;CDRsFilter{
                CGRIDs:              aefc.CgrIds,
                RunIDs:              aefc.MediationRunIds,
                ToRs:                aefc.TORs,
                OriginHosts:         aefc.CdrHosts,
                Sources:             aefc.CdrSources,
                RequestTypes:        aefc.ReqTypes,
                Tenants:             aefc.Tenants,
                Categories:          aefc.Categories,
                Accounts:            aefc.Accounts,
                Subjects:            aefc.Subjects,
                DestinationPrefixes: aefc.DestinationPrefixes,
                OrderIDStart:        aefc.OrderIdStart,
                OrderIDEnd:          aefc.OrderIdEnd,
                Paginator:           aefc.Paginator,
        }
        if len(aefc.TimeStart) != 0 </span><span class="cov8" title="1">{
                if answerTimeStart, err := ParseTimeDetectLayout(aefc.TimeStart, timezone); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        cdrFltr.AnswerTimeStart = &amp;answerTimeStart
                }</span>
        }
        <span class="cov8" title="1">if len(aefc.TimeEnd) != 0 </span><span class="cov8" title="1">{
                if answerTimeEnd, err := ParseTimeDetectLayout(aefc.TimeEnd, timezone); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        cdrFltr.AnswerTimeEnd = &amp;answerTimeEnd
                }</span>
        }
        <span class="cov8" title="1">if aefc.SkipRated </span><span class="cov8" title="1">{
                cdrFltr.MaxCost = Float64Pointer(-1.0)
        }</span> else<span class="cov8" title="1"> if aefc.SkipErrors </span><span class="cov8" title="1">{
                cdrFltr.MinCost = Float64Pointer(0.0)
                cdrFltr.MaxCost = Float64Pointer(-1.0)
        }</span>
        <span class="cov8" title="1">return cdrFltr, nil</span>
}

type ExportedFileCdrs struct {
        ExportedFilePath          string            // Full path to the newly generated export file
        TotalRecords              int               // Number of CDRs to be exported
        TotalCost                 float64           // Sum of all costs in exported CDRs
        FirstOrderId, LastOrderId int64             // The order id of the last exported CDR
        ExportedCgrIds            []string          // List of successfuly exported cgrids in the file
        UnexportedCgrIds          map[string]string // Map of errored CDRs, map key is cgrid, value will be the error string
}

type AttrGetCdrs struct {
        CgrIds          []string // If provided, it will filter based on the cgrids present in list
        MediationRunIds []string // If provided, it will filter on mediation runid

        TORs                []string // If provided, filter on TypeOfRecord
        CdrHosts            []string // If provided, it will filter cdrhost
        CdrSources          []string // If provided, it will filter cdrsource
        ReqTypes            []string // If provided, it will fiter reqtype
        Tenants             []string // If provided, it will filter tenant
        Categories          []string // If provided, it will filter çategory
        Accounts            []string // If provided, it will filter account
        Subjects            []string // If provided, it will filter the rating subject
        DestinationPrefixes []string // If provided, it will filter on destination prefix
        RatedAccounts       []string // If provided, it will filter ratedaccount
        RatedSubjects       []string // If provided, it will filter the ratedsubject
        OrderIdStart        *int64   // Export from this order identifier
        OrderIdEnd          *int64   // Export smaller than this order identifier
        TimeStart           string   // If provided, it will represent the starting of the CDRs interval (&gt;=)
        TimeEnd             string   // If provided, it will represent the end of the CDRs interval (&lt;)
        SkipErrors          bool     // Do not export errored CDRs
        SkipRated           bool     // Do not export rated CDRs
        OrderBy             string   // Ascendent/Descendent
        Paginator
}

func (fltr *AttrGetCdrs) AsCDRsFilter(timezone string) (cdrFltr *CDRsFilter, err error) <span class="cov8" title="1">{
        if fltr == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">cdrFltr = &amp;CDRsFilter{
                CGRIDs:              fltr.CgrIds,
                RunIDs:              fltr.MediationRunIds,
                ToRs:                fltr.TORs,
                OriginHosts:         fltr.CdrHosts,
                Sources:             fltr.CdrSources,
                RequestTypes:        fltr.ReqTypes,
                Tenants:             fltr.Tenants,
                Categories:          fltr.Categories,
                Accounts:            fltr.Accounts,
                Subjects:            fltr.Subjects,
                DestinationPrefixes: fltr.DestinationPrefixes,
                OrderIDStart:        fltr.OrderIdStart,
                OrderIDEnd:          fltr.OrderIdEnd,
                Paginator:           fltr.Paginator,
                OrderBy:             fltr.OrderBy,
        }
        if len(fltr.TimeStart) != 0 </span><span class="cov8" title="1">{
                if answerTimeStart, err := ParseTimeDetectLayout(fltr.TimeStart, timezone); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        cdrFltr.AnswerTimeStart = &amp;answerTimeStart
                }</span>
        }
        <span class="cov8" title="1">if len(fltr.TimeEnd) != 0 </span><span class="cov8" title="1">{
                if answerTimeEnd, err := ParseTimeDetectLayout(fltr.TimeEnd, timezone); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        cdrFltr.AnswerTimeEnd = &amp;answerTimeEnd
                }</span>
        }
        <span class="cov8" title="1">if fltr.SkipRated </span><span class="cov8" title="1">{
                cdrFltr.MaxCost = Float64Pointer(-1.0)
        }</span> else<span class="cov8" title="1"> if fltr.SkipErrors </span><span class="cov8" title="1">{
                cdrFltr.MinCost = Float64Pointer(0.0)
                cdrFltr.MaxCost = Float64Pointer(-1.0)
        }</span>
        <span class="cov8" title="1">return</span>
}

type AttrLoadTpFromFolder struct {
        FolderPath    string // Take files from folder absolute path
        DryRun        bool   // Do not write to database but parse only
        Validate      bool   // Run structural checks on data
        Recursive     bool   // load data recursive
        ArgDispatcher *ArgDispatcher
        Caching       *string
}

type AttrImportTPFromFolder struct {
        TPid          string
        FolderPath    string
        RunId         string
        CsvSeparator  string
        ArgDispatcher *ArgDispatcher
}

func NewTAFromAccountKey(accountKey string) (*TenantAccount, error) <span class="cov8" title="1">{
        accountSplt := strings.Split(accountKey, CONCATENATED_KEY_SEP)
        if len(accountSplt) != 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Unsupported format for TenantAccount: %s", accountKey)
        }</span>
        <span class="cov8" title="1">return &amp;TenantAccount{accountSplt[0], accountSplt[1]}, nil</span>
}

type TenantAccount struct {
        Tenant, Account string
}

type AttrDirExportTP struct {
        TPid           *string
        FileFormat     *string // Format of the exported file &lt;csv&gt;
        FieldSeparator *string // Separator used between fields
        ExportPath     *string // If provided it overwrites the configured export path
        Compress       *bool   // If true the folder will be compressed after export performed
}

type ExportedTPStats struct {
        ExportPath    string   // Full path to the newly generated export file
        ExportedFiles []string // List of exported files
        Compressed    bool
}

// CDRsFilter is a filter used to get records out of storDB
type CDRsFilter struct {
        CGRIDs                 []string          // If provided, it will filter based on the cgrids present in list
        NotCGRIDs              []string          // Filter specific CgrIds out
        RunIDs                 []string          // If provided, it will filter on mediation runid
        NotRunIDs              []string          // Filter specific runIds out
        OriginIDs              []string          // If provided, it will filter on OriginIDs
        NotOriginIDs           []string          // Filter specific OriginIDs out
        OriginHosts            []string          // If provided, it will filter cdrhost
        NotOriginHosts         []string          // Filter out specific cdr hosts
        Sources                []string          // If provided, it will filter cdrsource
        NotSources             []string          // Filter out specific CDR sources
        ToRs                   []string          // If provided, filter on TypeOfRecord
        NotToRs                []string          // Filter specific TORs out
        RequestTypes           []string          // If provided, it will fiter reqtype
        NotRequestTypes        []string          // Filter out specific request types
        Tenants                []string          // If provided, it will filter tenant
        NotTenants             []string          // If provided, it will filter tenant
        Categories             []string          // If provided, it will filter çategory
        NotCategories          []string          // Filter out specific categories
        Accounts               []string          // If provided, it will filter account
        NotAccounts            []string          // Filter out specific Accounts
        Subjects               []string          // If provided, it will filter the rating subject
        NotSubjects            []string          // Filter out specific subjects
        DestinationPrefixes    []string          // If provided, it will filter on destination prefix
        NotDestinationPrefixes []string          // Filter out specific destination prefixes
        Costs                  []float64         // Query based on costs specified
        NotCosts               []float64         // Filter out specific costs out from result
        ExtraFields            map[string]string // Query based on extra fields content
        NotExtraFields         map[string]string // Filter out based on extra fields content
        OrderIDStart           *int64            // Export from this order identifier
        OrderIDEnd             *int64            // Export smaller than this order identifier
        SetupTimeStart         *time.Time        // Start of interval, bigger or equal than configured
        SetupTimeEnd           *time.Time        // End interval, smaller than setupTime
        AnswerTimeStart        *time.Time        // Start of interval, bigger or equal than configured
        AnswerTimeEnd          *time.Time        // End interval, smaller than answerTime
        CreatedAtStart         *time.Time        // Start of interval, bigger or equal than configured
        CreatedAtEnd           *time.Time        // End interval, smaller than
        UpdatedAtStart         *time.Time        // Start of interval, bigger or equal than configured
        UpdatedAtEnd           *time.Time        // End interval, smaller than
        MinUsage               string            // Start of the usage interval (&gt;=)
        MaxUsage               string            // End of the usage interval (&lt;)
        MinCost                *float64          // Start of the cost interval (&gt;=)
        MaxCost                *float64          // End of the usage interval (&lt;)
        Unscoped               bool              // Include soft-deleted records in results
        Count                  bool              // If true count the items instead of returning data
        OrderBy                string            // Can be ordered by OrderID,AnswerTime,SetupTime,Cost,Usage
        Paginator
}

// Prepare will sort all the slices in order to search more faster
func (fltr *CDRsFilter) Prepare() <span class="cov8" title="1">{
        sort.Strings(fltr.CGRIDs)
        sort.Strings(fltr.NotCGRIDs)
        sort.Strings(fltr.RunIDs)
        sort.Strings(fltr.NotRunIDs)
        sort.Strings(fltr.OriginIDs)
        sort.Strings(fltr.NotOriginIDs)
        sort.Strings(fltr.OriginHosts)
        sort.Strings(fltr.NotOriginHosts)
        sort.Strings(fltr.Sources)
        sort.Strings(fltr.NotSources)
        sort.Strings(fltr.ToRs)
        sort.Strings(fltr.NotToRs)
        sort.Strings(fltr.RequestTypes)
        sort.Strings(fltr.NotRequestTypes)
        sort.Strings(fltr.Tenants)
        sort.Strings(fltr.NotTenants)
        sort.Strings(fltr.Categories)
        sort.Strings(fltr.NotCategories)
        sort.Strings(fltr.Accounts)
        sort.Strings(fltr.NotAccounts)
        sort.Strings(fltr.Subjects)
        sort.Strings(fltr.NotSubjects)
        // sort.Strings(fltr.DestinationPrefixes)
        // sort.Strings(fltr.NotDestinationPrefixes)

        sort.Float64s(fltr.Costs)
        sort.Float64s(fltr.NotCosts)
}</span>

// RPCCDRsFilter is a filter used in Rpc calls
// RPCCDRsFilter is slightly different than CDRsFilter by using string instead of Time filters
type RPCCDRsFilter struct {
        CGRIDs                 []string          // If provided, it will filter based on the cgrids present in list
        NotCGRIDs              []string          // Filter specific CgrIds out
        RunIDs                 []string          // If provided, it will filter on mediation runid
        NotRunIDs              []string          // Filter specific runIds out
        OriginIDs              []string          // If provided, it will filter on OriginIDs
        NotOriginIDs           []string          // Filter specific OriginIDs out
        OriginHosts            []string          // If provided, it will filter cdrhost
        NotOriginHosts         []string          // Filter out specific cdr hosts
        Sources                []string          // If provided, it will filter cdrsource
        NotSources             []string          // Filter out specific CDR sources
        ToRs                   []string          // If provided, filter on TypeOfRecord
        NotToRs                []string          // Filter specific TORs out
        RequestTypes           []string          // If provided, it will fiter reqtype
        NotRequestTypes        []string          // Filter out specific request types
        Tenants                []string          // If provided, it will filter tenant
        NotTenants             []string          // If provided, it will filter tenant
        Categories             []string          // If provided, it will filter çategory
        NotCategories          []string          // Filter out specific categories
        Accounts               []string          // If provided, it will filter account
        NotAccounts            []string          // Filter out specific Accounts
        Subjects               []string          // If provided, it will filter the rating subject
        NotSubjects            []string          // Filter out specific subjects
        DestinationPrefixes    []string          // If provided, it will filter on destination prefix
        NotDestinationPrefixes []string          // Filter out specific destination prefixes
        Costs                  []float64         // Query based on costs specified
        NotCosts               []float64         // Filter out specific costs out from result
        ExtraFields            map[string]string // Query based on extra fields content
        NotExtraFields         map[string]string // Filter out based on extra fields content
        SetupTimeStart         string            // Start of interval, bigger or equal than configured
        SetupTimeEnd           string            // End interval, smaller than setupTime
        AnswerTimeStart        string            // Start of interval, bigger or equal than configured
        AnswerTimeEnd          string            // End interval, smaller than answerTime
        CreatedAtStart         string            // Start of interval, bigger or equal than configured
        CreatedAtEnd           string            // End interval, smaller than
        UpdatedAtStart         string            // Start of interval, bigger or equal than configured
        UpdatedAtEnd           string            // End interval, smaller than
        MinUsage               string            // Start of the usage interval (&gt;=)
        MaxUsage               string            // End of the usage interval (&lt;)
        OrderBy                string            // Ascendent/Descendent
        ExtraArgs              map[string]any    // it will contain optional arguments like: OrderIDStart,OrderIDEnd,MinCost and MaxCost
        Paginator                                // Add pagination
}

func (fltr *RPCCDRsFilter) AsCDRsFilter(timezone string) (cdrFltr *CDRsFilter, err error) <span class="cov8" title="1">{
        if fltr == nil </span><span class="cov8" title="1">{
                cdrFltr = new(CDRsFilter)
                return
        }</span>
        <span class="cov8" title="1">cdrFltr = &amp;CDRsFilter{
                CGRIDs:                 fltr.CGRIDs,
                NotCGRIDs:              fltr.NotCGRIDs,
                RunIDs:                 fltr.RunIDs,
                NotRunIDs:              fltr.NotRunIDs,
                OriginIDs:              fltr.OriginIDs,
                NotOriginIDs:           fltr.NotOriginIDs,
                ToRs:                   fltr.ToRs,
                NotToRs:                fltr.NotToRs,
                OriginHosts:            fltr.OriginHosts,
                NotOriginHosts:         fltr.NotOriginHosts,
                Sources:                fltr.Sources,
                NotSources:             fltr.NotSources,
                RequestTypes:           fltr.RequestTypes,
                NotRequestTypes:        fltr.NotRequestTypes,
                Tenants:                fltr.Tenants,
                NotTenants:             fltr.NotTenants,
                Categories:             fltr.Categories,
                NotCategories:          fltr.NotCategories,
                Accounts:               fltr.Accounts,
                NotAccounts:            fltr.NotAccounts,
                Subjects:               fltr.Subjects,
                NotSubjects:            fltr.NotSubjects,
                DestinationPrefixes:    fltr.DestinationPrefixes,
                NotDestinationPrefixes: fltr.NotDestinationPrefixes,
                Costs:                  fltr.Costs,
                NotCosts:               fltr.NotCosts,
                ExtraFields:            fltr.ExtraFields,
                NotExtraFields:         fltr.NotExtraFields,
                MinUsage:               fltr.MinUsage,
                MaxUsage:               fltr.MaxUsage,
                Paginator:              fltr.Paginator,
                OrderBy:                fltr.OrderBy,
        }
        if len(fltr.SetupTimeStart) != 0 </span><span class="cov8" title="1">{
                var sTimeStart time.Time
                if sTimeStart, err = ParseTimeDetectLayout(fltr.SetupTimeStart, timezone); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">cdrFltr.SetupTimeStart = TimePointer(sTimeStart)</span>
        }
        <span class="cov8" title="1">if len(fltr.SetupTimeEnd) != 0 </span><span class="cov8" title="1">{
                var sTimeEnd time.Time
                if sTimeEnd, err = ParseTimeDetectLayout(fltr.SetupTimeEnd, timezone); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">cdrFltr.SetupTimeEnd = TimePointer(sTimeEnd)</span>
        }
        <span class="cov8" title="1">if len(fltr.AnswerTimeStart) != 0 </span><span class="cov8" title="1">{
                var aTimeStart time.Time
                if aTimeStart, err = ParseTimeDetectLayout(fltr.AnswerTimeStart, timezone); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">cdrFltr.AnswerTimeStart = TimePointer(aTimeStart)</span>
        }
        <span class="cov8" title="1">if len(fltr.AnswerTimeEnd) != 0 </span><span class="cov8" title="1">{
                var aTimeEnd time.Time
                if aTimeEnd, err = ParseTimeDetectLayout(fltr.AnswerTimeEnd, timezone); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">cdrFltr.AnswerTimeEnd = TimePointer(aTimeEnd)</span>
        }
        <span class="cov8" title="1">if len(fltr.CreatedAtStart) != 0 </span><span class="cov8" title="1">{
                var tStart time.Time
                if tStart, err = ParseTimeDetectLayout(fltr.CreatedAtStart, timezone); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">cdrFltr.CreatedAtStart = TimePointer(tStart)</span>
        }
        <span class="cov8" title="1">if len(fltr.CreatedAtEnd) != 0 </span><span class="cov8" title="1">{
                var tEnd time.Time
                if tEnd, err = ParseTimeDetectLayout(fltr.CreatedAtEnd, timezone); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">cdrFltr.CreatedAtEnd = TimePointer(tEnd)</span>
        }
        <span class="cov8" title="1">if len(fltr.UpdatedAtStart) != 0 </span><span class="cov8" title="1">{
                var tStart time.Time
                if tStart, err = ParseTimeDetectLayout(fltr.UpdatedAtStart, timezone); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">cdrFltr.UpdatedAtStart = TimePointer(tStart)</span>
        }
        <span class="cov8" title="1">if len(fltr.UpdatedAtEnd) != 0 </span><span class="cov8" title="1">{
                var tEnd time.Time
                if tEnd, err = ParseTimeDetectLayout(fltr.UpdatedAtEnd, timezone); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">cdrFltr.UpdatedAtEnd = TimePointer(tEnd)</span>
        }
        <span class="cov8" title="1">if oIDstart, has := fltr.ExtraArgs[OrderIDStart]; has </span><span class="cov8" title="1">{
                var oID int64
                if oID, err = IfaceAsTInt64(oIDstart); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">cdrFltr.OrderIDStart = Int64Pointer(oID)</span>
        }
        <span class="cov8" title="1">if oIDend, has := fltr.ExtraArgs[OrderIDEnd]; has </span><span class="cov8" title="1">{
                var oID int64
                if oID, err = IfaceAsTInt64(oIDend); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">cdrFltr.OrderIDEnd = Int64Pointer(oID)</span>
        }
        <span class="cov8" title="1">if mcost, has := fltr.ExtraArgs[MinCost]; has </span><span class="cov8" title="1">{
                var mc float64
                if mc, err = IfaceAsFloat64(mcost); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">cdrFltr.MinCost = Float64Pointer(mc)</span>
        }
        <span class="cov8" title="1">if mcost, has := fltr.ExtraArgs[MaxCost]; has </span><span class="cov8" title="1">{
                var mc float64
                if mc, err = IfaceAsFloat64(mcost); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">cdrFltr.MaxCost = Float64Pointer(mc)</span>
        }
        <span class="cov8" title="1">return</span>
}

type AttrSetActions struct {
        ActionsId string      // Actions id
        Overwrite bool        // If previously defined, will be overwritten
        Actions   []*TPAction // Set of actions this Actions profile will perform
}

type AttrExecuteAction struct {
        Tenant    string
        Account   string
        ActionsId string
}

type AttrSetAccount struct {
        Tenant           string
        Account          string
        ActionPlanID     string
        ActionTriggersID string
        ExtraOptions     map[string]bool
        ReloadScheduler  bool
}

type AttrRemoveAccount struct {
        Tenant          string
        Account         string
        ReloadScheduler bool
}

type AttrGetCallCost struct {
        CgrId string // Unique id of the CDR
        RunId string // Run Id
}

type AttrSetBalance struct {
        Tenant          string
        Account         string
        BalanceType     string
        Value           float64
        Balance         map[string]any
        ActionExtraData *map[string]any
        Cdrlog          bool
}

// TPResourceProfile is used in APIs to manage remotely offline ResourceProfile
type TPResourceProfile struct {
        TPid               string
        Tenant             string
        ID                 string // Identifier of this limit
        FilterIDs          []string
        ActivationInterval *TPActivationInterval // Time when this limit becomes active/expires
        UsageTTL           string
        Limit              string // Limit value
        AllocationMessage  string
        Blocker            bool // blocker flag to stop processing on filters matched
        Stored             bool
        Weight             float64  // Weight to sort the ResourceLimits
        ThresholdIDs       []string // Thresholds to check after changing Limit
}

// TPActivationInterval represents an activation interval for an item
type TPActivationInterval struct {
        ActivationTime string
        ExpiryTime     string
}

type ArgRSv1ResourceUsage struct {
        *CGREvent
        UsageID  string // ResourceUsage Identifier
        UsageTTL *time.Duration
        Units    float64
        *ArgDispatcher
}

type ArgsComputeFilterIndexIDs struct {
        Tenant        string
        Context       string
        AttributeIDs  []string
        ResourceIDs   []string
        StatIDs       []string
        SupplierIDs   []string
        ThresholdIDs  []string
        ChargerIDs    []string
        DispatcherIDs []string
}

type ArgsComputeFilterIndexes struct {
        Tenant      string
        Context     string
        AttributeS  bool
        ResourceS   bool
        StatS       bool
        SupplierS   bool
        ThresholdS  bool
        ChargerS    bool
        DispatcherS bool
}

// AsActivationTime converts TPActivationInterval into ActivationInterval
func (tpAI *TPActivationInterval) AsActivationInterval(timezone string) (ai *ActivationInterval, err error) <span class="cov8" title="1">{
        var at, et time.Time
        if at, err = ParseTimeDetectLayout(tpAI.ActivationTime, timezone); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if et, err = ParseTimeDetectLayout(tpAI.ExpiryTime, timezone); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return &amp;ActivationInterval{ActivationTime: at, ExpiryTime: et}, nil</span>
}

type ActivationInterval struct {
        ActivationTime time.Time
        ExpiryTime     time.Time
}

func (ai *ActivationInterval) IsActiveAtTime(atTime time.Time) bool <span class="cov8" title="1">{
        return (ai.ActivationTime.IsZero() || ai.ActivationTime.Before(atTime)) &amp;&amp;
                (ai.ExpiryTime.IsZero() || ai.ExpiryTime.After(atTime))
}</span>

// Attributes to send on SessionDisconnect by SMG
type AttrDisconnectSession struct {
        EventStart map[string]any
        Reason     string
}

// MetricWithFilters is used in TPStatProfile
type MetricWithFilters struct {
        FilterIDs []string
        MetricID  string
}

// TPStatProfile is used in APIs to manage remotely offline StatProfile
type TPStatProfile struct {
        TPid               string
        Tenant             string
        ID                 string
        FilterIDs          []string
        ActivationInterval *TPActivationInterval
        QueueLength        int
        TTL                string
        Metrics            []*MetricWithFilters
        Blocker            bool // blocker flag to stop processing on filters matched
        Stored             bool
        Weight             float64
        MinItems           int
        ThresholdIDs       []string
}

// TPThresholdProfile is used in APIs to manage remotely offline ThresholdProfile
type TPThresholdProfile struct {
        TPid               string
        Tenant             string
        ID                 string
        FilterIDs          []string
        ActivationInterval *TPActivationInterval // Time when this limit becomes active and expires
        MaxHits            int
        MinHits            int
        MinSleep           string
        Blocker            bool    // blocker flag to stop processing on filters matched
        Weight             float64 // Weight to sort the thresholds
        ActionIDs          []string
        Async              bool
}

// TPFilterProfile is used in APIs to manage remotely offline FilterProfile
type TPFilterProfile struct {
        TPid               string
        Tenant             string
        ID                 string
        Filters            []*TPFilter
        ActivationInterval *TPActivationInterval // Time when this limit becomes active and expires
}

// TPFilter is used in TPFilterProfile
type TPFilter struct {
        Type    string   // Filter type (*string, *timing, *rsr_filters, *cdr_stats)
        Element string   // Name of the field providing us the Values to check (used in case of some )
        Values  []string // Filter definition
}

// TPSupplier is used in TPSupplierProfile
type TPSupplier struct {
        ID                 string // SupplierID
        FilterIDs          []string
        AccountIDs         []string
        RatingPlanIDs      []string // used when computing price
        ResourceIDs        []string // queried in some strategies
        StatIDs            []string // queried in some strategies
        Weight             float64
        Blocker            bool
        SupplierParameters string
}

// TPSupplierProfile is used in APIs to manage remotely offline SupplierProfile
type TPSupplierProfile struct {
        TPid               string
        Tenant             string
        ID                 string
        FilterIDs          []string
        ActivationInterval *TPActivationInterval // Time when this limit becomes active and expires
        Sorting            string
        SortingParameters  []string
        Suppliers          []*TPSupplier
        Weight             float64
}

// TPAttribute is used in TPAttributeProfile
type TPAttribute struct {
        FilterIDs []string
        Path      string
        Type      string
        Value     string
}

// TPAttributeProfile is used in APIs to manage remotely offline AttributeProfile
type TPAttributeProfile struct {
        TPid               string
        Tenant             string
        ID                 string
        FilterIDs          []string
        ActivationInterval *TPActivationInterval // Time when this limit becomes active and expires
        Contexts           []string              // bind this TPAttribute to multiple context
        Attributes         []*TPAttribute
        Blocker            bool
        Weight             float64
}

// TPChargerProfile is used in APIs to manage remotely offline ChargerProfile
type TPChargerProfile struct {
        TPid               string
        Tenant             string
        ID                 string
        FilterIDs          []string
        ActivationInterval *TPActivationInterval // Time when this limit becomes active and expires
        RunID              string
        AttributeIDs       []string
        Weight             float64
}

type TPTntID struct {
        TPid   string
        Tenant string
        ID     string
}

// TPDispatcherProfile is used in APIs to manage remotely offline DispatcherProfile
type TPDispatcherProfile struct {
        TPid               string
        Tenant             string
        ID                 string
        Subsystems         []string
        FilterIDs          []string
        ActivationInterval *TPActivationInterval // Time when this limit becomes active and expires
        Strategy           string
        StrategyParams     []any // ie for distribution, set here the pool weights
        Weight             float64
        Hosts              []*TPDispatcherHostProfile
}

// TPDispatcherHostProfile is used in TPDispatcherProfile
type TPDispatcherHostProfile struct {
        ID        string
        FilterIDs []string
        Weight    float64 // applied in case of multiple connections need to be ordered
        Params    []any   // additional parameters stored for a session
        Blocker   bool    // no connection after this one
}

// TPDispatcherHost is used in APIs to manage remotely offline DispatcherHost
type TPDispatcherHost struct {
        TPid   string
        Tenant string
        ID     string
        Conns  []*TPDispatcherHostConn
}

// TPDispatcherHostConn is used in TPDispatcherHost
type TPDispatcherHostConn struct {
        Address   string
        Transport string
        TLS       bool
}

type UsageInterval struct {
        Min *time.Duration
        Max *time.Duration
}

type TimeInterval struct {
        Begin *time.Time
        End   *time.Time
}

type AttrRemoteLock struct {
        ReferenceID string        // reference ID for this lock if available
        LockIDs     []string      // List of IDs to obtain lock for
        Timeout     time.Duration // Automatically unlock on timeout
}

type SMCostFilter struct { //id cu litere mare
        CGRIDs         []string
        NotCGRIDs      []string
        RunIDs         []string
        NotRunIDs      []string
        OriginHosts    []string
        NotOriginHosts []string
        OriginIDs      []string
        NotOriginIDs   []string
        CostSources    []string
        NotCostSources []string
        Usage          UsageInterval
        CreatedAt      TimeInterval
}

func AppendToSMCostFilter(smcFilter *SMCostFilter, fieldType, fieldName string,
        values []string, timezone string) (smcf *SMCostFilter, err error) <span class="cov8" title="1">{
        switch fieldName </span>{
        case DynamicDataPrefix + CGRID:<span class="cov8" title="1">
                switch fieldType </span>{
                case MetaString:<span class="cov8" title="1">
                        smcFilter.CGRIDs = append(smcFilter.CGRIDs, values...)</span>
                case MetaNotString:<span class="cov8" title="1">
                        smcFilter.NotCGRIDs = append(smcFilter.NotCGRIDs, values...)</span>
                default:<span class="cov8" title="1">
                        err = fmt.Errorf("FilterType: %q not supported for FieldName: %q", fieldType, fieldName)</span>
                }
        case DynamicDataPrefix + RunID:<span class="cov8" title="1">
                switch fieldType </span>{
                case MetaString:<span class="cov8" title="1">
                        smcFilter.RunIDs = append(smcFilter.RunIDs, values...)</span>
                case MetaNotString:<span class="cov8" title="1">
                        smcFilter.NotRunIDs = append(smcFilter.NotRunIDs, values...)</span>
                default:<span class="cov8" title="1">
                        err = fmt.Errorf("FilterType: %q not supported for FieldName: %q", fieldType, fieldName)</span>
                }
        case DynamicDataPrefix + OriginHost:<span class="cov8" title="1">
                switch fieldType </span>{
                case MetaString:<span class="cov8" title="1">
                        smcFilter.OriginHosts = append(smcFilter.OriginHosts, values...)</span>
                case MetaNotString:<span class="cov8" title="1">
                        smcFilter.NotOriginHosts = append(smcFilter.NotOriginHosts, values...)</span>
                default:<span class="cov8" title="1">
                        err = fmt.Errorf("FilterType: %q not supported for FieldName: %q", fieldType, fieldName)</span>
                }
        case DynamicDataPrefix + OriginID:<span class="cov8" title="1">
                switch fieldType </span>{
                case MetaString:<span class="cov8" title="1">
                        smcFilter.OriginIDs = append(smcFilter.OriginIDs, values...)</span>
                case MetaNotString:<span class="cov8" title="1">
                        smcFilter.NotOriginIDs = append(smcFilter.NotOriginIDs, values...)</span>
                default:<span class="cov8" title="1">
                        err = fmt.Errorf("FilterType: %q not supported for FieldName: %q", fieldType, fieldName)</span>
                }
        case DynamicDataPrefix + CostSource:<span class="cov8" title="1">
                switch fieldType </span>{
                case MetaString:<span class="cov8" title="1">
                        smcFilter.CostSources = append(smcFilter.CostSources, values...)</span>
                case MetaNotString:<span class="cov8" title="1">
                        smcFilter.NotCostSources = append(smcFilter.NotCostSources, values...)</span>
                default:<span class="cov8" title="1">
                        err = fmt.Errorf("FilterType: %q not supported for FieldName: %q", fieldType, fieldName)</span>
                }
        case DynamicDataPrefix + Usage:<span class="cov8" title="1">
                switch fieldType </span>{
                case MetaGreaterOrEqual:<span class="cov8" title="1">
                        var minUsage time.Duration
                        minUsage, err = ParseDurationWithNanosecs(values[0])
                        if err != nil </span><span class="cov8" title="1">{
                                err = fmt.Errorf("Error when converting field: %q  value: %q in time.Duration ", fieldType, fieldName)
                                break</span>
                        }
                        <span class="cov8" title="1">smcFilter.Usage.Min = &amp;minUsage</span>
                case MetaLessThan:<span class="cov8" title="1">
                        var maxUsage time.Duration
                        maxUsage, err = ParseDurationWithNanosecs(values[0])
                        if err != nil </span><span class="cov8" title="1">{
                                err = fmt.Errorf("Error when converting field: %q  value: %q in time.Duration ", fieldType, fieldName)
                                break</span>
                        }
                        <span class="cov8" title="1">smcFilter.Usage.Max = &amp;maxUsage</span>
                default:<span class="cov8" title="1">
                        err = fmt.Errorf("FilterType: %q not supported for FieldName: %q", fieldType, fieldName)</span>
                }
        case DynamicDataPrefix + CreatedAt:<span class="cov8" title="1">
                switch fieldType </span>{
                case MetaGreaterOrEqual:<span class="cov8" title="1">
                        var start time.Time
                        start, err = ParseTimeDetectLayout(values[0], timezone)
                        if err != nil </span><span class="cov8" title="1">{
                                err = fmt.Errorf("Error when converting field: %q  value: %q in time.Time ", fieldType, fieldName)
                                break</span>
                        }
                        <span class="cov8" title="1">if !start.IsZero() </span><span class="cov8" title="1">{
                                smcFilter.CreatedAt.Begin = &amp;start
                        }</span>
                case MetaLessThan:<span class="cov8" title="1">
                        var end time.Time
                        end, err = ParseTimeDetectLayout(values[0], timezone)
                        if err != nil </span><span class="cov8" title="1">{
                                err = fmt.Errorf("Error when converting field: %q  value: %q in time.Time ", fieldType, fieldName)
                                break</span>
                        }
                        <span class="cov8" title="1">if !end.IsZero() </span><span class="cov8" title="1">{
                                smcFilter.CreatedAt.End = &amp;end
                        }</span>
                default:<span class="cov8" title="1">
                        err = fmt.Errorf("FilterType: %q not supported for FieldName: %q", fieldType, fieldName)</span>
                }
        default:<span class="cov8" title="1">
                err = fmt.Errorf("FieldName: %q not supported", fieldName)</span>
        }
        <span class="cov8" title="1">return smcFilter, err</span>
}

type RPCCDRsFilterWithArgDispatcher struct {
        *RPCCDRsFilter
        *ArgDispatcher
        *TenantArg
}

type ArgsGetCacheItemIDsWithArgDispatcher struct {
        *ArgDispatcher
        TenantArg
        ArgsGetCacheItemIDs
}

type ArgsGetCacheItemWithArgDispatcher struct {
        *ArgDispatcher
        TenantArg
        ArgsGetCacheItem
}

type AttrReloadCacheWithArgDispatcher struct {
        *ArgDispatcher
        TenantArg
        AttrReloadCache
}

type AttrCacheIDsWithArgDispatcher struct {
        *ArgDispatcher
        TenantArg
        CacheIDs []string
}

type ArgsGetGroupWithArgDispatcher struct {
        *ArgDispatcher
        TenantArg
        ArgsGetGroup
}

type ArgsGetCacheItemIDs struct {
        CacheID      string
        ItemIDPrefix string
}

type ArgsGetCacheItem struct {
        CacheID string
        ItemID  string
}

type ArgsGetGroup struct {
        CacheID string
        GroupID string
}

type SessionFilter struct {
        Limit   *int
        Filters []string
        Tenant  string
        *ArgDispatcher
}

type ArgDispatcher struct {
        APIKey  *string
        RouteID *string
}

type RatingPlanCostArg struct {
        RatingPlanIDs []string
        Destination   string
        SetupTime     string
        Usage         string
        *ArgDispatcher
}

type GetCostOnRatingPlansArgs struct {
        Account       string
        Subject       string
        Destination   string
        Tenant        string
        SetupTime     time.Time
        Usage         time.Duration
        RatingPlanIDs []string
        *ArgDispatcher
}

type GetMaxSessionTimeOnAccountsArgs struct {
        Subject     string
        Destination string
        Tenant      string
        SetupTime   time.Time
        Usage       time.Duration
        AccountIDs  []string
        *ArgDispatcher
}

type DurationArgs struct {
        DurationTime time.Duration
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "encoding/base64"
        "fmt"
        "net/http"
        "strings"
)

// use provides a cleaner interface for chaining middleware for single routes.
// Middleware functions are simple HTTP handlers (w http.ResponseWriter, r *http.Request)
//
//        r.HandleFunc("/login", use(loginHandler, rateLimit, csrf))
//        r.HandleFunc("/form", use(formHandler, csrf))
//        r.HandleFunc("/about", aboutHandler)
//
// From https://gist.github.com/elithrar/9146306
// See https://gist.github.com/elithrar/7600878#comment-955958 for how to extend it to suit simple http.Handler's
func use(h http.HandlerFunc, middleware ...func(http.HandlerFunc) http.HandlerFunc) http.HandlerFunc <span class="cov8" title="1">{
        for _, m := range middleware </span><span class="cov8" title="1">{
                h = m(h)
        }</span>

        <span class="cov8" title="1">return h</span>
}

type basicAuthMiddleware func(h http.HandlerFunc) http.HandlerFunc

// basicAuth returns a middleware function to intercept the request and validate
func basicAuth(userList map[string]string) basicAuthMiddleware <span class="cov8" title="1">{
        return func(h http.HandlerFunc) http.HandlerFunc </span><span class="cov8" title="1">{
                return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        w.Header().Set("WWW-Authenticate", `Basic realm="Restricted"`)

                        authHeader := strings.SplitN(r.Header.Get("Authorization"), " ", 2)
                        if len(authHeader) != 2 </span><span class="cov8" title="1">{
                                Logger.Warning("&lt;BasicAuth&gt; Missing authorization header value")
                                http.Error(w, "Not authorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">authHeaderDecoded, err := base64.StdEncoding.DecodeString(authHeader[1])
                        if err != nil </span><span class="cov8" title="1">{
                                Logger.Warning("&lt;BasicAuth&gt; Unable to decode authorization header")
                                http.Error(w, err.Error(), http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">userPass := strings.SplitN(string(authHeaderDecoded), ":", 2)
                        if len(userPass) != 2 </span><span class="cov8" title="1">{
                                Logger.Warning("&lt;BasicAuth&gt; Unauthorized API access. Missing or extra credential components")
                                http.Error(w, "Not authorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">valid := verifyCredential(userPass[0], userPass[1], userList)
                        if !valid </span><span class="cov8" title="1">{
                                Logger.Warning(fmt.Sprintf("&lt;BasicAuth&gt; Unauthorized API access by user '%s'", userPass[0]))
                                http.Error(w, "Not authorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">h.ServeHTTP(w, r)</span>
                }
        }
}

// verifyCredential validates the incoming username and password against the authorized user list
func verifyCredential(username string, password string, userList map[string]string) bool <span class="cov8" title="1">{
        hash, ok := userList[username]
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">storedPass, err := base64.StdEncoding.DecodeString(hash)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return string(storedPass[:]) == password</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "net"

        "github.com/cenkalti/rpc2"
        rpc2_jsonrpc "github.com/cenkalti/rpc2/jsonrpc"
        "github.com/cgrates/birpc"
        "github.com/cgrates/birpc/context"
)

// NewBiJSONrpcClient will create a bidirectional JSON client connection
func NewBiJSONrpcClient(addr string, handlers map[string]any) (*rpc2.Client, error) <span class="cov8" title="1">{
        conn, err := net.Dial(TCP, addr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">clnt := rpc2.NewClientWithCodec(rpc2_jsonrpc.NewJSONCodec(conn))
        for method, handlerFunc := range handlers </span><span class="cov8" title="1">{
                clnt.Handle(method, handlerFunc)
        }</span>
        <span class="cov8" title="1">go clnt.Run()
        return clnt, nil</span>
}

// Interface which the server needs to work as BiRPCServer
type BiRPCServer interface {
        Call(*context.Context, string, any, any) error // So we can use it also as birpc.ClientConnector
        CallBiRPC(birpc.ClientConnector, string, any, any) error
}

type BiRPCClient interface {
        Call(*context.Context, string, any, any) error // So we can use it also as birpc.ClientConnector
        ID() string
}

func NewBiRPCInternalClient(serverConn BiRPCServer) *BiRPCInternalClient <span class="cov8" title="1">{
        return &amp;BiRPCInternalClient{serverConn: serverConn}
}</span>

// Need separate client from the original RpcClientConnection since diretly passing the server is not enough without passing the client's reference
type BiRPCInternalClient struct {
        serverConn BiRPCServer
        clntConn   birpc.ClientConnector // conn to reach client and do calls over it
}

// Used in case when clientConn is not available at init time (eg: SMGAsterisk who needs the biRPCConn at initialization)
func (clnt *BiRPCInternalClient) SetClientConn(clntConn birpc.ClientConnector) <span class="cov8" title="1">{
        clnt.clntConn = clntConn
}</span>

// Part of birpc.ClientConnector interface
func (clnt *BiRPCInternalClient) Call(ctx *context.Context, serviceMethod string, args any, reply any) error <span class="cov8" title="1">{
        return clnt.serverConn.CallBiRPC(clnt.clntConn, serviceMethod, args, reply)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "time"
)

// CGREvent is a generic event processed by CGR services
type CGREvent struct {
        Tenant string
        ID     string
        Time   *time.Time // event time
        Event  map[string]any
}

func (ev *CGREvent) HasField(fldName string) (has bool) <span class="cov8" title="1">{
        _, has = ev.Event[fldName]
        return
}</span>

func (ev *CGREvent) CheckMandatoryFields(fldNames []string) error <span class="cov8" title="1">{
        for _, fldName := range fldNames </span><span class="cov8" title="1">{
                if _, has := ev.Event[fldName]; !has </span><span class="cov8" title="1">{
                        return NewErrMandatoryIeMissing(fldName)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// FieldAsString returns a field as string instance
func (ev *CGREvent) FieldAsString(fldName string) (val string, err error) <span class="cov8" title="1">{
        iface, has := ev.Event[fldName]
        if !has </span><span class="cov8" title="1">{
                return "", ErrNotFound
        }</span>
        <span class="cov8" title="1">return IfaceAsString(iface), nil</span>
}

// FieldAsTime returns a field as Time instance
func (ev *CGREvent) FieldAsTime(fldName string, timezone string) (t time.Time, err error) <span class="cov8" title="1">{
        iface, has := ev.Event[fldName]
        if !has </span><span class="cov8" title="1">{
                err = ErrNotFound
                return
        }</span>
        <span class="cov8" title="1">return IfaceAsTime(iface, timezone)</span>
}

// FieldAsDuration returns a field as Duration instance
func (ev *CGREvent) FieldAsDuration(fldName string) (d time.Duration, err error) <span class="cov8" title="1">{
        iface, has := ev.Event[fldName]
        if !has </span><span class="cov8" title="1">{
                err = ErrNotFound
                return
        }</span>
        <span class="cov8" title="1">return IfaceAsDuration(iface)</span>
}

// FieldAsFloat64 returns a field as float64 instance
func (ev *CGREvent) FieldAsFloat64(fldName string) (f float64, err error) <span class="cov8" title="1">{
        iface, has := ev.Event[fldName]
        if !has </span><span class="cov8" title="1">{
                return f, ErrNotFound
        }</span>
        <span class="cov8" title="1">return IfaceAsFloat64(iface)</span>
}

func (ev *CGREvent) TenantID() string <span class="cov8" title="1">{
        return ConcatenatedKey(ev.Tenant, ev.ID)
}</span>

/*
func (ev *CGREvent) FilterableEvent(fltredFields []string) (fEv map[string]any) {
        fEv = make(map[string]any)
        if len(fltredFields) == 0 {
                i := 0
                fltredFields = make([]string, len(ev.Event))
                for k := range ev.Event {
                        fltredFields[i] = k
                        i++
                }
        }
        for _, fltrFld := range fltredFields {
                fldVal, has := ev.Event[fltrFld]
                if !has {
                        continue // the field does not exist in map, ignore it
                }
                valOf := reflect.ValueOf(fldVal)
                if valOf.Kind() == reflect.String {
                        fEv[fltrFld] = StringToInterface(valOf.String()) // attempt converting from string to comparable interface
                } else {
                        fEv[fltrFld] = fldVal
                }
        }
        return
}
*/

func (ev *CGREvent) Clone() (clned *CGREvent) <span class="cov8" title="1">{
        clned = &amp;CGREvent{
                Tenant: ev.Tenant,
                ID:     ev.ID,
                Event:  make(map[string]any),
        }
        if ev.Time != nil </span><span class="cov8" title="1">{
                clned.Time = TimePointer(*ev.Time)
        }</span>
        <span class="cov8" title="1">for k, v := range ev.Event </span><span class="cov8" title="1">{
                clned.Event[k] = v
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ev *CGREvent) consumeArgDispatcher() (arg *ArgDispatcher) <span class="cov8" title="1">{
        if ev == nil </span><span class="cov8" title="1">{
                return
        }</span>
        //check if we have APIKey in event and in case it has add it in ArgDispatcher
        <span class="cov8" title="1">apiKeyIface, hasApiKey := ev.Event[MetaApiKey]
        if hasApiKey </span><span class="cov8" title="1">{
                delete(ev.Event, MetaApiKey)
                arg = &amp;ArgDispatcher{
                        APIKey: StringPointer(apiKeyIface.(string)),
                }
        }</span>
        //check if we have RouteID in event and in case it has add it in ArgDispatcher
        <span class="cov8" title="1">routeIDIface, hasRouteID := ev.Event[MetaRouteID]
        if !hasRouteID </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">delete(ev.Event, MetaRouteID)
        if !hasApiKey </span><span class="cov8" title="1">{ //in case we don't have APIKey, but we have RouteID we need to initialize the struct
                return &amp;ArgDispatcher{
                        RouteID: StringPointer(routeIDIface.(string)),
                }
        }</span>
        <span class="cov8" title="1">arg.RouteID = StringPointer(routeIDIface.(string))
        return</span>
}

// ConsumeSupplierPaginator will consume supplierPaginator if presented
func (ev *CGREvent) consumeSupplierPaginator() (args *Paginator) <span class="cov8" title="1">{
        args = new(Paginator)
        if ev == nil </span><span class="cov8" title="1">{
                return
        }</span>
        //check if we have suppliersLimit in event and in case it has add it in args
        <span class="cov8" title="1">limitIface, hasSuppliersLimit := ev.Event[MetaSuppliersLimit]
        if hasSuppliersLimit </span><span class="cov8" title="1">{
                delete(ev.Event, MetaSuppliersLimit)
                limit, err := IfaceAsInt64(limitIface)
                if err != nil </span><span class="cov8" title="1">{
                        Logger.Err(err.Error())
                        return
                }</span>
                <span class="cov8" title="1">args = &amp;Paginator{
                        Limit: IntPointer(int(limit)),
                }</span>
        }
        //check if we have offset in event and in case it has add it in args
        <span class="cov8" title="1">offsetIface, hasSuppliersOffset := ev.Event[MetaSuppliersOffset]
        if hasSuppliersOffset </span><span class="cov8" title="1">{
                delete(ev.Event, MetaSuppliersOffset)
                offset, err := IfaceAsInt64(offsetIface)
                if err != nil </span><span class="cov8" title="1">{
                        Logger.Err(err.Error())
                        return
                }</span>
                <span class="cov8" title="1">if !hasSuppliersLimit </span><span class="cov8" title="1">{ //in case we don't have limit, but we have offset we need to initialize the struct
                        args = &amp;Paginator{
                                Offset: IntPointer(int(offset)),
                        }
                }</span> else<span class="cov8" title="1"> {
                        args.Offset = IntPointer(int(offset))
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// ExtractedArgs stores the extracted arguments from CGREvent
type ExtractedArgs struct {
        ArgDispatcher     *ArgDispatcher
        SupplierPaginator *Paginator
}

// ExtractArgs extracts the ArgDispatcher and SupplierPaginator from the received event
func (ev *CGREvent) ExtractArgs(dispatcherFlag, consumeSupplierPaginator bool) (ca ExtractedArgs) <span class="cov8" title="1">{
        ca = ExtractedArgs{
                ArgDispatcher: ev.consumeArgDispatcher(),
        }
        if dispatcherFlag &amp;&amp; ca.ArgDispatcher == nil </span><span class="cov8" title="1">{
                ca.ArgDispatcher = new(ArgDispatcher)
        }</span>
        <span class="cov8" title="1">if consumeSupplierPaginator </span><span class="cov8" title="1">{
                ca.SupplierPaginator = ev.consumeSupplierPaginator()
        }</span>
        <span class="cov8" title="1">return</span>
}

// CGREvents is a group of generic events processed by CGR services
// ie: derived CDRs
type CGREvents struct {
        Tenant string
        ID     string
        Time   *time.Time // event time
        Events []map[string]any
}

func NewCGREventWithArgDispatcher() *CGREventWithArgDispatcher <span class="cov8" title="1">{
        return &amp;CGREventWithArgDispatcher{
                CGREvent:      new(CGREvent),
                ArgDispatcher: new(ArgDispatcher),
        }
}</span>

type CGREventWithArgDispatcher struct {
        *CGREvent
        *ArgDispatcher
}

func (ev *CGREventWithArgDispatcher) Clone() (clned *CGREventWithArgDispatcher) <span class="cov8" title="1">{
        if ev == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">clned = new(CGREventWithArgDispatcher)
        if ev.CGREvent != nil </span><span class="cov8" title="1">{
                clned.CGREvent = ev.CGREvent.Clone()
        }</span>
        <span class="cov8" title="1">if ev.ArgDispatcher != nil </span><span class="cov8" title="1">{
                clned.ArgDispatcher = new(ArgDispatcher)
                *clned.ArgDispatcher = *ev.ArgDispatcher
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "io"
)

// CgrRecordWriter is a writer for one line, compatible with csv.Writer interface on Write
// Used in TP exporter
type CgrRecordWriter interface {
        Write([]string) error
        Flush()
}

// NewCgrIORecordWriter return CgrRecordWriter that will replace csv.Writer
func NewCgrIORecordWriter(w io.Writer) *CgrIORecordWriter <span class="cov8" title="1">{
        return &amp;CgrIORecordWriter{w: w}
}</span>

// CgrIORecordWriter implements CgrRecordWriter
type CgrIORecordWriter struct {
        w io.Writer
}

// Write into the Writer the record
func (rw *CgrIORecordWriter) Write(record []string) error <span class="cov8" title="1">{
        for _, fld := range append(record, "\n") </span><span class="cov8" title="1">{ // Postpend the new line char and write record in the writer
                if _, err := io.WriteString(rw.w, fld); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Flush only to implement CgrRecordWriter
// ToDo: make sure we properly handle this method
func (*CgrIORecordWriter) Flush() <span class="cov8" title="1">{
        return
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "fmt"
)

var ConReqs *ConcReqs

type ConcReqs struct {
        limit    int
        strategy string
        aReqs    chan struct{}
}

func NewConReqs(reqs int, strategy string) *ConcReqs <span class="cov8" title="1">{
        cR := &amp;ConcReqs{
                limit:    reqs,
                strategy: strategy,
                aReqs:    make(chan struct{}, reqs),
        }
        for i := 0; i &lt; reqs; i++ </span><span class="cov8" title="1">{
                cR.aReqs &lt;- struct{}{}
        }</span>
        <span class="cov8" title="1">return cR</span>
}

var errDeny = fmt.Errorf("denying request due to maximum active requests reached")

func (cR *ConcReqs) Allocate() (err error) <span class="cov8" title="1">{
        if cR.limit == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">switch cR.strategy </span>{
        case MetaBusy:<span class="cov8" title="1">
                if len(cR.aReqs) == 0 </span><span class="cov8" title="1">{
                        return errDeny
                }</span>
                <span class="cov8" title="1">fallthrough</span>
        case MetaQueue:<span class="cov8" title="1">
                &lt;-cR.aReqs</span> // get from channel
        }
        <span class="cov8" title="1">return</span>
}

func (cR *ConcReqs) Deallocate() <span class="cov8" title="1">{
        if cR.limit == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">cR.aReqs &lt;- struct{}{}</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

// Most of the logic follows standard library implementation in this file
package utils

import (
        "bufio"
        "encoding/gob"
        "io"
        "log"
        "net/rpc"
)

type concReqsGobServerCodec struct {
        rwc       io.ReadWriteCloser
        dec       *gob.Decoder
        enc       *gob.Encoder
        encBuf    *bufio.Writer
        closed    bool
        allocated bool // populated if we have allocated a channel for concurrent requests
}

func NewConcReqsGobServerCodec(conn io.ReadWriteCloser) rpc.ServerCodec <span class="cov0" title="0">{
        buf := bufio.NewWriter(conn)
        return &amp;concReqsGobServerCodec{
                rwc:    conn,
                dec:    gob.NewDecoder(conn),
                enc:    gob.NewEncoder(buf),
                encBuf: buf,
        }
}</span>

func (c *concReqsGobServerCodec) ReadRequestHeader(r *rpc.Request) error <span class="cov0" title="0">{
        return c.dec.Decode(r)
}</span>

func (c *concReqsGobServerCodec) ReadRequestBody(body any) error <span class="cov0" title="0">{
        if err := ConReqs.Allocate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.allocated = true
        return c.dec.Decode(body)</span>
}

func (c *concReqsGobServerCodec) WriteResponse(r *rpc.Response, body any) (err error) <span class="cov0" title="0">{
        if c.allocated </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        ConReqs.Deallocate()
                        c.allocated = false
                }</span>()
        }
        <span class="cov0" title="0">if err = c.enc.Encode(r); err != nil </span><span class="cov0" title="0">{
                if c.encBuf.Flush() == nil </span><span class="cov0" title="0">{
                        // Gob couldn't encode the header. Should not happen, so if it does,
                        // shut down the connection to signal that the connection is broken.
                        log.Println("rpc: gob error encoding response:", err)
                        c.Close()
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if err = c.enc.Encode(body); err != nil </span><span class="cov0" title="0">{
                if c.encBuf.Flush() == nil </span><span class="cov0" title="0">{
                        // Was a gob problem encoding the body but the header has been written.
                        // Shut down the connection to signal that the connection is broken.
                        log.Println("rpc: gob error encoding body:", err)
                        c.Close()
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">return c.encBuf.Flush()</span>
}

func (c *concReqsGobServerCodec) Close() error <span class="cov0" title="0">{
        if c.closed </span><span class="cov0" title="0">{
                // Only call c.rwc.Close once; otherwise the semantics are undefined.
                return nil
        }</span>
        <span class="cov0" title="0">c.closed = true
        return c.rwc.Close()</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

// Most of the logic follows standard library implementation in this file
package utils

import (
        "encoding/json"
        "errors"
        "io"
        "net/rpc"
        "sync"
)

type concReqsServerCodec struct {
        dec *json.Decoder // for reading JSON values
        enc *json.Encoder // for writing JSON values
        c   io.Closer

        // temporary work space
        req serverRequest

        // JSON-RPC clients can use arbitrary json values as request IDs.
        // Package rpc expects uint64 request IDs.
        // We assign uint64 sequence numbers to incoming requests
        // but save the original request ID in the pending map.
        // When rpc responds, we use the sequence number in
        // the response to find the original request ID.
        mutex   sync.Mutex // protects seq, pending
        seq     uint64
        pending map[uint64]*json.RawMessage

        allocated bool // populated if we have allocated a channel for concurrent requests
}

// NewConcReqsServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.
func NewConcReqsServerCodec(conn io.ReadWriteCloser) rpc.ServerCodec <span class="cov0" title="0">{
        return &amp;concReqsServerCodec{
                dec:     json.NewDecoder(conn),
                enc:     json.NewEncoder(conn),
                c:       conn,
                pending: make(map[uint64]*json.RawMessage),
        }
}</span>

func (c *concReqsServerCodec) ReadRequestHeader(r *rpc.Request) error <span class="cov0" title="0">{
        c.req.reset()
        if err := c.dec.Decode(&amp;c.req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r.ServiceMethod = c.req.Method

        // JSON request id can be any JSON value;
        // RPC package expects uint64.  Translate to
        // internal uint64 and save JSON on the side.
        c.mutex.Lock()
        c.seq++
        c.pending[c.seq] = c.req.Id
        c.req.Id = nil
        r.Seq = c.seq
        c.mutex.Unlock()

        return nil</span>
}

func (c *concReqsServerCodec) ReadRequestBody(x any) error <span class="cov0" title="0">{
        if err := ConReqs.Allocate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.allocated = true
        if x == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if c.req.Params == nil </span><span class="cov0" title="0">{
                return errMissingParams
        }</span>
        // JSON params is array value.
        // RPC params is struct.
        // Unmarshal into array containing struct for now.
        // Should think about making RPC more general.
        <span class="cov0" title="0">var params [1]any
        params[0] = x
        return json.Unmarshal(*c.req.Params, &amp;params)</span>
}

func (c *concReqsServerCodec) WriteResponse(r *rpc.Response, x any) error <span class="cov0" title="0">{
        if c.allocated </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        ConReqs.Deallocate()
                        c.allocated = false
                }</span>()
        }

        <span class="cov0" title="0">c.mutex.Lock()
        b, ok := c.pending[r.Seq]
        if !ok </span><span class="cov0" title="0">{
                c.mutex.Unlock()
                return errors.New("invalid sequence number in response")
        }</span>
        <span class="cov0" title="0">delete(c.pending, r.Seq)
        c.mutex.Unlock()

        if b == nil </span><span class="cov0" title="0">{
                // Invalid request so no id. Use JSON null.
                b = &amp;null
        }</span>
        <span class="cov0" title="0">resp := serverResponse{Id: b}
        if r.Error == "" </span><span class="cov0" title="0">{
                resp.Result = x
        }</span> else<span class="cov0" title="0"> {
                resp.Error = r.Error
        }</span>
        <span class="cov0" title="0">return c.enc.Encode(resp)</span>
}

func (c *concReqsServerCodec) Close() error <span class="cov0" title="0">{
        return c.c.Close()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import "time"

var (
        CDRExportFormats = NewStringSet([]string{DRYRUN, MetaFileCSV, MetaFileFWV, MetaHTTPjsonCDR, MetaHTTPjsonMap,
                MetaHTTPjson, MetaHTTPPost, MetaAMQPjsonCDR, MetaAMQPjsonMap, MetaAMQPV1jsonMap, MetaSQSjsonMap,
                MetaKafkajsonMap, MetaS3jsonMap})
        MainCDRFields = NewStringSet([]string{CGRID, Source, OriginHost, OriginID, ToR, RequestType, Tenant, Category,
                Account, Subject, Destination, SetupTime, AnswerTime, Usage, COST, RATED, Partial, RunID,
                PreRated, CostSource, CostDetails, ExtraInfo, OrderID})
        PostPaidRatedSlice = []string{META_POSTPAID, META_RATED}
        ItemList           = NewStringSet([]string{MetaAccounts, MetaAttributes, MetaChargers, MetaDispatchers, MetaDispatcherHosts,
                MetaFilters, MetaResources, MetaStats, MetaThresholds, MetaSuppliers,
        })
        AttrInlineTypes = NewStringSet([]string{META_CONSTANT, MetaVariable, META_COMPOSED, META_USAGE_DIFFERENCE,
                MetaSum, MetaValueExponent})

        GitLastLog                  string // If set, it will be processed as part of versioning
        PosterTransportContentTypes = map[string]string{
                MetaHTTPjsonCDR:   CONTENT_JSON,
                MetaHTTPjsonMap:   CONTENT_JSON,
                MetaHTTPjson:      CONTENT_JSON,
                MetaHTTPPost:      CONTENT_FORM,
                MetaAMQPjsonCDR:   CONTENT_JSON,
                MetaAMQPjsonMap:   CONTENT_JSON,
                MetaAMQPV1jsonMap: CONTENT_JSON,
                MetaSQSjsonMap:    CONTENT_JSON,
                MetaKafkajsonMap:  CONTENT_JSON,
                MetaS3jsonMap:     CONTENT_JSON,
        }
        CDREFileSuffixes = map[string]string{
                MetaHTTPjsonCDR:   JSNSuffix,
                MetaHTTPjsonMap:   JSNSuffix,
                MetaAMQPjsonCDR:   JSNSuffix,
                MetaAMQPjsonMap:   JSNSuffix,
                MetaAMQPV1jsonMap: JSNSuffix,
                MetaSQSjsonMap:    JSNSuffix,
                MetaKafkajsonMap:  JSNSuffix,
                MetaS3jsonMap:     JSNSuffix,
                MetaHTTPPost:      FormSuffix,
                MetaFileCSV:       CSVSuffix,
                MetaFileFWV:       FWVSuffix,
        }
        // CachePartitions enables creation of cache partitions
        CachePartitions = NewStringSet([]string{CacheDestinations, CacheReverseDestinations,
                CacheRatingPlans, CacheRatingProfiles, CacheActions, CacheActionPlans,
                CacheAccountActionPlans, CacheActionTriggers, CacheSharedGroups, CacheTimings,
                CacheResourceProfiles, CacheResources, CacheEventResources, CacheStatQueueProfiles,
                CacheStatQueues, CacheThresholdProfiles, CacheThresholds, CacheFilters,
                CacheSupplierProfiles, CacheAttributeProfiles, CacheChargerProfiles,
                CacheDispatcherProfiles, CacheDispatcherHosts, CacheResourceFilterIndexes,
                CacheStatFilterIndexes, CacheThresholdFilterIndexes, CacheSupplierFilterIndexes,
                CacheAttributeFilterIndexes, CacheChargerFilterIndexes, CacheDispatcherFilterIndexes, CacheReverseFilterIndexes,
                CacheDispatcherRoutes, CacheDiameterMessages, CacheRPCResponses, CacheClosedSessions,
                CacheCDRIDs, CacheLoadIDs, CacheRPCConnections, CacheRatingProfilesTmp})
        CacheInstanceToPrefix = map[string]string{
                CacheDestinations:            DESTINATION_PREFIX,
                CacheReverseDestinations:     REVERSE_DESTINATION_PREFIX,
                CacheRatingPlans:             RATING_PLAN_PREFIX,
                CacheRatingProfiles:          RATING_PROFILE_PREFIX,
                CacheActions:                 ACTION_PREFIX,
                CacheActionPlans:             ACTION_PLAN_PREFIX,
                CacheAccountActionPlans:      AccountActionPlansPrefix,
                CacheActionTriggers:          ACTION_TRIGGER_PREFIX,
                CacheSharedGroups:            SHARED_GROUP_PREFIX,
                CacheResourceProfiles:        ResourceProfilesPrefix,
                CacheResources:               ResourcesPrefix,
                CacheTimings:                 TimingsPrefix,
                CacheStatQueueProfiles:       StatQueueProfilePrefix,
                CacheStatQueues:              StatQueuePrefix,
                CacheThresholdProfiles:       ThresholdProfilePrefix,
                CacheThresholds:              ThresholdPrefix,
                CacheFilters:                 FilterPrefix,
                CacheSupplierProfiles:        SupplierProfilePrefix,
                CacheAttributeProfiles:       AttributeProfilePrefix,
                CacheChargerProfiles:         ChargerProfilePrefix,
                CacheDispatcherProfiles:      DispatcherProfilePrefix,
                CacheDispatcherHosts:         DispatcherHostPrefix,
                CacheResourceFilterIndexes:   ResourceFilterIndexes,
                CacheStatFilterIndexes:       StatFilterIndexes,
                CacheThresholdFilterIndexes:  ThresholdFilterIndexes,
                CacheSupplierFilterIndexes:   SupplierFilterIndexes,
                CacheAttributeFilterIndexes:  AttributeFilterIndexes,
                CacheChargerFilterIndexes:    ChargerFilterIndexes,
                CacheDispatcherFilterIndexes: DispatcherFilterIndexes,
                CacheReverseFilterIndexes:    ReverseFilterIndexes,
                CacheLoadIDs:                 LoadIDPrefix,
                CacheAccounts:                ACCOUNT_PREFIX,
        }
        CachePrefixToInstance map[string]string // will be built on init
        PrefixToIndexCache    = map[string]string{
                ThresholdProfilePrefix:  CacheThresholdFilterIndexes,
                ResourceProfilesPrefix:  CacheResourceFilterIndexes,
                StatQueueProfilePrefix:  CacheStatFilterIndexes,
                SupplierProfilePrefix:   CacheSupplierFilterIndexes,
                AttributeProfilePrefix:  CacheAttributeFilterIndexes,
                ChargerProfilePrefix:    CacheChargerFilterIndexes,
                DispatcherProfilePrefix: CacheDispatcherFilterIndexes,
                ReverseFilterIndexes:    CacheReverseFilterIndexes,
        }
        CacheIndexesToPrefix map[string]string // will be built on init

        // NonMonetaryBalances are types of balances which are not handled as monetary
        NonMonetaryBalances = NewStringSet([]string{VOICE, SMS, DATA, GENERIC})

        // AccountableRequestTypes are the ones handled by Accounting subsystem
        AccountableRequestTypes = NewStringSet([]string{META_PREPAID, META_POSTPAID, META_PSEUDOPREPAID})

        CacheDataDBPartitions = NewStringSet([]string{CacheDestinations, CacheReverseDestinations,
                CacheRatingPlans, CacheRatingProfiles, CacheActions,
                CacheActionPlans, CacheAccountActionPlans, CacheActionTriggers, CacheSharedGroups, CacheResourceProfiles, CacheResources,
                CacheTimings, CacheStatQueueProfiles, CacheStatQueues, CacheThresholdProfiles, CacheThresholds,
                CacheFilters, CacheSupplierProfiles, CacheAttributeProfiles, CacheChargerProfiles,
                CacheDispatcherProfiles, CacheDispatcherHosts, CacheResourceFilterIndexes, CacheStatFilterIndexes,
                CacheThresholdFilterIndexes, CacheSupplierFilterIndexes, CacheAttributeFilterIndexes, CacheReverseFilterIndexes,
                CacheChargerFilterIndexes, CacheDispatcherFilterIndexes, CacheLoadIDs, CacheAccounts})

        // ProtectedSFlds are the fields that sessions should not alter
        ProtectedSFlds = NewStringSet([]string{CGRID, OriginHost, OriginID, Usage})
)

const (
        CGRateS                      = "CGRateS"
        VERSION                      = "v0.10.3~dev"
        DIAMETER_FIRMWARE_REVISION   = 918
        REDIS_MAX_CONNS              = 10
        CGRATES                      = "cgrates"
        POSTGRES                     = "postgres"
        MYSQL                        = "mysql"
        MONGO                        = "mongo"
        REDIS                        = "redis"
        INTERNAL                     = "internal"
        DataManager                  = "DataManager"
        LOCALHOST                    = "127.0.0.1"
        PREPAID                      = "prepaid"
        META_PREPAID                 = "*prepaid"
        POSTPAID                     = "postpaid"
        META_POSTPAID                = "*postpaid"
        PSEUDOPREPAID                = "pseudoprepaid"
        META_PSEUDOPREPAID           = "*pseudoprepaid"
        META_RATED                   = "*rated"
        META_NONE                    = "*none"
        META_NOW                     = "*now"
        ROUNDING_UP                  = "*up"
        ROUNDING_MIDDLE              = "*middle"
        ROUNDING_DOWN                = "*down"
        ANY                          = "*any"
        MetaAll                      = "*all"
        ZERO                         = "*zero"
        ASAP                         = "*asap"
        COMMENT_CHAR                 = '#'
        CSV_SEP                      = ','
        FALLBACK_SEP                 = ';'
        INFIELD_SEP                  = ";"
        MetaPipe                     = "*|"
        FIELDS_SEP                   = ","
        InInFieldSep                 = ":"
        STATIC_HDRVAL_SEP            = "::"
        REGEXP_PREFIX                = "~"
        FILTER_VAL_START             = "("
        FILTER_VAL_END               = ")"
        JSON                         = "json"
        MSGPACK                      = "msgpack"
        CSV_LOAD                     = "CSVLOAD"
        CGRID                        = "CGRID"
        ToR                          = "ToR"
        OrderID                      = "OrderID"
        OriginID                     = "OriginID"
        InitialOriginID              = "InitialOriginID"
        OriginIDPrefix               = "OriginIDPrefix"
        Source                       = "Source"
        OriginHost                   = "OriginHost"
        RequestType                  = "RequestType"
        Direction                    = "Direction"
        Tenant                       = "Tenant"
        Category                     = "Category"
        Context                      = "Context"
        Contexts                     = "Contexts"
        Account                      = "Account"
        Subject                      = "Subject"
        Destination                  = "Destination"
        SetupTime                    = "SetupTime"
        AnswerTime                   = "AnswerTime"
        Usage                        = "Usage"
        Value                        = "Value"
        LastUsed                     = "LastUsed"
        PDD                          = "PDD"
        SUPPLIER                     = "Supplier"
        RunID                        = "RunID"
        MetaReqRunID                 = "*req.RunID"
        COST                         = "Cost"
        CostDetails                  = "CostDetails"
        RATED                        = "rated"
        Partial                      = "Partial"
        PreRated                     = "PreRated"
        STATIC_VALUE_PREFIX          = "^"
        CSV                          = "csv"
        FWV                          = "fwv"
        MetaPartialCSV               = "*partial_csv"
        DRYRUN                       = "dry_run"
        META_COMBIMED                = "*combimed"
        MetaMongo                    = "*mongo"
        MetaRedis                    = "*redis"
        MetaPostgres                 = "*postgres"
        MetaInternal                 = "*internal"
        MetaLocalHost                = "*localhost"
        ZERO_RATING_SUBJECT_PREFIX   = "*zero"
        OK                           = "OK"
        MetaFileXML                  = "*file_xml"
        CDRE                         = "cdre"
        MASK_CHAR                    = "*"
        CONCATENATED_KEY_SEP         = ":"
        UNIT_TEST                    = "UNIT_TEST"
        HDR_VAL_SEP                  = "/"
        MONETARY                     = "*monetary"
        SMS                          = "*sms"
        MMS                          = "*mms"
        GENERIC                      = "*generic"
        DATA                         = "*data"
        VOICE                        = "*voice"
        MAX_COST_FREE                = "*free"
        MAX_COST_DISCONNECT          = "*disconnect"
        SECONDS                      = "seconds"
        META_OUT                     = "*out"
        META_ANY                     = "*any"
        ASR                          = "ASR"
        ACD                          = "ACD"
        TASKS_KEY                    = "tasks"
        ACTION_PLAN_PREFIX           = "apl_"
        AccountActionPlansPrefix     = "aap_"
        ACTION_TRIGGER_PREFIX        = "atr_"
        RATING_PLAN_PREFIX           = "rpl_"
        RATING_PROFILE_PREFIX        = "rpf_"
        ACTION_PREFIX                = "act_"
        SHARED_GROUP_PREFIX          = "shg_"
        ACCOUNT_PREFIX               = "acc_"
        DESTINATION_PREFIX           = "dst_"
        REVERSE_DESTINATION_PREFIX   = "rds_"
        DERIVEDCHARGERS_PREFIX       = "dcs_"
        USERS_PREFIX                 = "usr_"
        ResourcesPrefix              = "res_"
        ResourceProfilesPrefix       = "rsp_"
        ThresholdPrefix              = "thd_"
        TimingsPrefix                = "tmg_"
        FilterPrefix                 = "ftr_"
        CDR_STATS_PREFIX             = "cst_"
        VERSION_PREFIX               = "ver_"
        StatQueueProfilePrefix       = "sqp_"
        SupplierProfilePrefix        = "spp_"
        AttributeProfilePrefix       = "alp_"
        ChargerProfilePrefix         = "cpp_"
        DispatcherProfilePrefix      = "dpp_"
        DispatcherHostPrefix         = "dph_"
        ThresholdProfilePrefix       = "thp_"
        StatQueuePrefix              = "stq_"
        LoadIDPrefix                 = "lid_"
        LOADINST_KEY                 = "load_history"
        CREATE_CDRS_TABLES_SQL       = "create_cdrs_tables.sql"
        CREATE_TARIFFPLAN_TABLES_SQL = "create_tariffplan_tables.sql"
        TEST_SQL                     = "TEST_SQL"
        META_CONSTANT                = "*constant"
        META_FILLER                  = "*filler"
        META_HANDLER                 = "*handler"
        MetaHTTPPost                 = "*http_post"
        MetaHTTPjson                 = "*http_json"
        MetaHTTPjsonCDR              = "*http_json_cdr"
        MetaHTTPjsonMap              = "*http_json_map"
        MetaAMQPjsonCDR              = "*amqp_json_cdr"
        MetaAMQPjsonMap              = "*amqp_json_map"
        MetaAMQPV1jsonMap            = "*amqpv1_json_map"
        MetaSQSjsonMap               = "*sqs_json_map"
        MetaKafkajsonMap             = "*kafka_json_map"
        MetaSQL                      = "*sql"
        MetaMySQL                    = "*mysql"
        MetaS3jsonMap                = "*s3_json_map"
        CONFIG_PATH                  = "/etc/cgrates/"
        DISCONNECT_CAUSE             = "DisconnectCause"
        MetaFlatstore                = "*flatstore"
        MetaRating                   = "*rating"
        NOT_AVAILABLE                = "N/A"
        CALL                         = "call"
        EXTRA_FIELDS                 = "ExtraFields"
        META_SURETAX                 = "*sure_tax"
        MetaDynamic                  = "*dynamic"
        COUNTER_EVENT                = "*event"
        COUNTER_BALANCE              = "*balance"
        EVENT_NAME                   = "EventName"
        // action trigger threshold types
        TRIGGER_MIN_EVENT_COUNTER   = "*min_event_counter"
        TRIGGER_MAX_EVENT_COUNTER   = "*max_event_counter"
        TRIGGER_MAX_BALANCE_COUNTER = "*max_balance_counter"
        TRIGGER_MIN_BALANCE         = "*min_balance"
        TRIGGER_MAX_BALANCE         = "*max_balance"
        TRIGGER_BALANCE_EXPIRED     = "*balance_expired"
        HIERARCHY_SEP               = "&gt;"
        META_COMPOSED               = "*composed"
        META_USAGE_DIFFERENCE       = "*usage_difference"
        MetaSIPCID                  = "*sipcid"
        MetaDifference              = "*difference"
        MetaVariable                = "*variable"
        MetaCCUsage                 = "*cc_usage"
        MetaValueExponent           = "*value_exponent"
        NegativePrefix              = "!"
        MatchStartPrefix            = "^"
        MatchGreaterThanOrEqual     = "&gt;="
        MatchLessThanOrEqual        = "&lt;="
        MatchGreaterThan            = "&gt;"
        MatchLessThan               = "&lt;"
        MatchEndPrefix              = "$"
        MetaRaw                     = "*raw"
        CreatedAt                   = "CreatedAt"
        UpdatedAt                   = "UpdatedAt"
        HandlerArgSep               = "|"
        NodeID                      = "NodeID"
        ActiveGoroutines            = "ActiveGoroutines"
        MemoryUsage                 = "MemoryUsage"
        RunningSince                = "RunningSince"
        GoVersion                   = "GoVersion"
        SessionTTL                  = "SessionTTL"
        SessionTTLMaxDelay          = "SessionTTLMaxDelay"
        SessionTTLLastUsed          = "SessionTTLLastUsed"
        SessionTTLUsage             = "SessionTTLUsage"
        SessionTTLLastUsage         = "SessionTTLLastUsage"
        HandlerSubstractUsage       = "*substract_usage"
        XML                         = "xml"
        MetaGOB                     = "*gob"
        MetaJSON                    = "*json"
        MetaMSGPACK                 = "*msgpack"
        MetaDateTime                = "*datetime"
        MetaMaskedDestination       = "*masked_destination"
        MetaUnixTimestamp           = "*unix_timestamp"
        MetaPostCDR                 = "*post_cdr"
        MetaDumpToFile              = "*dump_to_file"
        NonTransactional            = ""
        DataDB                      = "data_db"
        StorDB                      = "stor_db"
        NotFoundCaps                = "NOT_FOUND"
        ServerErrorCaps             = "SERVER_ERROR"
        MandatoryIEMissingCaps      = "MANDATORY_IE_MISSING"
        UnsupportedCachePrefix      = "unsupported cache prefix"
        CDRSCtx                     = "cdrs"
        MandatoryInfoMissing        = "mandatory information missing"
        UnsupportedServiceIDCaps    = "UNSUPPORTED_SERVICE_ID"
        ServiceManager              = "service_manager"
        ServiceAlreadyRunning       = "service already running"
        RunningCaps                 = "RUNNING"
        StoppedCaps                 = "STOPPED"
        SchedulerNotRunningCaps     = "SCHEDULLER_NOT_RUNNING"
        MetaScheduler               = "*scheduler"
        MetaSessionsCosts           = "*sessions_costs"
        MetaRALs                    = "*rals"
        MetaRerate                  = "*rerate"
        MetaRefund                  = "*refund"
        MetaStats                   = "*stats"
        MetaResponder               = "*responder"
        MetaCore                    = "*core"
        MetaServiceManager          = "*servicemanager"
        MetaChargers                = "*chargers"
        MetaConfig                  = "*config"
        MetaDispatchers             = "*dispatchers"
        MetaDispatcherHosts         = "*dispatcher_hosts"
        MetaFilters                 = "*filters"
        MetaCDRs                    = "*cdrs"
        MetaCaches                  = "*caches"
        MetaGuardian                = "*guardians"
        MetaContinue                = "*continue"
        Migrator                    = "migrator"
        UnsupportedMigrationTask    = "unsupported migration task"
        NoStorDBConnection          = "not connected to StorDB"
        UndefinedVersion            = "undefined version"
        TxtSuffix                   = ".txt"
        JSNSuffix                   = ".json"
        GOBSuffix                   = ".gob"
        FormSuffix                  = ".form"
        XMLSuffix                   = ".xml"
        CSVSuffix                   = ".csv"
        FWVSuffix                   = ".fwv"
        CONTENT_JSON                = "json"
        CONTENT_FORM                = "form"
        CONTENT_TEXT                = "text"
        FileLockPrefix              = "file_"
        ActionsPoster               = "act"
        CDRPoster                   = "cdr"
        MetaFileCSV                 = "*file_csv"
        MetaFileFWV                 = "*file_fwv"
        MetaFScsv                   = "*freeswitch_csv"
        Accounts                    = "Accounts"
        AccountService              = "AccountS"
        Actions                     = "Actions"
        ActionPlans                 = "ActionPlans"
        ActionTriggers              = "ActionTriggers"
        SharedGroups                = "SharedGroups"
        TimingIDs                   = "TimingIDs"
        Timings                     = "Timings"
        Rates                       = "Rates"
        DestinationRates            = "DestinationRates"
        RatingPlans                 = "RatingPlans"
        RatingProfiles              = "RatingProfiles"
        AccountActions              = "AccountActions"
        Resources                   = "Resources"
        Stats                       = "Stats"
        Filters                     = "Filters"
        DispatcherProfiles          = "DispatcherProfiles"
        DispatcherHosts             = "DispatcherHosts"
        MetaEveryMinute             = "*every_minute"
        MetaHourly                  = "*hourly"
        ID                          = "ID"
        Thresholds                  = "Thresholds"
        Suppliers                   = "Suppliers"
        Attributes                  = "Attributes"
        Chargers                    = "Chargers"
        Dispatchers                 = "Dispatchers"
        StatS                       = "Stats"
        LoadIDsVrs                  = "LoadIDs"
        RALService                  = "RALs"
        CostSource                  = "CostSource"
        ExtraInfo                   = "ExtraInfo"
        Meta                        = "*"
        MetaSysLog                  = "*syslog"
        MetaStdLog                  = "*stdout"
        EventType                   = "EventType"
        EventSource                 = "EventSource"
        AccountID                   = "AccountID"
        ResourceID                  = "ResourceID"
        TotalUsage                  = "TotalUsage"
        StatID                      = "StatID"
        BalanceType                 = "BalanceType"
        BalanceID                   = "BalanceID"
        BalanceDestinationIds       = "BalanceDestinationIds"
        BalanceWeight               = "BalanceWeight"
        BalanceExpirationDate       = "BalanceExpirationDate"
        BalanceTimingTags           = "BalanceTimingTags"
        BalanceRatingSubject        = "BalanceRatingSubject"
        BalanceCategories           = "BalanceCategories"
        BalanceSharedGroups         = "BalanceSharedGroups"
        BalanceBlocker              = "BalanceBlocker"
        BalanceDisabled             = "BalanceDisabled"
        Units                       = "Units"
        AccountUpdate               = "AccountUpdate"
        BalanceUpdate               = "BalanceUpdate"
        StatUpdate                  = "StatUpdate"
        ResourceUpdate              = "ResourceUpdate"
        CDR                         = "CDR"
        CDRs                        = "CDRs"
        ExpiryTime                  = "ExpiryTime"
        AllowNegative               = "AllowNegative"
        Disabled                    = "Disabled"
        Action                      = "Action"
        MetaNow                     = "*now"
        SessionSCosts               = "SessionSCosts"
        Timing                      = "Timing"
        RQF                         = "RQF"
        Resource                    = "Resource"
        User                        = "User"
        Subscribers                 = "Subscribers"
        DerivedChargersV            = "DerivedChargers"
        Destinations                = "Destinations"
        ReverseDestinations         = "ReverseDestinations"
        RatingPlan                  = "RatingPlan"
        RatingProfile               = "RatingProfile"
        MetaRatingPlans             = "*rating_plans"
        MetaRatingProfiles          = "*rating_profiles"
        MetaUsers                   = "*users"
        MetaSubscribers             = "*subscribers"
        MetaDerivedChargersV        = "*derivedchargers"
        MetaStorDB                  = "*stordb"
        MetaDataDB                  = "*datadb"
        MetaWeight                  = "*weight"
        MetaLC                      = "*lc"
        MetaHC                      = "*hc"
        MetaQOS                     = "*qos"
        MetaReas                    = "*reas"
        MetaReds                    = "*reds"
        Weight                      = "Weight"
        Cost                        = "Cost"
        DestinationIDs              = "DestinationIDs"
        RatingSubject               = "RatingSubject"
        Categories                  = "Categories"
        Blocker                     = "Blocker"
        RatingPlanID                = "RatingPlanID"
        StartTime                   = "StartTime"
        AccountSummary              = "AccountSummary"
        RatingFilters               = "RatingFilters"
        RatingFilter                = "RatingFilter"
        Accounting                  = "Accounting"
        Rating                      = "Rating"
        Charges                     = "Charges"
        CompressFactor              = "CompressFactor"
        Increments                  = "Increments"
        Balance                     = "Balance"
        BalanceSummaries            = "BalanceSummaries"
        Type                        = "Type"
        YearsFieldName              = "Years"
        MonthsFieldName             = "Months"
        MonthDaysFieldName          = "MonthDays"
        WeekDaysFieldName           = "WeekDays"
        GroupIntervalStart          = "GroupIntervalStart"
        RateIncrement               = "RateIncrement"
        RateUnit                    = "RateUnit"
        BalanceUUID                 = "BalanceUUID"
        RatingID                    = "RatingID"
        ExtraChargeID               = "ExtraChargeID"
        ConnectFee                  = "ConnectFee"
        RoundingMethod              = "RoundingMethod"
        RoundingDecimals            = "RoundingDecimals"
        MaxCostStrategy             = "MaxCostStrategy"
        TimingID                    = "TimingID"
        RatesID                     = "RatesID"
        RatingFiltersID             = "RatingFiltersID"
        AccountingID                = "AccountingID"
        MetaSessionS                = "*sessions"
        MetaDefault                 = "*default"
        Error                       = "Error"
        MetaCgreq                   = "*cgreq"
        MetaCgrep                   = "*cgrep"
        MetaCGRAReq                 = "*cgrareq"
        CGR_ACD                     = "cgr_acd"
        FilterIDs                   = "FilterIDs"
        FieldName                   = "FieldName"
        Path                        = "Path"
        MetaRound                   = "*round"
        Pong                        = "Pong"
        MetaEventCost               = "*event_cost"
        MetaSuppliersMaxCost        = "*suppliers_maxcost"
        MetaMaxCost                 = "*maxcost"
        MetaSuppliersEventCost      = "*suppliers_event_cost"
        MetaSuppliersIgnoreErrors   = "*suppliers_ignore_errors"
        Freeswitch                  = "freeswitch"
        Kamailio                    = "kamailio"
        Opensips                    = "opensips"
        Asterisk                    = "asterisk"
        SchedulerS                  = "SchedulerS"
        MetaMultiply                = "*multiply"
        MetaDivide                  = "*divide"
        MetaUrl                     = "*url"
        MetaXml                     = "*xml"
        ApiKey                      = "apikey"
        MetaReq                     = "*req"
        MetaVars                    = "*vars"
        MetaRep                     = "*rep"
        MetaExp                     = "*exp"
        MetaHdr                     = "*hdr"
        MetaTrl                     = "*trl"
        MetaTmp                     = "*tmp"
        CGROriginHost               = "cgr_originhost"
        MetaInitiate                = "*initiate"
        MetaFD                      = "*fd"
        MetaUpdate                  = "*update"
        MetaTerminate               = "*terminate"
        MetaEvent                   = "*event"
        MetaMessage                 = "*message"
        MetaDryRun                  = "*dryrun"
        Event                       = "Event"
        EmptyString                 = ""
        DynamicDataPrefix           = "~"
        AttrValueSep                = "="
        ANDSep                      = "&amp;"
        PipeSep                     = "|"
        MetaApp                     = "*app"
        MetaAppID                   = "*appid"
        MetaCmd                     = "*cmd"
        MetaEnv                     = "*env:" // use in config for describing enviormant variables
        MetaTemplate                = "*template"
        MetaCCA                     = "*cca"
        MetaErr                     = "*err"
        OriginRealm                 = "OriginRealm"
        ProductName                 = "ProductName"
        IdxStart                    = "["
        IdxEnd                      = "]"
        MetaLog                     = "*log"
        MetaRemoteHost              = "*remote_host"
        RemoteHost                  = "RemoteHost"
        Local                       = "local"
        TCP                         = "tcp"
        CGRDebitInterval            = "CGRDebitInterval"
        Version                     = "Version"
        MetaTenant                  = "*tenant"
        ResourceUsage               = "ResourceUsage"
        MetaDuration                = "*duration"
        MetaLibPhoneNumber          = "*libphonenumber"
        MetaIP2Hex                  = "*ip2hex"
        MetaString2Hex              = "*string2hex"
        MetaReload                  = "*reload"
        MetaLoad                    = "*load"
        MetaRemove                  = "*remove"
        MetaRemoveAll               = "*removeall"
        MetaStore                   = "*store"
        MetaClear                   = "*clear"
        MetaExport                  = "*export"
        LoadIDs                     = "load_ids"
        DNSAgent                    = "DNSAgent"
        TLSNoCaps                   = "tls"
        MetaRouteID                 = "*route_id"
        MetaApiKey                  = "*api_key"
        UsageID                     = "UsageID"
        Rcode                       = "Rcode"
        Replacement                 = "Replacement"
        Regexp                      = "Regexp"
        Order                       = "Order"
        Preference                  = "Preference"
        Flags                       = "Flags"
        Service                     = "Service"
        MetaSuppliersLimit          = "*suppliers_limit"
        MetaSuppliersOffset         = "*suppliers_offset"
        ApierV                      = "ApierV"
        MetaApier                   = "*apier"
        MetaAnalyzer                = "*analyzer"
        CGREventString              = "CGREvent"
        MetaTextPlain               = "*text_plain"
        MetaIgnoreErrors            = "*ignore_errors"
        MetaRelease                 = "*release"
        MetaAllocate                = "*allocate"
        MetaAuthorize               = "*authorize"
        MetaInit                    = "*init"
        MetaRatingPlanCost          = "*rating_plan_cost"
        RatingPlanIDs               = "RatingPlanIDs"
        ERs                         = "ERs"
        Ratio                       = "Ratio"
        Load                        = "Load"
        Slash                       = "/"
        UUID                        = "UUID"
        ActionsID                   = "ActionsID"
        MetaAct                     = "*act"
        DestinationPrefix           = "DestinationPrefix"
        DestinationID               = "DestinationID"
        ExportTemplate              = "ExportTemplate"
        ExportFormat                = "ExportFormat"
        Synchronous                 = "Synchronous"
        Attempts                    = "Attempts"
        FieldSeparator              = "FieldSeparator"
        ExportPath                  = "ExportPath"
        ExportID                    = "ExportID"
        ExportFileName              = "ExportFileName"
        GroupID                     = "GroupID"
        ThresholdType               = "ThresholdType"
        ThresholdValue              = "ThresholdValue"
        Recurrent                   = "Recurrent"
        Executed                    = "Executed"
        MinSleep                    = "MinSleep"
        ActivationDate              = "ActivationDate"
        ExpirationDate              = "ExpirationDate"
        MinQueuedItems              = "MinQueuedItems"
        OrderIDStart                = "OrderIDStart"
        OrderIDEnd                  = "OrderIDEnd"
        MinCost                     = "MinCost"
        MaxCost                     = "MaxCost"
        MetaLoaders                 = "*loaders"
        TmpSuffix                   = ".tmp"
        MetaDiamreq                 = "*diamreq"
        MetaGroup                   = "*group"
        InternalRPCSet              = "InternalRPCSet"
        MetaFileName                = "*fileName"
        MetaBusy                    = "*busy"
        MetaQueue                   = "*queue"
        MetaRounding                = "*rounding"
)

// Migrator Action
const (
        Move    = "move"
        Migrate = "migrate"
)

// Meta Items
const (
        MetaAccounts            = "*accounts"
        MetaAccountActionPlans  = "*account_action_plans"
        MetaReverseDestinations = "*reverse_destinations"
        MetaActionPlans         = "*action_plans"
        MetaActionTriggers      = "*action_triggers"
        MetaActions             = "*actions"
        MetaResourceProfile     = "*resource_profiles"
        MetaStatQueueProfiles   = "*statqueue_profiles"
        MetaStatQueues          = "*statqueues"
        MetaThresholdProfiles   = "*threshold_profiles"
        MetaSupplierProfiles    = "*supplier_profiles"
        MetaAttributeProfiles   = "*attribute_profiles"
        MetaFilterIndexes       = "*filter_indexes"
        MetaDispatcherProfiles  = "*dispatcher_profiles"
        MetaChargerProfiles     = "*charger_profiles"
        MetaSharedGroups        = "*shared_groups"
        MetaThresholds          = "*thresholds"
        MetaSuppliers           = "*suppliers"
        MetaAttributes          = "*attributes"
        MetaLoadIDs             = "*load_ids"
)

// MetaMetrics
const (
        MetaASR      = "*asr"
        MetaACD      = "*acd"
        MetaTCD      = "*tcd"
        MetaACC      = "*acc"
        MetaTCC      = "*tcc"
        MetaPDD      = "*pdd"
        MetaDDC      = "*ddc"
        MetaSum      = "*sum"
        MetaAverage  = "*average"
        MetaDistinct = "*distinct"
)

// Services
const (
        SessionS    = "SessionS"
        AttributeS  = "AttributeS"
        SupplierS   = "SupplierS"
        ResourceS   = "ResourceS"
        StatService = "StatS"
        FilterS     = "FilterS"
        ThresholdS  = "ThresholdS"
        DispatcherS = "DispatcherS"
        LoaderS     = "LoaderS"
        ChargerS    = "ChargerS"
        CacheS      = "CacheS"
        AnalyzerS   = "AnalyzerS"
        CDRServer   = "CDRServer"
        ResponderS  = "ResponderS"
        GuardianS   = "GuardianS"
        ApierS      = "ApierS"
)

// Lower service names
const (
        SessionsLow    = "sessions"
        AttributesLow  = "attributes"
        ChargerSLow    = "chargers"
        SuppliersLow   = "suppliers"
        ResourcesLow   = "resources"
        StatServiceLow = "stats"
        ThresholdsLow  = "thresholds"
        DispatcherSLow = "dispatchers"
        AnalyzerSLow   = "analyzers"
        SchedulerSLow  = "schedulers"
        LoaderSLow     = "loaders"
        RALsLow        = "rals"
        ReplicatorLow  = "replicator"
        ApierSLow      = "apiers"
)

// Actions
const (
        LOG                       = "*log"
        RESET_TRIGGERS            = "*reset_triggers"
        SET_RECURRENT             = "*set_recurrent"
        UNSET_RECURRENT           = "*unset_recurrent"
        ALLOW_NEGATIVE            = "*allow_negative"
        DENY_NEGATIVE             = "*deny_negative"
        RESET_ACCOUNT             = "*reset_account"
        REMOVE_ACCOUNT            = "*remove_account"
        SET_BALANCE               = "*set_balance"
        REMOVE_BALANCE            = "*remove_balance"
        TOPUP_RESET               = "*topup_reset"
        TOPUP                     = "*topup"
        DEBIT_RESET               = "*debit_reset"
        DEBIT                     = "*debit"
        RESET_COUNTERS            = "*reset_counters"
        ENABLE_ACCOUNT            = "*enable_account"
        DISABLE_ACCOUNT           = "*disable_account"
        HttpPost                  = "*http_post"
        HttpPostAsync             = "*http_post_async"
        MAIL_ASYNC                = "*mail_async"
        UNLIMITED                 = "*unlimited"
        CDRLOG                    = "*cdrlog"
        SET_DDESTINATIONS         = "*set_ddestinations"
        TRANSFER_MONETARY_DEFAULT = "*transfer_monetary_default"
        CGR_RPC                   = "*cgr_rpc"
        TopUpZeroNegative         = "*topup_zero_negative"
        SetExpiry                 = "*set_expiry"
        MetaPublishAccount        = "*publish_account"
        MetaPublishBalance        = "*publish_balance"
        MetaRemoveSessionCosts    = "*remove_session_costs"
        MetaRemoveExpired         = "*remove_expired"
        MetaPostEvent             = "*post_event"
        MetaCDRAccount            = "*cdr_account"
)

// Migrator Metas
const (
        MetaSetVersions         = "*set_versions"
        MetaEnsureIndexes       = "*ensure_indexes"
        MetaTpRatingPlans       = "*tp_rating_plans"
        MetaTpFilters           = "*tp_filters"
        MetaTpDestinationRates  = "*tp_destination_rates"
        MetaTpActionTriggers    = "*tp_action_triggers"
        MetaTpAccountActions    = "*tp_account_actions"
        MetaTpActionPlans       = "*tp_action_plans"
        MetaTpActions           = "*tp_actions"
        MetaTpThresholds        = "*tp_thresholds"
        MetaTpSuppliers         = "*tp_suppliers"
        MetaTpStats             = "*tp_stats"
        MetaTpSharedGroups      = "*tp_shared_groups"
        MetaTpRatingProfiles    = "*tp_rating_profiles"
        MetaTpResources         = "*tp_resources"
        MetaTpRates             = "*tp_rates"
        MetaTpTimings           = "*tp_timings"
        MetaTpDestinations      = "*tp_destinations"
        MetaTpChargers          = "*tp_chargers"
        MetaTpDispatchers       = "*tp_dispatchers"
        MetaDurationSeconds     = "*duration_seconds"
        MetaDurationNanoseconds = "*duration_nanoseconds"
        CapAttributes           = "Attributes"
        CapResourceAllocation   = "ResourceAllocation"
        CapMaxUsage             = "MaxUsage"
        CapSuppliers            = "Suppliers"
        CapThresholds           = "Thresholds"
        CapStatQueues           = "StatQueues"
)

const (
        TpRatingPlans      = "TpRatingPlans"
        TpFilters          = "TpFilters"
        TpDestinationRates = "TpDestinationRates"
        TpActionTriggers   = "TpActionTriggers"
        TpAccountActionsV  = "TpAccountActions"
        TpActionPlans      = "TpActionPlans"
        TpActions          = "TpActions"
        TpThresholds       = "TpThresholds"
        TpSuppliers        = "TpSuppliers"
        TpStats            = "TpStats"
        TpSharedGroups     = "TpSharedGroups"
        TpRatingProfiles   = "TpRatingProfiles"
        TpResources        = "TpResources"
        TpRates            = "TpRates"
        TpTiming           = "TpTiming"
        TpResource         = "TpResource"
        TpDestinations     = "TpDestinations"
        TpRatingPlan       = "TpRatingPlan"
        TpRatingProfile    = "TpRatingProfile"
        TpChargers         = "TpChargers"
        TpDispatchers      = "TpDispatchers"
)

// Dispatcher Const
const (
        MetaFirst          = "*first"
        MetaRandom         = "*random"
        MetaBroadcast      = "*broadcast"
        MetaRoundRobin     = "*round_robin"
        MetaRatio          = "*ratio"
        ThresholdSv1       = "ThresholdSv1"
        StatSv1            = "StatSv1"
        ResourceSv1        = "ResourceSv1"
        SupplierSv1        = "SupplierSv1"
        AttributeSv1       = "AttributeSv1"
        SessionSv1         = "SessionSv1"
        ChargerSv1         = "ChargerSv1"
        MetaAuth           = "*auth"
        APIKey             = "APIKey"
        RouteID            = "RouteID"
        APIMethods         = "APIMethods"
        NestingSep         = "."
        ArgDispatcherField = "ArgDispatcher"
)

// Filter types
const (
        MetaNot            = "*not"
        MetaString         = "*string"
        MetaPrefix         = "*prefix"
        MetaSuffix         = "*suffix"
        MetaEmpty          = "*empty"
        MetaExists         = "*exists"
        MetaTimings        = "*timings"
        MetaRSR            = "*rsr"
        MetaStatS          = "*stats"
        MetaDestinations   = "*destinations"
        MetaLessThan       = "*lt"
        MetaLessOrEqual    = "*lte"
        MetaGreaterThan    = "*gt"
        MetaGreaterOrEqual = "*gte"
        MetaResources      = "*resources"
        MetaEqual          = "*eq"

        MetaNotString       = "*notstring"
        MetaNotPrefix       = "*notprefix"
        MetaNotSuffix       = "*notsuffix"
        MetaNotEmpty        = "*notempty"
        MetaNotExists       = "*notexists"
        MetaNotTimings      = "*nottimings"
        MetaNotRSR          = "*notrsr"
        MetaNotStatS        = "*notstats"
        MetaNotDestinations = "*notdestinations"
        MetaNotResources    = "*notresources"
        MetaNotEqual        = "*noteq"

        MetaEC = "*ec"
)

// ReplicatorSv1 APIs
const (
        ReplicatorSv1                        = "ReplicatorSv1"
        ReplicatorSv1Ping                    = "ReplicatorSv1.Ping"
        ReplicatorSv1GetAccount              = "ReplicatorSv1.GetAccount"
        ReplicatorSv1GetDestination          = "ReplicatorSv1.GetDestination"
        ReplicatorSv1GetReverseDestination   = "ReplicatorSv1.GetReverseDestination"
        ReplicatorSv1GetStatQueue            = "ReplicatorSv1.GetStatQueue"
        ReplicatorSv1GetFilter               = "ReplicatorSv1.GetFilter"
        ReplicatorSv1GetThreshold            = "ReplicatorSv1.GetThreshold"
        ReplicatorSv1GetThresholdProfile     = "ReplicatorSv1.GetThresholdProfile"
        ReplicatorSv1GetStatQueueProfile     = "ReplicatorSv1.GetStatQueueProfile"
        ReplicatorSv1GetTiming               = "ReplicatorSv1.GetTiming"
        ReplicatorSv1GetResource             = "ReplicatorSv1.GetResource"
        ReplicatorSv1GetResourceProfile      = "ReplicatorSv1.GetResourceProfile"
        ReplicatorSv1GetActionTriggers       = "ReplicatorSv1.GetActionTriggers"
        ReplicatorSv1GetShareGroup           = "ReplicatorSv1.GetShareGroup"
        ReplicatorSv1GetActions              = "ReplicatorSv1.GetActions"
        ReplicatorSv1GetActionPlan           = "ReplicatorSv1.GetActionPlan"
        ReplicatorSv1GetAllActionPlans       = "ReplicatorSv1.GetAllActionPlans"
        ReplicatorSv1GetAccountActionPlans   = "ReplicatorSv1.GetAccountActionPlans"
        ReplicatorSv1GetRatingPlan           = "ReplicatorSv1.GetRatingPlan"
        ReplicatorSv1GetRatingProfile        = "ReplicatorSv1.GetRatingProfile"
        ReplicatorSv1GetSupplierProfile      = "ReplicatorSv1.GetSupplierProfile"
        ReplicatorSv1GetAttributeProfile     = "ReplicatorSv1.GetAttributeProfile"
        ReplicatorSv1GetChargerProfile       = "ReplicatorSv1.GetChargerProfile"
        ReplicatorSv1GetDispatcherProfile    = "ReplicatorSv1.GetDispatcherProfile"
        ReplicatorSv1GetDispatcherHost       = "ReplicatorSv1.GetDispatcheHost"
        ReplicatorSv1GetItemLoadIDs          = "ReplicatorSv1.GetItemLoadIDs"
        ReplicatorSv1GetFilterIndexes        = "ReplicatorSv1.GetFilterIndexes"
        ReplicatorSv1MatchFilterIndex        = "ReplicatorSv1.MatchFilterIndex"
        ReplicatorSv1SetThresholdProfile     = "ReplicatorSv1.SetThresholdProfile"
        ReplicatorSv1SetThreshold            = "ReplicatorSv1.SetThreshold"
        ReplicatorSv1SetFilterIndexes        = "ReplicatorSv1.SetFilterIndexes"
        ReplicatorSv1Account                 = "ReplicatorSv1.SetAccount"
        ReplicatorSv1SetDestination          = "ReplicatorSv1.SetDestination"
        ReplicatorSv1SetReverseDestination   = "ReplicatorSv1.SetReverseDestination"
        ReplicatorSv1SetStatQueue            = "ReplicatorSv1.SetStatQueue"
        ReplicatorSv1SetFilter               = "ReplicatorSv1.SetFilter"
        ReplicatorSv1SetStatQueueProfile     = "ReplicatorSv1.SetStatQueueProfile"
        ReplicatorSv1SetTiming               = "ReplicatorSv1.SetTiming"
        ReplicatorSv1SetResource             = "ReplicatorSv1.SetResource"
        ReplicatorSv1SetResourceProfile      = "ReplicatorSv1.SetResourceProfile"
        ReplicatorSv1SetActionTriggers       = "ReplicatorSv1.SetActionTriggers"
        ReplicatorSv1SetSharedGroup          = "ReplicatorSv1.SetSharedGroup"
        ReplicatorSv1SetActions              = "ReplicatorSv1.SetActions"
        ReplicatorSv1SetActionPlan           = "ReplicatorSv1.SetActionPlan"
        ReplicatorSv1SetAccountActionPlans   = "ReplicatorSv1.SetAccountActionPlans"
        ReplicatorSv1SetRatingPlan           = "ReplicatorSv1.SetRatingPlan"
        ReplicatorSv1SetRatingProfile        = "ReplicatorSv1.SetRatingProfile"
        ReplicatorSv1SetSupplierProfile      = "ReplicatorSv1.SetSupplierProfile"
        ReplicatorSv1SetAttributeProfile     = "ReplicatorSv1.SetAttributeProfile"
        ReplicatorSv1SetChargerProfile       = "ReplicatorSv1.SetChargerProfile"
        ReplicatorSv1SetDispatcherProfile    = "ReplicatorSv1.SetDispatcherProfile"
        ReplicatorSv1SetDispatcherHost       = "ReplicatorSv1.SetDispatcherHost"
        ReplicatorSv1SetLoadIDs              = "ReplicatorSv1.SetLoadIDs"
        ReplicatorSv1RemoveThreshold         = "ReplicatorSv1.RemoveThreshold"
        ReplicatorSv1RemoveDestination       = "ReplicatorSv1.RemoveDestination"
        ReplicatorSv1RemoveAccount           = "ReplicatorSv1.RemoveAccount"
        ReplicatorSv1RemoveStatQueue         = "ReplicatorSv1.RemoveStatQueue"
        ReplicatorSv1RemoveFilter            = "ReplicatorSv1.RemoveFilter"
        ReplicatorSv1RemoveThresholdProfile  = "ReplicatorSv1.RemoveThresholdProfile"
        ReplicatorSv1RemoveStatQueueProfile  = "ReplicatorSv1.RemoveStatQueueProfile"
        ReplicatorSv1RemoveTiming            = "ReplicatorSv1.RemoveTiming"
        ReplicatorSv1RemoveResource          = "ReplicatorSv1.RemoveResource"
        ReplicatorSv1RemoveResourceProfile   = "ReplicatorSv1.RemoveResourceProfile"
        ReplicatorSv1RemoveActionTriggers    = "ReplicatorSv1.RemoveActionTriggers"
        ReplicatorSv1RemoveSharedGroup       = "ReplicatorSv1.RemoveSharedGroup"
        ReplicatorSv1RemoveActions           = "ReplicatorSv1.RemoveActions"
        ReplicatorSv1RemoveActionPlan        = "ReplicatorSv1.RemoveActionPlan"
        ReplicatorSv1RemAccountActionPlans   = "ReplicatorSv1.RemAccountActionPlans"
        ReplicatorSv1RemoveRatingPlan        = "ReplicatorSv1.RemoveRatingPlan"
        ReplicatorSv1RemoveRatingProfile     = "ReplicatorSv1.RemoveRatingProfile"
        ReplicatorSv1RemoveSupplierProfile   = "ReplicatorSv1.RemoveSupplierProfile"
        ReplicatorSv1RemoveAttributeProfile  = "ReplicatorSv1.RemoveAttributeProfile"
        ReplicatorSv1RemoveChargerProfile    = "ReplicatorSv1.RemoveChargerProfile"
        ReplicatorSv1RemoveDispatcherProfile = "ReplicatorSv1.RemoveDispatcherProfile"
        ReplicatorSv1RemoveDispatcherHost    = "ReplicatorSv1.RemoveDispatcherHost"
)

// APIerSv1 APIs
const (
        ApierV1                                   = "ApierV1"
        ApierV2                                   = "ApierV2"
        APIerSv1                                  = "APIerSv1"
        APIerSv1ComputeFilterIndexes              = "APIerSv1.ComputeFilterIndexes"
        APIerSv1ComputeFilterIndexIDs             = "APIerSv1.ComputeFilterIndexIDs"
        APIerSv1Ping                              = "APIerSv1.Ping"
        APIerSv1SetDispatcherProfile              = "APIerSv1.SetDispatcherProfile"
        APIerSv1GetDispatcherProfile              = "APIerSv1.GetDispatcherProfile"
        APIerSv1GetDispatcherProfileIDs           = "APIerSv1.GetDispatcherProfileIDs"
        APIerSv1RemoveDispatcherProfile           = "APIerSv1.RemoveDispatcherProfile"
        APIerSv1SetDispatcherHost                 = "APIerSv1.SetDispatcherHost"
        APIerSv1GetDispatcherHost                 = "APIerSv1.GetDispatcherHost"
        APIerSv1GetDispatcherHostIDs              = "APIerSv1.GetDispatcherHostIDs"
        APIerSv1RemoveDispatcherHost              = "APIerSv1.RemoveDispatcherHost"
        APIerSv1GetEventCost                      = "APIerSv1.GetEventCost"
        APIerSv1LoadTariffPlanFromFolder          = "APIerSv1.LoadTariffPlanFromFolder"
        APIerSv1GetCost                           = "APIerSv1.GetCost"
        APIerSv1SetBalance                        = "APIerSv1.SetBalance"
        APIerSv1GetFilter                         = "APIerSv1.GetFilter"
        APIerSv1GetFilterIndexes                  = "APIerSv1.GetFilterIndexes"
        APIerSv1RemoveFilterIndexes               = "APIerSv1.RemoveFilterIndexes"
        APIerSv1RemoveFilter                      = "APIerSv1.RemoveFilter"
        APIerSv1SetFilter                         = "APIerSv1.SetFilter"
        APIerSv1GetFilterIDs                      = "APIerSv1.GetFilterIDs"
        APIerSv1GetAccountActionPlansIndexHealth  = "APIerSv1.GetAccountActionPlansIndexHealth"
        APIerSv1GetReverseDestinationsIndexHealth = "APIerSv1.GetReverseDestinationsIndexHealth"
        APIerSv1GetThresholdsIndexesHealth        = "APIerSv1.GetThresholdsIndexesHealth"
        APIerSv1GetResourcesIndexesHealth         = "APIerSv1.GetResourcesIndexesHealth"
        APIerSv1GetStatsIndexesHealth             = "APIerSv1.GetStatsIndexesHealth"
        APIerSv1GetSuppliersIndexesHealth         = "APIerSv1.GetSuppliersIndexesHealth"
        APIerSv1GetChargersIndexesHealth          = "APIerSv1.GetChargersIndexesHealth"
        APIerSv1GetAttributesIndexesHealth        = "APIerSv1.GetAttributesIndexesHealth"
        APIerSv1GetDispatchersIndexesHealth       = "APIerSv1.GetDispatchersIndexesHealth"
        APIerSv1GetRatingProfile                  = "APIerSv1.GetRatingProfile"
        APIerSv1RemoveRatingProfile               = "APIerSv1.RemoveRatingProfile"
        APIerSv1SetRatingProfile                  = "APIerSv1.SetRatingProfile"
        APIerSv1GetRatingProfileIDs               = "APIerSv1.GetRatingProfileIDs"
        APIerSv1SetDataDBVersions                 = "APIerSv1.SetDataDBVersions"
        APIerSv1SetStorDBVersions                 = "APIerSv1.SetStorDBVersions"
        APIerSv1GetAccountActionPlan              = "APIerSv1.GetAccountActionPlan"
        APIerSv1ComputeActionPlanIndexes          = "APIerSv1.ComputeActionPlanIndexes"
        APIerSv1GetActions                        = "APIerSv1.GetActions"
        APIerSv1GetActionPlan                     = "APIerSv1.GetActionPlan"
        APIerSv1GetActionPlanIDs                  = "APIerSv1.GetActionPlanIDs"
        APIerSv1GetRatingPlanIDs                  = "APIerSv1.GetRatingPlanIDs"
        APIerSv1GetRatingPlan                     = "APIerSv1.GetRatingPlan"
        APIerSv1RemoveRatingPlan                  = "APIerSv1.RemoveRatingPlan"
        APIerSv1GetDestination                    = "APIerSv1.GetDestination"
        APIerSv1GetReverseDestination             = "APIerSv1.GetReverseDestination"
        APIerSv1AddBalance                        = "APIerSv1.AddBalance"
        APIerSv1DebitBalance                      = "APIerSv1.DebitBalance"
        APIerSv1SetAccount                        = "APIerSv1.SetAccount"
        APIerSv1GetAccountsCount                  = "APIerSv1.GetAccountsCount"
        APIerSv1GetDataDBVersions                 = "APIerSv1.GetDataDBVersions"
        APIerSv1GetStorDBVersions                 = "APIerSv1.GetStorDBVersions"
        APIerSv1GetCDRs                           = "APIerSv1.GetCDRs"
        APIerSv1GetTPAccountActions               = "APIerSv1.GetTPAccountActions"
        APIerSv1SetTPAccountActions               = "APIerSv1.SetTPAccountActions"
        APIerSv1GetTPAccountActionsByLoadId       = "APIerSv1.GetTPAccountActionsByLoadId"
        APIerSv1GetTPAccountActionLoadIds         = "APIerSv1.GetTPAccountActionLoadIds"
        APIerSv1GetTPAccountActionIds             = "APIerSv1.GetTPAccountActionIds"
        APIerSv1RemoveTPAccountActions            = "APIerSv1.RemoveTPAccountActions"
        APIerSv1GetTPActionPlan                   = "APIerSv1.GetTPActionPlan"
        APIerSv1SetTPActionPlan                   = "APIerSv1.SetTPActionPlan"
        APIerSv1GetTPActionPlanIds                = "APIerSv1.GetTPActionPlanIds"
        APIerSv1SetTPActionTriggers               = "APIerSv1.SetTPActionTriggers"
        APIerSv1GetTPActionTriggers               = "APIerSv1.GetTPActionTriggers"
        APIerSv1RemoveTPActionTriggers            = "APIerSv1.RemoveTPActionTriggers"
        APIerSv1GetTPActionTriggerIds             = "APIerSv1.GetTPActionTriggerIds"
        APIerSv1GetTPActions                      = "APIerSv1.GetTPActions"
        APIerSv1RemoveTPActionPlan                = "APIerSv1.RemoveTPActionPlan"
        APIerSv1GetTPAttributeProfile             = "APIerSv1.GetTPAttributeProfile"
        APIerSv1SetTPAttributeProfile             = "APIerSv1.SetTPAttributeProfile"
        APIerSv1GetTPAttributeProfileIds          = "APIerSv1.GetTPAttributeProfileIds"
        APIerSv1RemoveTPAttributeProfile          = "APIerSv1.RemoveTPAttributeProfile"
        APIerSv1GetTPCharger                      = "APIerSv1.GetTPCharger"
        APIerSv1SetTPCharger                      = "APIerSv1.SetTPCharger"
        APIerSv1RemoveTPCharger                   = "APIerSv1.RemoveTPCharger"
        APIerSv1GetTPChargerIDs                   = "APIerSv1.GetTPChargerIDs"
        APIerSv1SetTPFilterProfile                = "APIerSv1.SetTPFilterProfile"
        APIerSv1GetTPFilterProfile                = "APIerSv1.GetTPFilterProfile"
        APIerSv1GetTPFilterProfileIds             = "APIerSv1.GetTPFilterProfileIds"
        APIerSv1RemoveTPFilterProfile             = "APIerSv1.RemoveTPFilterProfile"
        APIerSv1GetTPDestination                  = "APIerSv1.GetTPDestination"
        APIerSv1SetTPDestination                  = "APIerSv1.SetTPDestination"
        APIerSv1GetTPDestinationIDs               = "APIerSv1.GetTPDestinationIDs"
        APIerSv1RemoveTPDestination               = "APIerSv1.RemoveTPDestination"
        APIerSv1GetTPResource                     = "APIerSv1.GetTPResource"
        APIerSv1SetTPResource                     = "APIerSv1.SetTPResource"
        APIerSv1RemoveTPResource                  = "APIerSv1.RemoveTPResource"
        APIerSv1SetTPRate                         = "APIerSv1.SetTPRate"
        APIerSv1GetTPRate                         = "APIerSv1.GetTPRate"
        APIerSv1RemoveTPRate                      = "APIerSv1.RemoveTPRate"
        APIerSv1GetTPRateIds                      = "APIerSv1.GetTPRateIds"
        APIerSv1SetTPThreshold                    = "APIerSv1.SetTPThreshold"
        APIerSv1GetTPThreshold                    = "APIerSv1.GetTPThreshold"
        APIerSv1GetTPThresholdIDs                 = "APIerSv1.GetTPThresholdIDs"
        APIerSv1RemoveTPThreshold                 = "APIerSv1.RemoveTPThreshold"
        APIerSv1SetTPStat                         = "APIerSv1.SetTPStat"
        APIerSv1GetTPStat                         = "APIerSv1.GetTPStat"
        APIerSv1RemoveTPStat                      = "APIerSv1.RemoveTPStat"
        APIerSv1GetTPDestinationRate              = "APIerSv1.GetTPDestinationRate"
        APIerSv1SetTPSupplierProfile              = "APIerSv1.SetTPSupplierProfile"
        APIerSv1GetTPSupplierProfile              = "APIerSv1.GetTPSupplierProfile"
        APIerSv1GetTPSupplierProfileIDs           = "APIerSv1.GetTPSupplierProfileIDs"
        APIerSv1RemoveTPSupplierProfile           = "APIerSv1.RemoveTPSupplierProfile"
        APIerSv1GetTPDispatcherProfile            = "APIerSv1.GetTPDispatcherProfile"
        APIerSv1SetTPDispatcherProfile            = "APIerSv1.SetTPDispatcherProfile"
        APIerSv1RemoveTPDispatcherProfile         = "APIerSv1.RemoveTPDispatcherProfile"
        APIerSv1GetTPDispatcherProfileIDs         = "APIerSv1.GetTPDispatcherProfileIDs"
        APIerSv1GetTPSharedGroups                 = "APIerSv1.GetTPSharedGroups"
        APIerSv1SetTPSharedGroups                 = "APIerSv1.SetTPSharedGroups"
        APIerSv1GetTPSharedGroupIds               = "APIerSv1.GetTPSharedGroupIds"
        APIerSv1RemoveTPSharedGroups              = "APIerSv1.RemoveTPSharedGroups"
        APIerSv1ExportCDRs                        = "APIerSv1.ExportCDRs"
        APIerSv1GetTPRatingPlan                   = "APIerSv1.GetTPRatingPlan"
        APIerSv1SetTPRatingPlan                   = "APIerSv1.SetTPRatingPlan"
        APIerSv1GetTPRatingPlanIds                = "APIerSv1.GetTPRatingPlanIds"
        APIerSv1RemoveTPRatingPlan                = "APIerSv1.RemoveTPRatingPlan"
        APIerSv1SetTPActions                      = "APIerSv1.SetTPActions"
        APIerSv1GetTPActionIds                    = "APIerSv1.GetTPActionIds"
        APIerSv1RemoveTPActions                   = "APIerSv1.RemoveTPActions"
        APIerSv1SetActionPlan                     = "APIerSv1.SetActionPlan"
        APIerSv1ExecuteAction                     = "APIerSv1.ExecuteAction"
        APIerSv1SetTPRatingProfile                = "APIerSv1.SetTPRatingProfile"
        APIerSv1GetTPRatingProfile                = "APIerSv1.GetTPRatingProfile"
        APIerSv1RemoveTPRatingProfile             = "APIerSv1.RemoveTPRatingProfile"
        APIerSv1SetTPDestinationRate              = "APIerSv1.SetTPDestinationRate"
        APIerSv1GetTPRatingProfileLoadIds         = "APIerSv1.GetTPRatingProfileLoadIds"
        APIerSv1GetTPRatingProfilesByLoadID       = "APIerSv1.GetTPRatingProfilesByLoadID"
        APIerSv1GetTPRatingProfileIds             = "APIerSv1.GetTPRatingProfileIds"
        APIerSv1GetTPDestinationRateIds           = "APIerSv1.GetTPDestinationRateIds"
        APIerSv1RemoveTPDestinationRate           = "APIerSv1.RemoveTPDestinationRate"
        APIerSv1ImportTariffPlanFromFolder        = "APIerSv1.ImportTariffPlanFromFolder"
        APIerSv1ExportTPToFolder                  = "APIerSv1.ExportTPToFolder"
        APIerSv1LoadRatingPlan                    = "APIerSv1.LoadRatingPlan"
        APIerSv1LoadRatingProfile                 = "APIerSv1.LoadRatingProfile"
        APIerSv1LoadAccountActions                = "APIerSv1.LoadAccountActions"
        APIerSv1SetActions                        = "APIerSv1.SetActions"
        APIerSv1AddTriggeredAction                = "APIerSv1.AddTriggeredAction"
        APIerSv1GetAccountActionTriggers          = "APIerSv1.GetAccountActionTriggers"
        APIerSv1AddAccountActionTriggers          = "APIerSv1.AddAccountActionTriggers"
        APIerSv1ResetAccountActionTriggers        = "APIerSv1.ResetAccountActionTriggers"
        APIerSv1SetAccountActionTriggers          = "APIerSv1.SetAccountActionTriggers"
        APIerSv1RemoveAccountActionTriggers       = "APIerSv1.RemoveAccountActionTriggers"
        APIerSv1GetScheduledActions               = "APIerSv1.GetScheduledActions"
        APIerSv1RemoveActionTiming                = "APIerSv1.RemoveActionTiming"
        APIerSv1ComputeReverseDestinations        = "APIerSv1.ComputeReverseDestinations"
        APIerSv1ComputeAccountActionPlans         = "APIerSv1.ComputeAccountActionPlans"
        APIerSv1SetDestination                    = "APIerSv1.SetDestination"
        APIerSv1GetDataCost                       = "APIerSv1.GetDataCost"
        APIerSv1ReplayFailedPosts                 = "APIerSv1.ReplayFailedPosts"
        APIerSv1RemoveAccount                     = "APIerSv1.RemoveAccount"
        APIerSv1DebitUsage                        = "APIerSv1.DebitUsage"
        APIerSv1GetCacheStats                     = "APIerSv1.GetCacheStats"
        APIerSv1ReloadCache                       = "APIerSv1.ReloadCache"
        APIerSv1GetActionTriggers                 = "APIerSv1.GetActionTriggers"
        APIerSv1SetActionTrigger                  = "APIerSv1.SetActionTrigger"
        APIerSv1RemoveActionPlan                  = "APIerSv1.RemoveActionPlan"
        APIerSv1RemoveActions                     = "APIerSv1.RemoveActions"
        APIerSv1RemoveBalances                    = "APIerSv1.RemoveBalances"
        APIerSv1ReloadCdreConfig                  = "APIerSv1.ReloadCdreConfig"
        APIerSv1GetLoadHistory                    = "APIerSv1.GetLoadHistory"
        APIerSv1GetLoadIDs                        = "APIerSv1.GetLoadIDs"
        APIerSv1ExecuteScheduledActions           = "APIerSv1.ExecuteScheduledActions"
        APIerSv1GetLoadTimes                      = "APIerSv1.GetLoadTimes"
        APIerSv1GetSharedGroup                    = "APIerSv1.GetSharedGroup"
        APIerSv1RemoveActionTrigger               = "APIerSv1.RemoveActionTrigger"
        APIerSv1GetAccount                        = "APIerSv1.GetAccount"
)

// APIerSv1 TP APIs
const (
        APIerSv1SetTPTiming              = "APIerSv1.SetTPTiming"
        APIerSv1GetTPTiming              = "APIerSv1.GetTPTiming"
        APIerSv1RemoveTPTiming           = "APIerSv1.RemoveTPTiming"
        APIerSv1GetTPTimingIds           = "APIerSv1.GetTPTimingIds"
        APIerSv1LoadTariffPlanFromStorDb = "APIerSv1.LoadTariffPlanFromStorDb"
        APIerSv1RemoveTPFromFolder       = "APIerSv1.RemoveTPFromFolder"
)

// APIerSv2 APIs
const (
        APIerSv2                           = "APIerSv2"
        APIerSv2LoadTariffPlanFromFolder   = "APIerSv2.LoadTariffPlanFromFolder"
        APIerSv2GetCDRs                    = "APIerSv2.GetCDRs"
        APIerSv2GetAccount                 = "APIerSv2.GetAccount"
        APIerSv2GetAccounts                = "APIerSv2.GetAccounts"
        APIerSv2SetAccount                 = "APIerSv2.SetAccount"
        APIerSv2CountCDRs                  = "APIerSv2.CountCDRs"
        APIerSv2SetBalance                 = "APIerSv2.SetBalance"
        APIerSv2SetActions                 = "APIerSv2.SetActions"
        APIerSv2RemoveTPTiming             = "APIerSv2.RemoveTPTiming"
        APIerSv2GetTPDestination           = "APIerSv2.GetTPDestination"
        APIerSv2SetTPDestination           = "APIerSv2.SetTPDestination"
        APIerSv2RemoveTPDestination        = "APIerSv2.RemoveTPDestination"
        APIerSv2GetTPDestinationIDs        = "APIerSv2.GetTPDestinationIDs"
        APIerSv2GetTPTiming                = "APIerSv2.GetTPTiming"
        APIerSv2SetTPTiming                = "APIerSv2.SetTPTiming"
        APIerSv2SetAccountActionTriggers   = "APIerSv2.SetAccountActionTriggers"
        APIerSv2GetAccountActionTriggers   = "APIerSv2.GetAccountActionTriggers"
        APIerSv2SetActionPlan              = "APIerSv2.SetActionPlan"
        APIerSv2GetActions                 = "APIerSv2.GetActions"
        APIerSv2GetDestinations            = "APIerSv2.GetDestinations"
        APIerSv2GetCacheStats              = "APIerSv2.GetCacheStats"
        APIerSv2ExecuteAction              = "APIerSv2.ExecuteAction"
        APIerSv2ResetAccountActionTriggers = "APIerSv2.ResetAccountActionTriggers"
        APIerSv2RemoveActions              = "APIerSv2.RemoveActions"
)

const (
        ServiceManagerV1              = "ServiceManagerV1"
        ServiceManagerV1StartService  = "ServiceManagerV1.StartService"
        ServiceManagerV1StopService   = "ServiceManagerV1.StopService"
        ServiceManagerV1ServiceStatus = "ServiceManagerV1.ServiceStatus"
        ServiceManagerV1Ping          = "ServiceManagerV1.Ping"
)

const (
        ConfigSv1                     = "ConfigSv1"
        ConfigSv1GetJSONSection       = "ConfigSv1.GetJSONSection"
        ConfigSv1ReloadConfigFromPath = "ConfigSv1.ReloadConfigFromPath"
        ConfigSv1ReloadConfigFromJSON = "ConfigSv1.ReloadConfigFromJSON"
)

const (
        RALsV1                   = "RALsV1"
        RALsV1GetRatingPlansCost = "RALsV1.GetRatingPlansCost"
        RALsV1Ping               = "RALsV1.Ping"
)

const (
        CoreS         = "CoreS"
        CoreSv1       = "CoreSv1"
        CoreSv1Status = "CoreSv1.Status"
        CoreSv1Ping   = "CoreSv1.Ping"
        CoreSv1Sleep  = "CoreSv1.Sleep"
)

// SupplierS APIs
const (
        SupplierSv1GetSuppliers                = "SupplierSv1.GetSuppliers"
        SupplierSv1GetSupplierProfilesForEvent = "SupplierSv1.GetSupplierProfilesForEvent"
        SupplierSv1Ping                        = "SupplierSv1.Ping"
        APIerSv1GetSupplierProfile             = "APIerSv1.GetSupplierProfile"
        APIerSv1GetSupplierProfileIDs          = "APIerSv1.GetSupplierProfileIDs"
        APIerSv1RemoveSupplierProfile          = "APIerSv1.RemoveSupplierProfile"
        APIerSv1SetSupplierProfile             = "APIerSv1.SetSupplierProfile"
)

// AttributeS APIs
const (
        APIerSv1SetAttributeProfile      = "APIerSv1.SetAttributeProfile"
        APIerSv1GetAttributeProfile      = "APIerSv1.GetAttributeProfile"
        APIerSv1GetAttributeProfileIDs   = "APIerSv1.GetAttributeProfileIDs"
        APIerSv1RemoveAttributeProfile   = "APIerSv1.RemoveAttributeProfile"
        APIerSv2SetAttributeProfile      = "APIerSv2.SetAttributeProfile"
        AttributeSv1GetAttributeForEvent = "AttributeSv1.GetAttributeForEvent"
        AttributeSv1ProcessEvent         = "AttributeSv1.ProcessEvent"
        AttributeSv1Ping                 = "AttributeSv1.Ping"
)

// ChargerS APIs
const (
        ChargerSv1Ping                = "ChargerSv1.Ping"
        ChargerSv1GetChargersForEvent = "ChargerSv1.GetChargersForEvent"
        ChargerSv1ProcessEvent        = "ChargerSv1.ProcessEvent"
        APIerSv1GetChargerProfile     = "APIerSv1.GetChargerProfile"
        APIerSv1RemoveChargerProfile  = "APIerSv1.RemoveChargerProfile"
        APIerSv1SetChargerProfile     = "APIerSv1.SetChargerProfile"
        APIerSv1GetChargerProfileIDs  = "APIerSv1.GetChargerProfileIDs"
)

// ThresholdS APIs
const (
        ThresholdSv1ProcessEvent          = "ThresholdSv1.ProcessEvent"
        ThresholdSv1GetThreshold          = "ThresholdSv1.GetThreshold"
        ThresholdSv1GetThresholdIDs       = "ThresholdSv1.GetThresholdIDs"
        ThresholdSv1Ping                  = "ThresholdSv1.Ping"
        ThresholdSv1GetThresholdsForEvent = "ThresholdSv1.GetThresholdsForEvent"
        APIerSv1GetThresholdProfileIDs    = "APIerSv1.GetThresholdProfileIDs"
        APIerSv1GetThresholdProfile       = "APIerSv1.GetThresholdProfile"
        APIerSv1RemoveThresholdProfile    = "APIerSv1.RemoveThresholdProfile"
        APIerSv1SetThresholdProfile       = "APIerSv1.SetThresholdProfile"
)

// StatS APIs
const (
        StatSv1ProcessEvent            = "StatSv1.ProcessEvent"
        StatSv1GetQueueIDs             = "StatSv1.GetQueueIDs"
        StatSv1GetQueueStringMetrics   = "StatSv1.GetQueueStringMetrics"
        StatSv1GetQueueFloatMetrics    = "StatSv1.GetQueueFloatMetrics"
        StatSv1Ping                    = "StatSv1.Ping"
        StatSv1GetStatQueuesForEvent   = "StatSv1.GetStatQueuesForEvent"
        StatSv1GetStatQueue            = "StatSv1.GetStatQueue"
        APIerSv1GetStatQueueProfile    = "APIerSv1.GetStatQueueProfile"
        APIerSv1RemoveStatQueueProfile = "APIerSv1.RemoveStatQueueProfile"
        APIerSv1SetStatQueueProfile    = "APIerSv1.SetStatQueueProfile"
        APIerSv1GetStatQueueProfileIDs = "APIerSv1.GetStatQueueProfileIDs"
)

// ResourceS APIs
const (
        ResourceSv1AuthorizeResources   = "ResourceSv1.AuthorizeResources"
        ResourceSv1GetResourcesForEvent = "ResourceSv1.GetResourcesForEvent"
        ResourceSv1AllocateResources    = "ResourceSv1.AllocateResources"
        ResourceSv1ReleaseResources     = "ResourceSv1.ReleaseResources"
        ResourceSv1Ping                 = "ResourceSv1.Ping"
        ResourceSv1GetResource          = "ResourceSv1.GetResource"
        APIerSv1SetResourceProfile      = "APIerSv1.SetResourceProfile"
        APIerSv1RemoveResourceProfile   = "APIerSv1.RemoveResourceProfile"
        APIerSv1GetResourceProfile      = "APIerSv1.GetResourceProfile"
        APIerSv1GetResourceProfileIDs   = "APIerSv1.GetResourceProfileIDs"
)

// SessionS APIs
const (
        SessionSv1AuthorizeEvent             = "SessionSv1.AuthorizeEvent"
        SessionSv1AuthorizeEventWithDigest   = "SessionSv1.AuthorizeEventWithDigest"
        SessionSv1InitiateSession            = "SessionSv1.InitiateSession"
        SessionSv1InitiateSessionWithDigest  = "SessionSv1.InitiateSessionWithDigest"
        SessionSv1UpdateSession              = "SessionSv1.UpdateSession"
        SessionSv1SyncSessions               = "SessionSv1.SyncSessions"
        SessionSv1TerminateSession           = "SessionSv1.TerminateSession"
        SessionSv1ProcessCDR                 = "SessionSv1.ProcessCDR"
        SessionSv1ProcessMessage             = "SessionSv1.ProcessMessage"
        SessionSv1ProcessEvent               = "SessionSv1.ProcessEvent"
        SessionSv1DisconnectSession          = "SessionSv1.DisconnectSession"
        SessionSv1GetActiveSessions          = "SessionSv1.GetActiveSessions"
        SessionSv1GetActiveSessionsCount     = "SessionSv1.GetActiveSessionsCount"
        SessionSv1ForceDisconnect            = "SessionSv1.ForceDisconnect"
        SessionSv1GetPassiveSessions         = "SessionSv1.GetPassiveSessions"
        SessionSv1GetPassiveSessionsCount    = "SessionSv1.GetPassiveSessionsCount"
        SessionSv1SetPassiveSession          = "SessionSv1.SetPassiveSession"
        SessionSv1Ping                       = "SessionSv1.Ping"
        SessionSv1GetActiveSessionIDs        = "SessionSv1.GetActiveSessionIDs"
        SessionSv1RegisterInternalBiJSONConn = "SessionSv1.RegisterInternalBiJSONConn"
        SessionSv1ReplicateSessions          = "SessionSv1.ReplicateSessions"
        SessionSv1ActivateSessions           = "SessionSv1.ActivateSessions"
        SessionSv1DeactivateSessions         = "SessionSv1.DeactivateSessions"
        SMGenericV1InitiateSession           = "SMGenericV1.InitiateSession"
        SessionSv1Sleep                      = "SessionSv1.Sleep"
)

// Responder APIs
const (
        Responder                            = "Responder"
        ResponderDebit                       = "Responder.Debit"
        ResponderRefundIncrements            = "Responder.RefundIncrements"
        ResponderGetMaxSessionTime           = "Responder.GetMaxSessionTime"
        ResponderMaxDebit                    = "Responder.MaxDebit"
        ResponderRefundRounding              = "Responder.RefundRounding"
        ResponderGetCost                     = "Responder.GetCost"
        ResponderGetCostOnRatingPlans        = "Responder.GetCostOnRatingPlans"
        ResponderGetMaxSessionTimeOnAccounts = "Responder.GetMaxSessionTimeOnAccounts"
        ResponderShutdown                    = "Responder.Shutdown"
        ResponderPing                        = "Responder.Ping"
)

// DispatcherS APIs
const (
        DispatcherSv1Ping               = "DispatcherSv1.Ping"
        DispatcherSv1GetProfileForEvent = "DispatcherSv1.GetProfileForEvent"
        DispatcherSv1Apier              = "DispatcherSv1.Apier"
        DispatcherServicePing           = "DispatcherService.Ping"
)

// AnalyzerS APIs
const (
        AnalyzerSv1     = "AnalyzerSv1"
        AnalyzerSv1Ping = "AnalyzerSv1.Ping"
)

// LoaderS APIs
const (
        LoaderSv1       = "LoaderSv1"
        LoaderSv1Load   = "LoaderSv1.Load"
        LoaderSv1Remove = "LoaderSv1.Remove"
        LoaderSv1Ping   = "LoaderSv1.Ping"
)

// CacheS APIs
const (
        CacheSv1                  = "CacheSv1"
        CacheSv1GetCacheStats     = "CacheSv1.GetCacheStats"
        CacheSv1GetItemIDs        = "CacheSv1.GetItemIDs"
        CacheSv1HasItem           = "CacheSv1.HasItem"
        CacheSv1GetItemExpiryTime = "CacheSv1.GetItemExpiryTime"
        CacheSv1RemoveItem        = "CacheSv1.RemoveItem"
        CacheSv1PrecacheStatus    = "CacheSv1.PrecacheStatus"
        CacheSv1HasGroup          = "CacheSv1.HasGroup"
        CacheSv1GetGroupItemIDs   = "CacheSv1.GetGroupItemIDs"
        CacheSv1RemoveGroup       = "CacheSv1.RemoveGroup"
        CacheSv1Clear             = "CacheSv1.Clear"
        CacheSv1ReloadCache       = "CacheSv1.ReloadCache"
        CacheSv1LoadCache         = "CacheSv1.LoadCache"
        CacheSv1FlushCache        = "CacheSv1.FlushCache"
        CacheSv1Ping              = "CacheSv1.Ping"
)

// GuardianS APIs
const (
        GuardianSv1             = "GuardianSv1"
        GuardianSv1RemoteLock   = "GuardianSv1.RemoteLock"
        GuardianSv1RemoteUnlock = "GuardianSv1.RemoteUnlock"
        GuardianSv1Ping         = "GuardianSv1.Ping"
)

// Cdrs APIs
const (
        CDRsV1                   = "CDRsV1"
        CDRsV1GetCDRsCount       = "CDRsV1.GetCDRsCount"
        CDRsV1RateCDRs           = "CDRsV1.RateCDRs"
        CDRsV1GetCDRs            = "CDRsV1.GetCDRs"
        CDRsV1ProcessCDR         = "CDRsV1.ProcessCDR"
        CDRsV1ProcessExternalCDR = "CDRsV1.ProcessExternalCDR"
        CDRsV1StoreSessionCost   = "CDRsV1.StoreSessionCost"
        CDRsV1ProcessEvent       = "CDRsV1.ProcessEvent"
        CDRsV1Ping               = "CDRsV1.Ping"
        CDRsV2                   = "CDRsV2"
        CDRsV2StoreSessionCost   = "CDRsV2.StoreSessionCost"
        CdrsV2ProcessExternalCdr = "CdrsV2.ProcessExternalCdr"
        CdrsV2ProcessCdr         = "CdrsV2.ProcessCdr"
)

// Scheduler
const (
        SchedulerSv1       = "SchedulerSv1"
        SchedulerSv1Ping   = "SchedulerSv1.Ping"
        SchedulerSv1Reload = "SchedulerSv1.Reload"
)

// cgr_ variables
const (
        CGR_ACCOUNT          = "cgr_account"
        CGR_SUPPLIER         = "cgr_supplier"
        CGR_DESTINATION      = "cgr_destination"
        CGR_SUBJECT          = "cgr_subject"
        CGR_CATEGORY         = "cgr_category"
        CGR_REQTYPE          = "cgr_reqtype"
        CGR_TENANT           = "cgr_tenant"
        CGR_PDD              = "cgr_pdd"
        CGR_DISCONNECT_CAUSE = "cgr_disconnectcause"
        CGR_COMPUTELCR       = "cgr_computelcr"
        CGR_SUPPLIERS        = "cgr_suppliers"
        CGRFlags             = "cgr_flags"
)

// CSV file name
const (
        TimingsCsv            = "Timings.csv"
        DestinationsCsv       = "Destinations.csv"
        RatesCsv              = "Rates.csv"
        DestinationRatesCsv   = "DestinationRates.csv"
        RatingPlansCsv        = "RatingPlans.csv"
        RatingProfilesCsv     = "RatingProfiles.csv"
        SharedGroupsCsv       = "SharedGroups.csv"
        ActionsCsv            = "Actions.csv"
        ActionPlansCsv        = "ActionPlans.csv"
        ActionTriggersCsv     = "ActionTriggers.csv"
        AccountActionsCsv     = "AccountActions.csv"
        ResourcesCsv          = "Resources.csv"
        StatsCsv              = "Stats.csv"
        ThresholdsCsv         = "Thresholds.csv"
        FiltersCsv            = "Filters.csv"
        SuppliersCsv          = "Suppliers.csv"
        AttributesCsv         = "Attributes.csv"
        ChargersCsv           = "Chargers.csv"
        DispatcherProfilesCsv = "DispatcherProfiles.csv"
        DispatcherHostsCsv    = "DispatcherHosts.csv"
)

// Table Name
const (
        TBLTPTimings          = "tp_timings"
        TBLTPDestinations     = "tp_destinations"
        TBLTPRates            = "tp_rates"
        TBLTPDestinationRates = "tp_destination_rates"
        TBLTPRatingPlans      = "tp_rating_plans"
        TBLTPRateProfiles     = "tp_rating_profiles"
        TBLTPSharedGroups     = "tp_shared_groups"
        TBLTPActions          = "tp_actions"
        TBLTPActionPlans      = "tp_action_plans"
        TBLTPActionTriggers   = "tp_action_triggers"
        TBLTPAccountActions   = "tp_account_actions"
        TBLTPResources        = "tp_resources"
        TBLTPStats            = "tp_stats"
        TBLTPThresholds       = "tp_thresholds"
        TBLTPFilters          = "tp_filters"
        SessionCostsTBL       = "session_costs"
        CDRsTBL               = "cdrs"
        TBLTPSuppliers        = "tp_suppliers"
        TBLTPAttributes       = "tp_attributes"
        TBLTPChargers         = "tp_chargers"
        TBLVersions           = "versions"
        OldSMCosts            = "sm_costs"
        TBLTPDispatchers      = "tp_dispatcher_profiles"
        TBLTPDispatcherHosts  = "tp_dispatcher_hosts"
)

// Cache Name
const (
        CacheDestinations            = "*destinations"
        CacheReverseDestinations     = "*reverse_destinations"
        CacheRatingPlans             = "*rating_plans"
        CacheRatingProfiles          = "*rating_profiles"
        CacheActions                 = "*actions"
        CacheActionPlans             = "*action_plans"
        CacheAccountActionPlans      = "*account_action_plans"
        CacheActionTriggers          = "*action_triggers"
        CacheSharedGroups            = "*shared_groups"
        CacheResources               = "*resources"
        CacheResourceProfiles        = "*resource_profiles"
        CacheTimings                 = "*timings"
        CacheEventResources          = "*event_resources"
        CacheStatQueueProfiles       = "*statqueue_profiles"
        CacheStatQueues              = "*statqueues"
        CacheThresholdProfiles       = "*threshold_profiles"
        CacheThresholds              = "*thresholds"
        CacheFilters                 = "*filters"
        CacheSupplierProfiles        = "*supplier_profiles"
        CacheAttributeProfiles       = "*attribute_profiles"
        CacheChargerProfiles         = "*charger_profiles"
        CacheDispatcherProfiles      = "*dispatcher_profiles"
        CacheDispatcherHosts         = "*dispatcher_hosts"
        CacheDispatchers             = "*dispatchers"
        CacheDispatcherRoutes        = "*dispatcher_routes"
        CacheResourceFilterIndexes   = "*resource_filter_indexes"
        CacheStatFilterIndexes       = "*stat_filter_indexes"
        CacheThresholdFilterIndexes  = "*threshold_filter_indexes"
        CacheSupplierFilterIndexes   = "*supplier_filter_indexes"
        CacheAttributeFilterIndexes  = "*attribute_filter_indexes"
        CacheChargerFilterIndexes    = "*charger_filter_indexes"
        CacheDispatcherFilterIndexes = "*dispatcher_filter_indexes"
        CacheReverseFilterIndexes    = "*reverse_filter_indexes"
        CacheDiameterMessages        = "*diameter_messages"
        CacheRPCResponses            = "*rpc_responses"
        CacheClosedSessions          = "*closed_sessions"
        MetaPrecaching               = "*precaching"
        MetaReady                    = "*ready"
        CacheLoadIDs                 = "*load_ids"
        CacheAccounts                = "*accounts"
        CacheRPCConnections          = "*rpc_connections"
        CacheCDRIDs                  = "*cdr_ids"
        CacheRatingProfilesTmp       = "*tmp_rating_profiles"
        CacheReplicationHosts        = "*replication_hosts"
)

// Prefix for indexing
const (
        ResourceFilterIndexes   = "rfi_"
        StatFilterIndexes       = "sfi_"
        ThresholdFilterIndexes  = "tfi_"
        SupplierFilterIndexes   = "spi_"
        AttributeFilterIndexes  = "afi_"
        ChargerFilterIndexes    = "cfi_"
        DispatcherFilterIndexes = "dfi_"
        ActionPlanIndexes       = "api_"
        ReverseFilterIndexes    = "fii_"
)

// Agents
const (
        KamailioAgent   = "KamailioAgent"
        RadiusAgent     = "RadiusAgent"
        DiameterAgent   = "DiameterAgent"
        FreeSWITCHAgent = "FreeSWITCHAgent"
        AsteriskAgent   = "AsteriskAgent"
        HTTPAgent       = "HTTPAgent"
)

// Poster
const (
        SQSPoster    = "SQSPoster"
        S3Poster     = "S3Poster"
        AWSRegion    = "aws_region"
        AWSKey       = "aws_key"
        AWSSecret    = "aws_secret"
        KafkaTopic   = "topic"
        KafkaGroupID = "group_id"
        KafkaMaxWait = "max_wait"
)

// Google_API
const (
        MetaGoogleAPI             = "*gapi"
        GoogleConfigDirName       = ".gapi"
        GoogleCredentialsFileName = "credentials.json"
        GoogleTokenFileName       = "token.json"
)

// StorDB
var (
        PostgressSSLModeDisable    = "disable"
        PostgressSSLModeAllow      = "allow"
        PostgressSSLModePrefer     = "prefer"
        PostgressSSLModeRequire    = "require"
        PostgressSSLModeVerifyCa   = "verify-ca"
        PostgressSSLModeVerifyFull = "verify-full"
)

// GeneralCfg
const (
        NodeIDCfg             = "node_id"
        LoggerCfg             = "logger"
        LogLevelCfg           = "log_level"
        HttpSkipTlsVerifyCfg  = "http_skip_tls_verify"
        RoundingDecimalsCfg   = "rounding_decimals"
        DBDataEncodingCfg     = "dbdata_encoding"
        TpExportPathCfg       = "tpexport_dir"
        PosterAttemptsCfg     = "poster_attempts"
        FailedPostsDirCfg     = "failed_posts_dir"
        FailedPostsTTLCfg     = "failed_posts_ttl"
        DefaultReqTypeCfg     = "default_request_type"
        DefaultCategoryCfg    = "default_category"
        DefaultTenantCfg      = "default_tenant"
        DefaultTimezoneCfg    = "default_timezone"
        DefaultCachingCfg     = "default_caching"
        ConnectAttemptsCfg    = "connect_attempts"
        ReconnectsCfg         = "reconnects"
        ConnectTimeoutCfg     = "connect_timeout"
        ReplyTimeoutCfg       = "reply_timeout"
        LockingTimeoutCfg     = "locking_timeout"
        DigestSeparatorCfg    = "digest_separator"
        DigestEqualCfg        = "digest_equal"
        RSRSepCfg             = "rsr_separator"
        MaxParallelConnsCfg   = "max_parallel_conns"
        ConcurrentRequestsCfg = "concurrent_requests"
        ConcurrentStrategyCfg = "concurrent_strategy"
)

// StorDbCfg
const (
        TypeCfg                = "type"
        MaxOpenConnsCfg        = "max_open_conns"
        MaxIdleConnsCfg        = "max_idle_conns"
        ConnMaxLifetimeCfg     = "conn_max_lifetime"
        StringIndexedFieldsCfg = "string_indexed_fields"
        PrefixIndexedFieldsCfg = "prefix_indexed_fields"
        QueryTimeoutCfg        = "query_timeout"
        SSLModeCfg             = "sslmode"
        ItemsCfg               = "items"
)

// DataDbCfg
const (
        DataDbTypeCfg          = "db_type"
        DataDbHostCfg          = "db_host"
        DataDbPortCfg          = "db_port"
        DataDbNameCfg          = "db_name"
        DataDbUserCfg          = "db_user"
        DataDbPassCfg          = "db_password"
        DataDbSentinelNameCfg  = "redis_sentinel"
        RmtConnsCfg            = "remote_conns"
        RplConnsCfg            = "replication_conns"
        ReplicationFilteredCfg = "replication_filtered"
)

// ItemOpt
const (
        RemoteCfg    = "remote"
        ReplicateCfg = "replicate"
        TTLCfg       = "ttl"
        LimitCfg     = "limit"
        StaticTTLCfg = "static_ttl"
)

// Tls
const (
        ServerCerificateCfg = "server_certificate"
        ServerKeyCfg        = "server_key"
        ServerPolicyCfg     = "server_policy"
        ServerNameCfg       = "server_name"
        ClientCerificateCfg = "client_certificate"
        ClientKeyCfg        = "client_key"
        CaCertificateCfg    = "ca_certificate"
)

// ListenCfg
const (
        RPCJSONListenCfg    = "rpc_json"
        RPCGOBListenCfg     = "rpc_gob"
        HTTPListenCfg       = "http"
        RPCJSONTLSListenCfg = "rpc_json_tls"
        RPCGOBTLSListenCfg  = "rpc_gob_tls"
        HTTPTLSListenCfg    = "http_tls"
)

// HTTPCfg
const (
        HTTPJsonRPCURLCfg        = "json_rpc_url"
        HTTPWSURLCfg             = "ws_url"
        HTTPFreeswitchCDRsURLCfg = "freeswitch_cdrs_url"
        HTTPCDRsURLCfg           = "http_cdrs"
        HTTPUseBasicAuthCfg      = "use_basic_auth"
        HTTPAuthUsersCfg         = "auth_users"
)

// FilterSCfg
const (
        StatSConnsCfg     = "stats_conns"
        ResourceSConnsCfg = "resources_conns"
        ApierSConnsCfg    = "apiers_conns"
)

// RalsCfg
const (
        EnabledCfg                 = "enabled"
        ThresholdSConnsCfg         = "thresholds_conns"
        CacheSConnsCfg             = "caches_conns"
        RpSubjectPrefixMatchingCfg = "rp_subject_prefix_matching"
        RemoveExpiredCfg           = "remove_expired"
        MaxComputedUsageCfg        = "max_computed_usage"
        BalanceRatingSubjectCfg    = "balance_rating_subject"
        MaxIncrementsCfg           = "max_increments"
)

// SchedulerCfg
const (
        CDRsConnsCfg = "cdrs_conns"
        FiltersCfg   = "filters"
)

// CdrsCfg
const (
        ExtraFieldsCfg      = "extra_fields"
        StoreCdrsCfg        = "store_cdrs"
        SMCostRetriesCfg    = "session_cost_retries"
        ChargerSConnsCfg    = "chargers_conns"
        AttributeSConnsCfg  = "attributes_conns"
        OnlineCDRExportsCfg = "online_cdr_exports"
)

// SessionSCfg
const (
        ListenBijsonCfg        = "listen_bijson"
        RALsConnsCfg           = "rals_conns"
        ResSConnsCfg           = "resources_conns"
        ThreshSConnsCfg        = "thresholds_conns"
        SupplSConnsCfg         = "suppliers_conns"
        AttrSConnsCfg          = "attributes_conns"
        ReplicationConnsCfg    = "replication_conns"
        DebitIntervalCfg       = "debit_interval"
        StoreSCostsCfg         = "store_session_costs"
        SessionTTLCfg          = "session_ttl"
        SessionTTLMaxDelayCfg  = "session_ttl_max_delay"
        SessionTTLLastUsedCfg  = "session_ttl_last_used"
        SessionTTLUsageCfg     = "session_ttl_usage"
        SessionTTLLastUsageCfg = "session_ttl_last_usage"
        SessionIndexesCfg      = "session_indexes"
        ClientProtocolCfg      = "client_protocol"
        ChannelSyncIntervalCfg = "channel_sync_interval"
        TerminateAttemptsCfg   = "terminate_attempts"
        AlterableFieldsCfg     = "alterable_fields"
        MinDurLowBalanceCfg    = "min_dur_low_balance"
        DefaultUsageCfg        = "default_usage"
)

// FsAgentCfg
const (
        SessionSConnsCfg       = "sessions_conns"
        SubscribeParkCfg       = "subscribe_park"
        CreateCdrCfg           = "create_cdr"
        LowBalanceAnnFileCfg   = "low_balance_ann_file"
        EmptyBalanceContextCfg = "empty_balance_context"
        EmptyBalanceAnnFileCfg = "empty_balance_ann_file"
        MaxWaitConnectionCfg   = "max_wait_connection"
        EventSocketConnsCfg    = "event_socket_conns"
)

// From Config
const (
        AddressCfg = "address"
        Password   = "password"
        AliasCfg   = "alias"

        // KamAgentCfg
        EvapiConnsCfg = "evapi_conns"
        TimezoneCfg   = "timezone"
        TimezoneCfgC  = "Timezone"

        // AsteriskConnCfg
        UserCf = "user"

        // AsteriskAgentCfg
        CreateCDRCfg     = "create_cdr"
        AsteriskConnsCfg = "asterisk_conns"

        // DiameterAgentCfg
        ListenNetCfg         = "listen_net"
        ListenCfg            = "listen"
        DictionariesPathCfg  = "dictionaries_path"
        OriginHostCfg        = "origin_host"
        OriginRealmCfg       = "origin_realm"
        VendorIdCfg          = "vendor_id"
        ProductNameCfg       = "product_name"
        ConcurrentReqsCfg    = "concurrent_requests"
        SyncedConnReqsCfg    = "synced_conn_requests"
        ASRTemplateCfg       = "asr_template"
        RARTemplateCfg       = "rar_template"
        ForcedDisconnectCfg  = "forced_disconnect"
        TemplatesCfg         = "templates"
        RequestProcessorsCfg = "request_processors"

        // RequestProcessor
        RequestFieldsCfg = "request_fields"
        ReplyFieldsCfg   = "reply_fields"

        // RadiusAgentCfg
        ListenAuthCfg         = "listen_auth"
        ListenAcctCfg         = "listen_acct"
        ClientSecretsCfg      = "client_secrets"
        ClientDictionariesCfg = "client_dictionaries"

        // AttributeSCfg
        IndexedSelectsCfg = "indexed_selects"
        ProcessRunsCfg    = "process_runs"
        NestedFieldsCfg   = "nested_fields"

        // ChargerSCfg
        StoreIntervalCfg = "store_interval"

        // StatSCfg
        StoreUncompressedLimitCfg = "store_uncompressed_limit"

        // Cache
        PartitionsCfg = "partitions"
        PrecacheCfg   = "precache"

        // CdreCfg
        ExportFormatCfg      = "export_format"
        ExportPathCfg        = "export_path"
        AttributeSContextCfg = "attributes_context"
        SynchronousCfg       = "synchronous"
        AttemptsCfg          = "attempts"

        //LoaderSCfg
        IdCfg           = "id"
        DryRunCfg       = "dry_run"
        LockFileNameCfg = "lock_filename"
        TpInDirCfg      = "tp_in_dir"
        TpOutDirCfg     = "tp_out_dir"
        DataCfg         = "data"

        DefaultRatioCfg            = "default_ratio"
        ReadersCfg                 = "readers"
        PoolSize                   = "poolSize"
        Conns                      = "conns"
        FilenameCfg                = "file_name"
        RequestPayloadCfg          = "request_payload"
        ReplyPayloadCfg            = "reply_payload"
        TransportCfg               = "transport"
        StrategyCfg                = "strategy"
        Dynaprepaid_actionplansCfg = "dynaprepaid_actionplans"
)

// FC Template
const (
        TagCfg             = "tag"
        TypeCf             = "type"
        PathCfg            = "path"
        ValueCfg           = "value"
        WidthCfg           = "width"
        StripCfg           = "strip"
        PaddingCfg         = "padding"
        MandatoryCfg       = "mandatory"
        AttributeIDCfg     = "attribute_id"
        NewBranchCfg       = "new_branch"
        BlockerCfg         = "blocker"
        BreakOnSuccessCfg  = "break_on_success"
        Handler_id         = "handler_id"
        LayoutCfg          = "layout"
        CostShiftDigitsCfg = "cost_shift_digits"
        MaskDestIDCfg      = "mask_destinationd_id"
        MaskLenCfg         = "mask_length"
)

// SureTax
const (
        UrlCfg                  = "url"
        ClientNumberCfg         = "client_number"
        ValidationKeyCfg        = "validation_key"
        BusinessUnitCfg         = "business_unit"
        IncludeLocalCostCfg     = "include_local_cost"
        ReturnFileCodeCfg       = "return_file_code"
        ResponseGroupCfg        = "response_group"
        ResponseTypeCfg         = "response_type"
        RegulatoryCodeCfg       = "regulatory_code"
        ClientTrackingCfg       = "client_tracking"
        CustomerNumberCfg       = "customer_number"
        OrigNumberCfg           = "orig_number"
        TermNumberCfg           = "term_number"
        BillToNumberCfg         = "bill_to_number"
        ZipcodeCfg              = "zipcode"
        Plus4Cfg                = "plus4"
        P2PZipcodeCfg           = "p2pzipcode"
        P2PPlus4Cfg             = "p2pplus4"
        UnitsCfg                = "units"
        UnitTypeCfg             = "unit_type"
        TaxIncludedCfg          = "tax_included"
        TaxSitusRuleCfg         = "tax_situs_rule"
        TransTypeCodeCfg        = "trans_type_code"
        SalesTypeCodeCfg        = "sales_type_code"
        TaxExemptionCodeListCfg = "tax_exemption_code_list"
)

// LoaderCgrCfg
const (
        TpIDCfg            = "tpid"
        DataPathCfg        = "data_path"
        DisableReverseCfg  = "disable_reverse"
        FieldSeparatorCfg  = "field_separator"
        CachesConnsCfg     = "caches_conns"
        SchedulerConnsCfg  = "scheduler_conns"
        GapiCredentialsCfg = "gapi_credentials"
        GapiTokenCfg       = "gapi_token"
)

// MigratorCgrCfg
const (
        OutDataDBTypeCfg          = "out_datadb_type"
        OutDataDBHostCfg          = "out_datadb_host"
        OutDataDBPortCfg          = "out_datadb_port"
        OutDataDBNameCfg          = "out_datadb_name"
        OutDataDBUserCfg          = "out_datadb_user"
        OutDataDBPasswordCfg      = "out_datadb_password"
        OutDataDBEncodingCfg      = "out_datadb_encoding"
        OutDataDBRedisSentinelCfg = "out_datadb_redis_sentinel"
        OutStorDBTypeCfg          = "out_stordb_type"
        OutStorDBHostCfg          = "out_stordb_host"
        OutStorDBPortCfg          = "out_stordb_port"
        OutStorDBNameCfg          = "out_stordb_name"
        OutStorDBUserCfg          = "out_stordb_user"
        OutStorDBPasswordCfg      = "out_stordb_password"
        UsersFiltersCfg           = "users_filters"
)

// MailerCfg
const (
        MailerServerCfg   = "server"
        MailerAuthUserCfg = "auth_user"
        MailerAuthPassCfg = "auth_password"
        MailerFromAddrCfg = "from_address"
)

// EventReaderCfg
const (
        IDCfg                       = "id"
        RowLengthCfg                = "row_length"
        FieldSepCfg                 = "field_separator"
        RunDelayCfg                 = "run_delay"
        SourcePathCfg               = "source_path"
        ProcessedPathCfg            = "processed_path"
        XmlRootPathCfg              = "xml_root_path"
        TenantCfg                   = "tenant"
        FlagsCfg                    = "flags"
        FailedCallsPrefixCfg        = "failed_calls_prefix"
        PartialRecordCacheCfg       = "partial_record_cache"
        PartialCacheExpiryActionCfg = "partial_cache_expiry_action"
        FieldsCfg                   = "fields"
        CacheDumpFieldsCfg          = "cache_dump_fields"
)

// CGRConfig
const (
        CdreProfiles     = "cdre"             // from JSON
        LoaderCfg        = "loaders"          // from JSON
        HttpAgentCfg     = "http_agent"       // from JSON
        RpcConns         = "rpc_conns"        // from JSON
        GeneralCfg       = "general"          // from JSON
        DataDbCfg        = "data_db"          // from JSON
        StorDbCfg        = "stor_db"          // from JSON
        TlsCfg           = "tls"              // from JSON
        CacheCfg         = "caches"           // from JSON
        HttpCfg          = "http"             // from JSON
        FilterSCfg       = "filters"          // from JSON
        RalsCfg          = "rals"             // from JSON
        SchedulerCfg     = "schedulers"       // from JSON
        CdrsCfg          = "cdrs"             // from JSON
        SessionSCfg      = "sessions"         // from JSON
        FsAgentCfg       = "freeswitch_agent" // from JSON
        KamAgentCfg      = "kamailio_agent"   // from JSON
        AsteriskAgentCfg = "asterisk_agent"   // from JSON
        DiameterAgentCfg = "diameter_agent"   // from JSON
        RadiusAgentCfg   = "radius_agent"     // from JSON
        DnsAgentCfg      = "dns_agent"        // from JSON
        AttributeSCfg    = "attributes"       // from JSON
        ChargerSCfg      = "chargers"         // from JSON
        ResourceSCfg     = "resources"        // from JSON
        StatsCfg         = "stats"            // from JSON
        ThresholdSCfg    = "thresholds"       // from JSON
        SupplierSCfg     = "suppliers"        // from JSON
        SureTaxCfg       = "suretax"          // from JSON
        DispatcherSCfg   = "dispatchers"      // from JSON
        LoaderCgrCfg     = "loader"           // from JSON
        MigratorCgrCfg   = "migrator"         // from JSON
        MailerCfg        = "mailer"           // from JSON
        AnalyzerSCfg     = "analyzers"        // from JSON
        Apier            = "apiers"           // from JSON
        ErsCfg           = "ers"              // from JSON

)

// Go type limits
const (
        AbsoluteMaxUint     = ^uint(0)
        AbsoluteMinUint     = 0
        AbsoluteMaxInt      = int(AbsoluteMaxUint &gt;&gt; 1)
        AbsoluteMinInt      = -AbsoluteMaxInt - 1
        AbsoluteMaxDuration = time.Duration(AbsoluteMaxInt)
)

// Strip/Padding strategy
var (
        // common
        MetaRight = "*right"
        MetaLeft  = "*left"
        // only for strip
        MetaXRight = "*xright"
        MetaXLeft  = "*xleft"
        // only for padding
        MetaZeroLeft = "*zeroleft"
)

func buildCacheInstRevPrefixes() <span class="cov8" title="1">{
        CachePrefixToInstance = make(map[string]string)
        for k, v := range CacheInstanceToPrefix </span><span class="cov8" title="1">{
                CachePrefixToInstance[v] = k
        }</span>
}

func buildCacheIndexesToPrefix() <span class="cov8" title="1">{
        CacheIndexesToPrefix = make(map[string]string)
        for k, v := range PrefixToIndexCache </span><span class="cov8" title="1">{
                CacheIndexesToPrefix[v] = k
        }</span>
}

func init() <span class="cov8" title="1">{
        buildCacheInstRevPrefixes()
        buildCacheIndexesToPrefix()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "archive/zip"
        "bytes"
        "crypto/rand"
        "crypto/sha1"
        "encoding/gob"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log"
        "math"
        math_rand "math/rand"
        "os"
        "path/filepath"
        "reflect"
        "regexp"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/cgrates/rpcclient"
)

var (
        startCGRateSTime time.Time

        rfc3339Rule                  = regexp.MustCompile(`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.+$`)
        sqlRule                      = regexp.MustCompile(`^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}$`)
        utcFormat                    = regexp.MustCompile(`^\d{4}-\d{2}-\d{2}[T]\d{2}:\d{2}:\d{2}$`)
        gotimeRule                   = regexp.MustCompile(`^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}\.?\d*\s[+,-]\d+\s\w+$`)
        gotimeRule2                  = regexp.MustCompile(`^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}\.?\d*\s[+,-]\d+\s[+,-]\d+$`)
        fsTimestamp                  = regexp.MustCompile(`^\d{16}$`)
        astTimestamp                 = regexp.MustCompile(`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d*[+,-]\d+$`)
        unixTimestampRule            = regexp.MustCompile(`^\d{10}$`)
        unixTimestampMilisecondsRule = regexp.MustCompile(`^\d{13}$`)
        unixTimestampNanosecondsRule = regexp.MustCompile(`^\d{19}$`)
        oneLineTimestampRule         = regexp.MustCompile(`^\d{14}$`)
        oneSpaceTimestampRule        = regexp.MustCompile(`^\d{2}\.\d{2}.\d{4}\s{1}\d{2}:\d{2}:\d{2}$`)
        eamonTimestampRule           = regexp.MustCompile(`^\d{2}/\d{2}/\d{4}\s{1}\d{2}:\d{2}:\d{2}$`)
        broadsoftTimestampRule       = regexp.MustCompile(`^\d{14}\.\d{3}`)
)

func init() <span class="cov8" title="1">{
        startCGRateSTime = time.Now()
        math_rand.Seed(startCGRateSTime.UnixNano())
}</span>

// GetStartTime return the Start time of engine (in UNIX format)
func GetStartTime() string <span class="cov8" title="1">{
        return startCGRateSTime.Format(time.UnixDate)
}</span>

func NewCounter(start, limit int64) *Counter <span class="cov8" title="1">{
        return &amp;Counter{
                value: start,
                limit: limit,
        }
}</span>

type Counter struct {
        value, limit int64
        sync.Mutex
}

func (c *Counter) Next() int64 <span class="cov8" title="1">{
        c.Lock()
        defer c.Unlock()
        c.value += 1
        if c.limit &gt; 0 &amp;&amp; c.value &gt; c.limit </span><span class="cov8" title="1">{
                c.value = 0
        }</span>
        <span class="cov8" title="1">return c.value</span>
}

func (c *Counter) Value() int64 <span class="cov8" title="1">{
        c.Lock()
        defer c.Unlock()
        return c.value
}</span>

// Returns first non empty string out of vals. Useful to extract defaults
func FirstNonEmpty(vals ...string) string <span class="cov8" title="1">{
        for _, val := range vals </span><span class="cov8" title="1">{
                if len(val) != 0 </span><span class="cov8" title="1">{
                        return val
                }</span>
        }
        <span class="cov8" title="1">return EmptyString</span>
}

// Sha1 generate the SHA1 hash from any string
func Sha1(attrs ...string) string <span class="cov8" title="1">{
        hasher := sha1.New()
        for _, attr := range attrs </span><span class="cov8" title="1">{
                hasher.Write([]byte(attr))
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%x", hasher.Sum(nil))</span>
}

// helper function for uuid generation
func GenUUID() string <span class="cov8" title="1">{
        b := make([]byte, 16)
        _, err := io.ReadFull(rand.Reader, b)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">b[6] = (b[6] &amp; 0x0F) | 0x40
        b[8] = (b[8] &amp;^ 0x40) | 0x80
        return fmt.Sprintf("%x-%x-%x-%x-%x", b[:4], b[4:6], b[6:8], b[8:10],
                b[10:])</span>
}

// UUIDSha1Prefix generates a prefix of the sha1 applied to an UUID
// prefix 8 is chosen since the probability of colision starts being minimal after 7 characters (see git commits)
func UUIDSha1Prefix() string <span class="cov8" title="1">{
        return Sha1(GenUUID())[:7]
}</span>

// Round return rounded version of x with prec precision.
//
// Special cases are:
//
//        Round(±0) = ±0
//        Round(±Inf) = ±Inf
//        Round(NaN) = NaN
func Round(x float64, prec int, method string) float64 <span class="cov8" title="1">{
        var rounder float64
        maxPrec := 7 // define a max precison to cut float errors
        if maxPrec &lt; prec </span><span class="cov8" title="1">{
                maxPrec = prec
        }</span>
        <span class="cov8" title="1">pow := math.Pow(10, float64(prec))
        intermed := x * pow
        _, frac := math.Modf(intermed)

        switch method </span>{
        case ROUNDING_UP:<span class="cov8" title="1">
                if frac &gt;= math.Pow10(-maxPrec) </span><span class="cov8" title="1">{ // Max precision we go, rest is float chaos
                        rounder = math.Ceil(intermed)
                }</span> else<span class="cov8" title="1"> {
                        rounder = math.Floor(intermed)
                }</span>
        case ROUNDING_DOWN:<span class="cov8" title="1">
                rounder = math.Floor(intermed)</span>
        case ROUNDING_MIDDLE:<span class="cov8" title="1">
                if frac &gt;= 0.5 </span><span class="cov8" title="1">{
                        rounder = math.Ceil(intermed)
                }</span> else<span class="cov8" title="1"> {
                        rounder = math.Floor(intermed)
                }</span>
        default:<span class="cov8" title="1">
                rounder = intermed</span>
        }

        <span class="cov8" title="1">return rounder / pow</span>
}

func getAddDuration(tmStr string) (addDur time.Duration, err error) <span class="cov8" title="1">{
        eDurIdx := strings.Index(tmStr, "+")
        if eDurIdx == -1 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return time.ParseDuration(tmStr[eDurIdx+1:])</span>
}

// ParseTimeDetectLayout returns the time from string
func ParseTimeDetectLayout(tmStr string, timezone string) (time.Time, error) <span class="cov8" title="1">{
        tmStr = strings.TrimSpace(tmStr)
        var nilTime time.Time
        if len(tmStr) == 0 || tmStr == UNLIMITED </span><span class="cov8" title="1">{
                return nilTime, nil
        }</span>
        <span class="cov8" title="1">loc, err := time.LoadLocation(timezone)
        if err != nil </span><span class="cov8" title="1">{
                return nilTime, err
        }</span>
        <span class="cov8" title="1">switch </span>{
        case tmStr == UNLIMITED || tmStr == "":<span class="cov0" title="0"></span>
        // leave it at zero
        case tmStr == "*daily":<span class="cov8" title="1">
                return time.Now().AddDate(0, 0, 1), nil</span> // add one day
        case tmStr == "*monthly":<span class="cov8" title="1">
                return time.Now().AddDate(0, 1, 0), nil</span> // add one month
        case tmStr == "*yearly":<span class="cov8" title="1">
                return time.Now().AddDate(1, 0, 0), nil</span> // add one year
        case strings.HasPrefix(tmStr, "*month_end"):<span class="cov8" title="1">
                expDate := GetEndOfMonth(time.Now())
                extraDur, err := getAddDuration(tmStr)
                if err != nil </span><span class="cov8" title="1">{
                        return nilTime, err
                }</span>
                <span class="cov8" title="1">expDate = expDate.Add(extraDur)
                return expDate, nil</span>
        case strings.HasPrefix(tmStr, "*mo"):<span class="cov8" title="1"> // add one month and extra duration
                extraDur, err := getAddDuration(tmStr)
                if err != nil </span><span class="cov8" title="1">{
                        return nilTime, err
                }</span>
                <span class="cov8" title="1">return time.Now().AddDate(0, 1, 0).Add(extraDur), nil</span>
        case astTimestamp.MatchString(tmStr):<span class="cov8" title="1">
                return time.Parse("2006-01-02T15:04:05.999999999-0700", tmStr)</span>
        case rfc3339Rule.MatchString(tmStr):<span class="cov8" title="1">
                return time.Parse(time.RFC3339, tmStr)</span>
        case gotimeRule.MatchString(tmStr):<span class="cov8" title="1">
                return time.Parse("2006-01-02 15:04:05.999999999 -0700 MST", tmStr)</span>
        case gotimeRule2.MatchString(tmStr):<span class="cov8" title="1">
                return time.Parse("2006-01-02 15:04:05.999999999 -0700 -0700", tmStr)</span>
        case sqlRule.MatchString(tmStr):<span class="cov8" title="1">
                return time.ParseInLocation("2006-01-02 15:04:05", tmStr, loc)</span>
        case fsTimestamp.MatchString(tmStr):<span class="cov8" title="1">
                if tmstmp, err := strconv.ParseInt(tmStr+"000", 10, 64); err != nil </span><span class="cov8" title="1">{
                        return nilTime, err
                }</span> else<span class="cov8" title="1"> {
                        return time.Unix(0, tmstmp).In(loc), nil
                }</span>
        case unixTimestampRule.MatchString(tmStr):<span class="cov8" title="1">
                if tmstmp, err := strconv.ParseInt(tmStr, 10, 64); err != nil </span><span class="cov0" title="0">{
                        return nilTime, err
                }</span> else<span class="cov8" title="1"> {
                        return time.Unix(tmstmp, 0).In(loc), nil
                }</span>
        case unixTimestampMilisecondsRule.MatchString(tmStr):<span class="cov8" title="1">
                if tmstmp, err := strconv.ParseInt(tmStr, 10, 64); err != nil </span><span class="cov0" title="0">{
                        return nilTime, err
                }</span> else<span class="cov8" title="1"> {
                        return time.Unix(0, tmstmp*int64(time.Millisecond)).In(loc), nil
                }</span>
        case unixTimestampNanosecondsRule.MatchString(tmStr):<span class="cov8" title="1">
                if tmstmp, err := strconv.ParseInt(tmStr, 10, 64); err != nil </span><span class="cov8" title="1">{
                        return nilTime, err
                }</span> else<span class="cov8" title="1"> {
                        return time.Unix(0, tmstmp).In(loc), nil
                }</span>
        case tmStr == "0" || len(tmStr) == 0:<span class="cov8" title="1"> // Time probably missing from request
                return nilTime, nil</span>
        case oneLineTimestampRule.MatchString(tmStr):<span class="cov8" title="1">
                return time.ParseInLocation("20060102150405", tmStr, loc)</span>
        case oneSpaceTimestampRule.MatchString(tmStr):<span class="cov8" title="1">
                return time.ParseInLocation("02.01.2006  15:04:05", tmStr, loc)</span>
        case eamonTimestampRule.MatchString(tmStr):<span class="cov8" title="1">
                return time.ParseInLocation("02/01/2006 15:04:05", tmStr, loc)</span>
        case broadsoftTimestampRule.MatchString(tmStr):<span class="cov8" title="1">
                return time.ParseInLocation("20060102150405.999", tmStr, loc)</span>
        case tmStr == "*now":<span class="cov8" title="1">
                return time.Now(), nil</span>
        case strings.HasPrefix(tmStr, "+"):<span class="cov8" title="1">
                tmStr = strings.TrimPrefix(tmStr, "+")
                if tmStrTmp, err := time.ParseDuration(tmStr); err != nil </span><span class="cov8" title="1">{
                        return nilTime, err
                }</span> else<span class="cov8" title="1"> {
                        return time.Now().Add(tmStrTmp), nil
                }</span>
        case utcFormat.MatchString(tmStr):<span class="cov8" title="1">
                return time.ParseInLocation("2006-01-02T15:04:05", tmStr, loc)</span>

        }
        <span class="cov8" title="1">return nilTime, errors.New("Unsupported time format")</span>
}

// RoundDuration returns a number equal or larger than the amount that exactly
// is divisible to whole
func RoundDuration(whole, amount time.Duration) time.Duration <span class="cov8" title="1">{
        a, w := float64(amount), float64(whole)
        if math.Mod(a, w) == 0 </span><span class="cov8" title="1">{
                return amount
        }</span>
        <span class="cov8" title="1">return time.Duration((w - math.Mod(a, w) + a))</span>
}

func SplitPrefix(prefix string, minLength int) []string <span class="cov8" title="1">{
        length := int(math.Max(float64(len(prefix)-(minLength-1)), 0))
        subs := make([]string, length)
        max := len(prefix)
        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                subs[i] = prefix[:max-i]
        }</span>
        <span class="cov8" title="1">return subs</span>
}

func CopyHour(src, dest time.Time) time.Time <span class="cov8" title="1">{
        if src.Hour() == 0 &amp;&amp; src.Minute() == 0 &amp;&amp; src.Second() == 0 </span><span class="cov8" title="1">{
                return src
        }</span>
        <span class="cov8" title="1">return time.Date(dest.Year(), dest.Month(), dest.Day(), src.Hour(), src.Minute(), src.Second(), src.Nanosecond(), src.Location())</span>
}

// Parses duration, considers s as time unit if not provided, seconds as float to specify subunits
func ParseDurationWithSecs(durStr string) (d time.Duration, err error) <span class="cov8" title="1">{
        if durStr == "" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if _, err = strconv.ParseFloat(durStr, 64); err == nil </span><span class="cov8" title="1">{ // Seconds format considered
                durStr += "s"
        }</span>
        <span class="cov8" title="1">return time.ParseDuration(durStr)</span>
}

// Parses duration, considers s as time unit if not provided, seconds as float to specify subunits
func ParseDurationWithNanosecs(durStr string) (d time.Duration, err error) <span class="cov8" title="1">{
        if durStr == "" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if durStr == UNLIMITED </span><span class="cov8" title="1">{
                durStr = "-1"
        }</span>
        <span class="cov8" title="1">if _, err = strconv.ParseFloat(durStr, 64); err == nil </span><span class="cov8" title="1">{ // Seconds format considered
                durStr += "ns"
        }</span>
        <span class="cov8" title="1">return time.ParseDuration(durStr)</span>
}

// returns the minimum duration between the two
func MinDuration(d1, d2 time.Duration) time.Duration <span class="cov8" title="1">{
        if d1 &lt; d2 </span><span class="cov8" title="1">{
                return d1
        }</span>
        <span class="cov8" title="1">return d2</span>
}

// ParseZeroRatingSubject will parse the subject in the balance
// returns duration if able to extract it from subject
// returns error if not able to parse duration (ie: if ratingSubject is standard one)
func ParseZeroRatingSubject(tor, rateSubj string, defaultRateSubj map[string]string) (time.Duration, error) <span class="cov8" title="1">{
        rateSubj = strings.TrimSpace(rateSubj)
        if rateSubj == "" || rateSubj == ANY </span><span class="cov8" title="1">{
                var hasToR bool
                if rateSubj, hasToR = defaultRateSubj[tor]; !hasToR </span><span class="cov8" title="1">{
                        rateSubj = defaultRateSubj[META_ANY]
                }</span>
        }
        <span class="cov8" title="1">if !strings.HasPrefix(rateSubj, ZERO_RATING_SUBJECT_PREFIX) </span><span class="cov8" title="1">{
                return 0, errors.New("malformed rating subject: " + rateSubj)
        }</span>
        <span class="cov8" title="1">durStr := rateSubj[len(ZERO_RATING_SUBJECT_PREFIX):]
        if _, err := strconv.ParseFloat(durStr, 64); err == nil </span><span class="cov8" title="1">{ // No time unit, postpend
                durStr += "ns"
        }</span>
        <span class="cov8" title="1">return time.ParseDuration(durStr)</span>
}

func ConcatenatedKey(keyVals ...string) string <span class="cov8" title="1">{
        return strings.Join(keyVals, CONCATENATED_KEY_SEP)
}</span>

func SplitConcatenatedKey(key string) []string <span class="cov8" title="1">{
        return strings.Split(key, CONCATENATED_KEY_SEP)
}</span>

func InfieldJoin(vals ...string) string <span class="cov8" title="1">{
        return strings.Join(vals, INFIELD_SEP)
}</span>

func InfieldSplit(val string) []string <span class="cov8" title="1">{
        return strings.Split(val, INFIELD_SEP)
}</span>

func Unzip(src, dest string) error <span class="cov0" title="0">{
        r, err := zip.OpenReader(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer r.Close()

        for _, f := range r.File </span><span class="cov0" title="0">{
                rc, err := f.Open()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer rc.Close()

                path := filepath.Join(dest, f.Name)
                if f.FileInfo().IsDir() </span><span class="cov0" title="0">{
                        os.MkdirAll(path, f.Mode())
                }</span> else<span class="cov0" title="0"> {
                        f, err := os.OpenFile(
                                path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer f.Close()

                        _, err = io.Copy(f, rc)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Fib returns successive Fibonacci numbers.
func Fib() func() int <span class="cov8" title="1">{
        a, b := 0, 1
        return func() int </span><span class="cov8" title="1">{
                if b &gt; 0 </span><span class="cov8" title="1">{ // only increment Fibonacci numbers while b doesn't overflow
                        a, b = b, a+b
                }</span>
                <span class="cov8" title="1">return a</span>
        }
}

// FibDuration returns successive Fibonacci numbers as time.Duration with the
// unit specified by durationUnit or maxDuration if it is exceeded
func FibDuration(durationUnit, maxDuration time.Duration) func() time.Duration <span class="cov0" title="0">{
        fib := Fib()
        return func() time.Duration </span><span class="cov0" title="0">{
                fibNrAsDuration := time.Duration(fib())
                if fibNrAsDuration &gt; (AbsoluteMaxDuration / durationUnit) </span><span class="cov0" title="0">{ // check if the current fibonacci nr. in the sequence would exceed the absolute maximum duration if multiplied by the duration unit value
                        fibNrAsDuration = AbsoluteMaxDuration
                }</span> else<span class="cov0" title="0"> {
                        fibNrAsDuration *= durationUnit
                }</span>
                <span class="cov0" title="0">if maxDuration &gt; 0 &amp;&amp; maxDuration &lt; fibNrAsDuration </span><span class="cov0" title="0">{
                        return maxDuration
                }</span>
                <span class="cov0" title="0">return fibNrAsDuration</span>
        }
}

// Utilities to provide pointers where we need to define ad-hoc
func StringPointer(str string) *string <span class="cov8" title="1">{
        if str == ZERO </span><span class="cov8" title="1">{
                str = EmptyString
                return &amp;str
        }</span>
        <span class="cov8" title="1">return &amp;str</span>
}

func IntPointer(i int) *int <span class="cov8" title="1">{
        return &amp;i
}</span>

func Int64Pointer(i int64) *int64 <span class="cov8" title="1">{
        return &amp;i
}</span>

func Float64Pointer(f float64) *float64 <span class="cov8" title="1">{
        return &amp;f
}</span>

func BoolPointer(b bool) *bool <span class="cov8" title="1">{
        return &amp;b
}</span>

func StringMapPointer(sm StringMap) *StringMap <span class="cov8" title="1">{
        return &amp;sm
}</span>

func MapStringStringPointer(mp map[string]string) *map[string]string <span class="cov8" title="1">{
        return &amp;mp
}</span>

func TimePointer(t time.Time) *time.Time <span class="cov8" title="1">{
        return &amp;t
}</span>

func DurationPointer(d time.Duration) *time.Duration <span class="cov8" title="1">{
        return &amp;d
}</span>

func ToIJSON(v any) string <span class="cov8" title="1">{
        b, _ := json.MarshalIndent(v, "", " ")
        return string(b)
}</span>

func ToJSON(v any) string <span class="cov8" title="1">{
        b, _ := json.Marshal(v)
        return string(b)
}</span>

func LogFull(v any) <span class="cov0" title="0">{
        log.Print(ToIJSON(v))
}</span>

// Simple object cloner, b should be a pointer towards a value into which we want to decode
func Clone(a, b any) error <span class="cov8" title="1">{
        buff := new(bytes.Buffer)
        enc := gob.NewEncoder(buff)
        dec := gob.NewDecoder(buff)
        if err := enc.Encode(a); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := dec.Decode(b); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Used as generic function logic for various fields

// Attributes
//
//        source - the base source
//        width - the field width
//        strip - if present it will specify the strip strategy, when missing strip will not be allowed
//        padding - if present it will specify the padding strategy to use, left, right, zeroleft, zeroright
func FmtFieldWidth(fieldID, source string, width int, strip, padding string, mandatory bool) (string, error) <span class="cov8" title="1">{
        if mandatory &amp;&amp; len(source) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("Empty source value for fieldID: &lt;%s&gt;", fieldID)
        }</span>
        <span class="cov8" title="1">if width == 0 </span><span class="cov8" title="1">{ // Disable width processing if not defined
                return source, nil
        }</span>
        <span class="cov8" title="1">if len(source) == width </span><span class="cov8" title="1">{ // the source is exactly the maximum length
                return source, nil
        }</span>
        <span class="cov8" title="1">if len(source) &gt; width </span><span class="cov8" title="1">{ //the source is bigger than allowed
                if len(strip) == 0 </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("Source %s is bigger than the width %d, no strip defied, fieldID: &lt;%s&gt;", source, width, fieldID)
                }</span>
                <span class="cov8" title="1">if strip == MetaRight </span><span class="cov8" title="1">{
                        return source[:width], nil
                }</span> else<span class="cov8" title="1"> if strip == MetaXRight </span><span class="cov8" title="1">{
                        return source[:width-1] + "x", nil // Suffix with x to mark prefix
                }</span> else<span class="cov8" title="1"> if strip == MetaLeft </span><span class="cov8" title="1">{
                        diffIndx := len(source) - width
                        return source[diffIndx:], nil
                }</span> else<span class="cov8" title="1"> if strip == MetaXLeft </span><span class="cov8" title="1">{ // Prefix one x to mark stripping
                        diffIndx := len(source) - width
                        return "x" + source[diffIndx+1:], nil
                }</span>
        } else<span class="cov8" title="1"> { //the source is smaller as the maximum allowed
                if len(padding) == 0 </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("Source %s is smaller than the width %d, no padding defined, fieldID: &lt;%s&gt;", source, width, fieldID)
                }</span>
                <span class="cov8" title="1">var paddingFmt string
                switch padding </span>{
                case MetaRight:<span class="cov8" title="1">
                        paddingFmt = fmt.Sprintf("%%-%ds", width)</span>
                case MetaLeft:<span class="cov8" title="1">
                        paddingFmt = fmt.Sprintf("%%%ds", width)</span>
                case MetaZeroLeft:<span class="cov8" title="1">
                        paddingFmt = fmt.Sprintf("%%0%ds", width)</span>
                }
                <span class="cov8" title="1">if len(paddingFmt) != 0 </span><span class="cov8" title="1">{
                        return fmt.Sprintf(paddingFmt, source), nil
                }</span>
        }
        <span class="cov8" title="1">return source, nil</span>
}

// Returns the string representation of iface or error if not convertible
func CastIfToString(iface any) (strVal string, casts bool) <span class="cov8" title="1">{
        switch rawVal := iface.(type) </span>{
        case string:<span class="cov8" title="1">
                strVal = rawVal
                casts = true</span>
        case int:<span class="cov8" title="1">
                strVal = strconv.Itoa(rawVal)
                casts = true</span>
        case int64:<span class="cov8" title="1">
                strVal = strconv.FormatInt(rawVal, 10)
                casts = true</span>
        case float64:<span class="cov8" title="1">
                strVal = strconv.FormatFloat(rawVal, 'f', -1, 64)
                casts = true</span>
        case bool:<span class="cov8" title="1">
                strVal = strconv.FormatBool(rawVal)
                casts = true</span>
        case []uint8:<span class="cov8" title="1">
                var byteVal []byte
                if byteVal, casts = iface.([]byte); casts </span><span class="cov8" title="1">{
                        strVal = string(byteVal)
                }</span>
        default:<span class="cov8" title="1"> // Maybe we are lucky and the value converts to string
                strVal, casts = iface.(string)</span>
        }
        <span class="cov8" title="1">return strVal, casts</span>
}

func GetEndOfMonth(ref time.Time) time.Time <span class="cov8" title="1">{
        if ref.IsZero() </span><span class="cov8" title="1">{
                return time.Now()
        }</span>
        <span class="cov8" title="1">year, month, _ := ref.Date()
        if month == time.December </span><span class="cov8" title="1">{
                year++
                month = time.January
        }</span> else<span class="cov8" title="1"> {
                month++
        }</span>
        <span class="cov8" title="1">eom := time.Date(year, month, 1, 0, 0, 0, 0, ref.Location())
        return eom.Add(-time.Second)</span>
}

// formats number in K,M,G, etc.
func SizeFmt(num float64, suffix string) string <span class="cov8" title="1">{
        if suffix == EmptyString </span><span class="cov8" title="1">{
                suffix = "B"
        }</span>
        <span class="cov8" title="1">for _, unit := range []string{"", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei", "Zi"} </span><span class="cov8" title="1">{
                if math.Abs(num) &lt; 1024.0 </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%3.1f%s%s", num, unit, suffix)
                }</span>
                <span class="cov8" title="1">num /= 1024.0</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("%.1f%s%s", num, "Yi", suffix)</span>
}

func TimeIs0h(t time.Time) bool <span class="cov8" title="1">{
        return t.Hour() == 0 &amp;&amp; t.Minute() == 0 &amp;&amp; t.Second() == 0
}</span>

func ParseHierarchyPath(path string, sep string) HierarchyPath <span class="cov8" title="1">{
        if sep == EmptyString </span><span class="cov8" title="1">{
                for _, sep = range []string{"/", NestingSep} </span><span class="cov8" title="1">{
                        if idx := strings.Index(path, sep); idx != -1 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">path = strings.Trim(path, sep) // Need to strip if prefix of suffiy (eg: paths with /) so we can properly split
        return HierarchyPath(strings.Split(path, sep))</span>
}

// HierarchyPath is used in various places to represent various path hierarchies (eg: in Diameter groups, XML trees)
type HierarchyPath []string

func (h HierarchyPath) AsString(sep string, prefix bool) string <span class="cov8" title="1">{
        if len(h) == 0 </span><span class="cov8" title="1">{
                return EmptyString
        }</span>
        <span class="cov8" title="1">retStr := EmptyString
        for idx, itm := range h </span><span class="cov8" title="1">{
                if idx == 0 </span><span class="cov8" title="1">{
                        if prefix </span><span class="cov8" title="1">{
                                retStr += sep
                        }</span>
                } else<span class="cov8" title="1"> {
                        retStr += sep
                }</span>
                <span class="cov8" title="1">retStr += itm</span>
        }
        <span class="cov8" title="1">return retStr</span>
}

// Mask a number of characters in the suffix of the destination
func MaskSuffix(dest string, maskLen int) string <span class="cov8" title="1">{
        destLen := len(dest)
        if maskLen &lt; 0 </span><span class="cov8" title="1">{
                return dest
        }</span> else<span class="cov8" title="1"> if maskLen &gt; destLen </span><span class="cov8" title="1">{
                maskLen = destLen
        }</span>
        <span class="cov8" title="1">dest = dest[:destLen-maskLen]
        for i := 0; i &lt; maskLen; i++ </span><span class="cov8" title="1">{
                dest += MASK_CHAR
        }</span>
        <span class="cov8" title="1">return dest</span>
}

// Sortable Int64Slice
type Int64Slice []int64

func (slc Int64Slice) Len() int <span class="cov8" title="1">{
        return len(slc)
}</span>
func (slc Int64Slice) Swap(i, j int) <span class="cov8" title="1">{
        slc[i], slc[j] = slc[j], slc[i]
}</span>
func (slc Int64Slice) Less(i, j int) bool <span class="cov8" title="1">{
        return slc[i] &lt; slc[j]
}</span>

// CapitalizeErrorMessage returns the capitalized version of an error, useful in APIs
func CapitalizedMessage(errMessage string) (capStr string) <span class="cov8" title="1">{
        capStr = strings.ToUpper(errMessage)
        capStr = strings.Replace(capStr, " ", "_", -1)
        return
}</span>

func GetCGRVersion() (vers string, err error) <span class="cov8" title="1">{
        vers = fmt.Sprintf("%s@%s", CGRateS, VERSION)
        if GitLastLog == "" </span><span class="cov8" title="1">{
                return vers, nil
        }</span>
        <span class="cov8" title="1">rdr := bytes.NewBufferString(GitLastLog)
        var commitHash string
        var commitDate time.Time
        for i := 0; i &lt; 5; i++ </span><span class="cov8" title="1">{ // read a maximum of 5 lines
                var ln string
                ln, err = rdr.ReadString('\n')
                if err != nil </span><span class="cov8" title="1">{
                        return vers, fmt.Errorf("Building version - error: &lt;%s&gt; reading line from file", err.Error()) //or errorsNew()
                }</span>
                <span class="cov8" title="1">if strings.HasPrefix(ln, "commit ") </span><span class="cov8" title="1">{
                        commitSplt := strings.Split(ln, " ")
                        if len(commitSplt) != 2 </span><span class="cov8" title="1">{
                                return vers, fmt.Errorf("Building version - cannot extract commit hash")
                        }</span>
                        <span class="cov8" title="1">commitHash = commitSplt[1]
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(ln, "Date:") </span><span class="cov8" title="1">{
                        dateSplt := strings.Split(ln, ": ")
                        if len(dateSplt) != 2 </span><span class="cov8" title="1">{
                                return vers, fmt.Errorf("Building version - cannot split commit date")
                        }</span>
                        <span class="cov8" title="1">commitDate, err = time.Parse("Mon Jan 2 15:04:05 2006 -0700", strings.TrimSpace(dateSplt[1]))
                        if err != nil </span><span class="cov8" title="1">{
                                return vers, fmt.Errorf("Building version - error: &lt;%s&gt; compiling commit date", err.Error())
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">if commitHash == "" || commitDate.IsZero() </span><span class="cov8" title="1">{
                return vers, fmt.Errorf("Cannot find commitHash or commitDate information")
        }</span>
        //CGRateS@v0.10.1~dev-20200110075344-7572e7b11e00
        <span class="cov8" title="1">return fmt.Sprintf("%s@%s-%s-%s", CGRateS, VERSION, commitDate.UTC().Format("20060102150405"), commitHash[:12]), nil</span>
}

func NewTenantID(tntID string) *TenantID <span class="cov8" title="1">{
        if !strings.Contains(tntID, CONCATENATED_KEY_SEP) </span><span class="cov8" title="1">{ // no :, ID without Tenant
                return &amp;TenantID{ID: tntID}
        }</span>
        <span class="cov8" title="1">tIDSplt := strings.Split(tntID, CONCATENATED_KEY_SEP)
        return &amp;TenantID{Tenant: tIDSplt[0], ID: ConcatenatedKey(tIDSplt[1:]...)}</span>
}

type TenantArg struct {
        Tenant string
}

type TenantArgWithPaginator struct {
        TenantArg
        Paginator
}

type TenantWithArgDispatcher struct {
        *TenantArg
        *ArgDispatcher
}

type TenantID struct {
        Tenant string
        ID     string
}

type TenantIDWithArgDispatcher struct {
        *TenantID
        *ArgDispatcher
}

func (tID *TenantID) TenantID() string <span class="cov8" title="1">{
        return ConcatenatedKey(tID.Tenant, tID.ID)
}</span>

type TenantIDWithCache struct {
        Tenant string
        ID     string
        Cache  *string
}

func (tID *TenantIDWithCache) TenantID() string <span class="cov8" title="1">{
        return ConcatenatedKey(tID.Tenant, tID.ID)
}</span>

// RPCCall is a generic method calling RPC on a struct instance
// serviceMethod is assumed to be in the form InstanceV1.Method
// where V1Method will become RPC method called on instance
func RPCCall(inst any, serviceMethod string, args any, reply any) error <span class="cov8" title="1">{
        methodSplit := strings.Split(serviceMethod, ".")
        if len(methodSplit) != 2 </span><span class="cov8" title="1">{
                return rpcclient.ErrUnsupporteServiceMethod
        }</span>
        <span class="cov0" title="0">method := reflect.ValueOf(inst).MethodByName(
                strings.ToUpper(methodSplit[0][len(methodSplit[0])-2:]) + methodSplit[1])
        if !method.IsValid() </span><span class="cov0" title="0">{
                return rpcclient.ErrUnsupporteServiceMethod
        }</span>
        <span class="cov0" title="0">params := []reflect.Value{reflect.ValueOf(args), reflect.ValueOf(reply)}
        ret := method.Call(params)
        if len(ret) != 1 </span><span class="cov0" title="0">{
                return ErrServerError
        }</span>
        <span class="cov0" title="0">if ret[0].Interface() == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err, ok := ret[0].Interface().(error)
        if !ok </span><span class="cov0" title="0">{
                return ErrServerError
        }</span>
        <span class="cov0" title="0">return err</span>
}

// ApierRPCCall implements generic RPCCall for APIer instances
func APIerRPCCall(inst any, serviceMethod string, args any, reply any) error <span class="cov0" title="0">{
        methodSplit := strings.Split(serviceMethod, ".")
        if len(methodSplit) != 2 </span><span class="cov0" title="0">{
                return rpcclient.ErrUnsupporteServiceMethod
        }</span>
        <span class="cov0" title="0">method := reflect.ValueOf(inst).MethodByName(methodSplit[1])
        if !method.IsValid() </span><span class="cov0" title="0">{
                return rpcclient.ErrUnsupporteServiceMethod
        }</span>
        <span class="cov0" title="0">params := []reflect.Value{reflect.ValueOf(args), reflect.ValueOf(reply)}
        ret := method.Call(params)
        if len(ret) != 1 </span><span class="cov0" title="0">{
                return ErrServerError
        }</span>
        <span class="cov0" title="0">if ret[0].Interface() == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">err, ok := ret[0].Interface().(error)
        if !ok </span><span class="cov0" title="0">{
                return ErrServerError
        }</span>
        <span class="cov0" title="0">return err</span>
}

// CachedRPCResponse is used to cache a RPC response
type CachedRPCResponse struct {
        Result any
        Error  error
}

func ReverseString(s string) string <span class="cov8" title="1">{
        r := []rune(s)
        for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                r[i], r[j] = r[j], r[i]
        }</span>
        <span class="cov8" title="1">return string(r)</span>
}

func GetUrlRawArguments(dialURL string) (out map[string]string) <span class="cov8" title="1">{
        out = make(map[string]string)
        idx := strings.IndexRune(dialURL, '?')
        if idx == -1 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">strParams := dialURL[idx+1:]
        if len(strParams) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">vecParams := strings.Split(strParams, "&amp;")
        for _, paramPair := range vecParams </span><span class="cov8" title="1">{
                idx := strings.IndexRune(paramPair, '=')
                if idx == -1 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">out[paramPair[:idx]] = paramPair[idx+1:]</span>
        }
        <span class="cov8" title="1">return</span>
}

// WarnExecTime is used when we need to meassure the execution of specific functions
// and warn when the total duration is higher than expected
// should be usually called with defer, ie: defer WarnExecTime(time.Now(), "MyTestFunc", time.Duration(2*time.Second))
func WarnExecTime(startTime time.Time, logID string, maxDur time.Duration) <span class="cov8" title="1">{
        totalDur := time.Since(startTime)
        if totalDur &gt; maxDur </span><span class="cov8" title="1">{
                Logger.Warning(fmt.Sprintf("&lt;%s&gt; execution took: &lt;%s&gt;", logID, totalDur))
        }</span>
}

// endchan := LongExecTimeDetector("mesaj", 5*time.Second)
// defer func() { close(endchan) }()
func LongExecTimeDetector(logID string, maxDur time.Duration) (endchan chan struct{}) <span class="cov0" title="0">{
        endchan = make(chan struct{}, 1)
        go func() </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-time.After(maxDur):<span class="cov0" title="0">
                        Logger.Warning(fmt.Sprintf("&lt;%s&gt; execution more than: &lt;%s&gt;", logID, maxDur))</span>
                case &lt;-endchan:<span class="cov0" title="0"></span>
                }
        }()
        <span class="cov0" title="0">return</span>
}

type GetFilterIndexesArg struct {
        CacheID      string
        ItemIDPrefix string
        FilterType   string
        FldNameVal   map[string]string
}

type MatchFilterIndexArg struct {
        CacheID      string
        ItemIDPrefix string
        FilterType   string
        FieldName    string
        FieldVal     string
}

type SetFilterIndexesArg struct {
        CacheID      string
        ItemIDPrefix string
        Indexes      map[string]StringMap
}

func CastRPCErr(err error) error <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                if _, has := ErrMap[err.Error()]; has </span><span class="cov8" title="1">{
                        return ErrMap[err.Error()]
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

// RandomInteger returns a random integer between min and max values
func RandomInteger(min, max int) int <span class="cov8" title="1">{
        return math_rand.Intn(max-min) + min
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "encoding/hex"
        "fmt"
        "net"
        "strconv"
        "strings"
        "time"

        "github.com/nyaruka/phonenumbers"
)

// DataConverters groups together multiple converters,
// executing optimized conversions
type DataConverters []DataConverter

// ConvertString converts from and to string
func (dcs DataConverters) ConvertString(in string) (out string, err error) <span class="cov8" title="1">{
        outIface := any(in)
        for _, cnv := range dcs </span><span class="cov8" title="1">{
                if outIface, err = cnv.Convert(outIface); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return IfaceAsString(outIface), nil</span>
}

// DataConverter represents functions which should convert input into output
type DataConverter interface {
        Convert(any) (any, error)
}

// NewDataConverter is a factory of converters
func NewDataConverter(params string) (conv DataConverter, err error) <span class="cov8" title="1">{
        switch </span>{
        case params == MetaDurationSeconds:<span class="cov8" title="1">
                return NewDurationSecondsConverter("")</span>
        case params == MetaDurationNanoseconds:<span class="cov8" title="1">
                return NewDurationNanosecondsConverter("")</span>
        case strings.HasPrefix(params, MetaRound):<span class="cov8" title="1">
                if len(params) == len(MetaRound) </span><span class="cov8" title="1">{ // no extra params, defaults implied
                        return NewRoundConverter("")
                }</span>
                <span class="cov8" title="1">return NewRoundConverter(params[len(MetaRound)+1:])</span>
        case strings.HasPrefix(params, MetaMultiply):<span class="cov8" title="1">
                if len(params) == len(MetaMultiply) </span><span class="cov8" title="1">{ // no extra params, defaults implied
                        return NewMultiplyConverter("")
                }</span>
                <span class="cov8" title="1">return NewMultiplyConverter(params[len(MetaMultiply)+1:])</span>
        case strings.HasPrefix(params, MetaDivide):<span class="cov8" title="1">
                if len(params) == len(MetaDivide) </span><span class="cov8" title="1">{ // no extra params, defaults implied
                        return NewDivideConverter("")
                }</span>
                <span class="cov8" title="1">return NewDivideConverter(params[len(MetaDivide)+1:])</span>
        case params == MetaDuration:<span class="cov8" title="1">
                return NewDurationConverter("")</span>
        case params == MetaIP2Hex:<span class="cov0" title="0">
                return new(IP2HexConverter), nil</span>
        case params == MetaString2Hex:<span class="cov8" title="1">
                return new(String2HexConverter), nil</span>
        case strings.HasPrefix(params, MetaLibPhoneNumber):<span class="cov8" title="1">
                if len(params) == len(MetaLibPhoneNumber) </span><span class="cov8" title="1">{
                        return NewPhoneNumberConverter("")
                }</span>
                <span class="cov8" title="1">return NewPhoneNumberConverter(params[len(MetaLibPhoneNumber)+1:])</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported converter definition: &lt;%s&gt;", params)</span>
        }
}

func NewDataConverterMustCompile(params string) (conv DataConverter) <span class="cov8" title="1">{
        var err error
        if conv, err = NewDataConverter(params); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("parsing: &lt;%s&gt;, error: %s", params, err.Error()))</span>
        }
        <span class="cov8" title="1">return</span>
}

func NewDurationSecondsConverter(params string) (hdlr DataConverter, err error) <span class="cov8" title="1">{
        return new(DurationSecondsConverter), nil
}</span>

// DurationSecondsConverter converts duration into seconds encapsulated in float64
type DurationSecondsConverter struct{}

func (mS *DurationSecondsConverter) Convert(in any) (
        out any, err error) <span class="cov8" title="1">{
        var inDur time.Duration
        if inDur, err = IfaceAsDuration(in); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">out = inDur.Seconds()
        return</span>
}

func NewDurationNanosecondsConverter(params string) (
        hdlr DataConverter, err error) <span class="cov8" title="1">{
        return new(DurationNanosecondsConverter), nil
}</span>

// DurationNanosecondsConverter converts duration into nanoseconds encapsulated in int64
type DurationNanosecondsConverter struct{}

func (mS *DurationNanosecondsConverter) Convert(in any) (
        out any, err error) <span class="cov8" title="1">{
        var inDur time.Duration
        if inDur, err = IfaceAsDuration(in); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">out = inDur.Nanoseconds()
        return</span>
}

func NewRoundConverter(params string) (hdlr DataConverter, err error) <span class="cov8" title="1">{
        rc := new(RoundConverter)
        var paramsSplt []string
        if params != EmptyString </span><span class="cov8" title="1">{
                paramsSplt = strings.Split(params, InInFieldSep)
        }</span>
        <span class="cov8" title="1">switch len(paramsSplt) </span>{
        case 0:<span class="cov8" title="1">
                rc.Method = ROUNDING_MIDDLE</span>
        case 1:<span class="cov8" title="1">
                if rc.Decimals, err = strconv.Atoi(paramsSplt[0]); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%s converter needs integer as decimals, have: &lt;%s&gt;",
                                MetaRound, paramsSplt[0])
                }</span>
                <span class="cov8" title="1">rc.Method = ROUNDING_MIDDLE</span>
        case 2:<span class="cov8" title="1">
                rc.Method = paramsSplt[1]
                if rc.Decimals, err = strconv.Atoi(paramsSplt[0]); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%s converter needs integer as decimals, have: &lt;%s&gt;",
                                MetaRound, paramsSplt[0])
                }</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported %s converter parameters: &lt;%s&gt;",
                        MetaRound, params)</span>
        }
        <span class="cov8" title="1">return rc, nil</span>
}

// RoundConverter will round floats
type RoundConverter struct {
        Decimals int
        Method   string
}

func (rnd *RoundConverter) Convert(in any) (out any, err error) <span class="cov8" title="1">{
        var inFloat float64
        if inFloat, err = IfaceAsFloat64(in); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">out = Round(inFloat, rnd.Decimals, rnd.Method)
        return</span>
}

func NewMultiplyConverter(constructParams string) (hdlr DataConverter, err error) <span class="cov8" title="1">{
        if constructParams == EmptyString </span><span class="cov8" title="1">{
                return nil, ErrMandatoryIeMissingNoCaps
        }</span>
        <span class="cov8" title="1">var val float64
        if val, err = strconv.ParseFloat(constructParams, 64); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return &amp;MultiplyConverter{Value: val}, nil</span>
}

// MultiplyConverter multiplies input with value in params
// encapsulates the output as float64 value
type MultiplyConverter struct {
        Value float64
}

func (m *MultiplyConverter) Convert(in any) (out any, err error) <span class="cov8" title="1">{
        var inFloat64 float64
        if inFloat64, err = IfaceAsFloat64(in); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">out = inFloat64 * m.Value
        return</span>
}

func NewDivideConverter(constructParams string) (hdlr DataConverter, err error) <span class="cov8" title="1">{
        if constructParams == "" </span><span class="cov8" title="1">{
                return nil, ErrMandatoryIeMissingNoCaps
        }</span>
        <span class="cov8" title="1">var val float64
        if val, err = strconv.ParseFloat(constructParams, 64); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return &amp;DivideConverter{Value: val}, nil</span>
}

// DivideConverter divides input with value in params
// encapsulates the output as float64 value
type DivideConverter struct {
        Value float64
}

func (m *DivideConverter) Convert(in any) (out any, err error) <span class="cov8" title="1">{
        var inFloat64 float64
        if inFloat64, err = IfaceAsFloat64(in); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">out = inFloat64 / m.Value
        return</span>
}

func NewDurationConverter(params string) (hdlr DataConverter, err error) <span class="cov8" title="1">{
        return new(DurationConverter), nil
}</span>

// DurationConverter converts duration into seconds encapsulated in float64
type DurationConverter struct{}

func (mS *DurationConverter) Convert(in any) (
        out any, err error) <span class="cov8" title="1">{
        return IfaceAsDuration(in)
}</span>

// NewPhoneNumberConverter create a new phoneNumber converter
// If the format isn't specify by default we use NATIONAL
// Possible fromats are : E164(0) , INTERNATIONAL(1) , NATIONAL(2) ,RFC3966(3)
// Also ContryCode needs to be specified
func NewPhoneNumberConverter(params string) (
        pbDC DataConverter, err error) <span class="cov8" title="1">{
        lc := new(PhoneNumberConverter)
        var paramsSplt []string
        if params != EmptyString </span><span class="cov8" title="1">{
                paramsSplt = strings.Split(params, InInFieldSep)
        }</span>
        <span class="cov8" title="1">switch len(paramsSplt) </span>{
        case 2:<span class="cov8" title="1">
                lc.CountryCode = paramsSplt[0]
                frm, err := strconv.Atoi(paramsSplt[1])
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">lc.Format = phonenumbers.PhoneNumberFormat(frm)</span>
        case 1:<span class="cov8" title="1">
                lc.CountryCode = paramsSplt[0]
                lc.Format = 2</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported %s converter parameters: &lt;%s&gt;",
                        MetaLibPhoneNumber, params)</span>
        }
        <span class="cov8" title="1">return lc, nil</span>
}

// PhoneNumberConverter converts
type PhoneNumberConverter struct {
        CountryCode string
        Format      phonenumbers.PhoneNumberFormat
}

func (lc *PhoneNumberConverter) Convert(in any) (out any, err error) <span class="cov8" title="1">{
        num, err := phonenumbers.Parse(IfaceAsString(in), lc.CountryCode)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return phonenumbers.Format(num, lc.Format), nil</span>
}

// HexConvertor will round floats
type IP2HexConverter struct{}

func (*IP2HexConverter) Convert(in any) (out any, err error) <span class="cov8" title="1">{
        var ip net.IP
        switch val := in.(type) </span>{
        case string:<span class="cov8" title="1">
                ip = net.ParseIP(val)</span>
        case net.IP:<span class="cov8" title="1">
                ip = val</span>
        default:<span class="cov8" title="1">
                src := IfaceAsString(in)
                ip = net.ParseIP(src)</span>
        }

        <span class="cov8" title="1">hx := hex.EncodeToString([]byte(ip))
        if len(hx) &lt; 8 </span><span class="cov8" title="1">{
                return hx, nil
        }</span>
        <span class="cov8" title="1">return "0x" + string([]byte(hx)[len(hx)-8:]), nil</span>
}

// String2HexConverter will transform the string to hex
type String2HexConverter struct{}

// Convert implements DataConverter interface
func (*String2HexConverter) Convert(in any) (o any, err error) <span class="cov8" title="1">{
        var out string
        if out = hex.EncodeToString([]byte(IfaceAsString(in))); len(out) == 0 </span><span class="cov8" title="1">{
                o = out
                return
        }</span>
        <span class="cov8" title="1">o = "0x" + out
        return</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "net"
        "strings"
)

// posible NMType
const (
        NMDataType NMType = iota
        NMMapType
        NMSliceType
)

// DataProvider is a data source from multiple formats
type DataProvider interface {
        String() string // printable version of data
        FieldAsInterface(fldPath []string) (any, error)
        FieldAsString(fldPath []string) (string, error) // remove this
        RemoteHost() net.Addr
}

// NavigableMapper is the interface supported by replies convertible to CGRReply
type NavigableMapper interface {
        AsNavigableMap() NavigableMap2
}

// DPDynamicInterface returns the value of the field if the path is dynamic
func DPDynamicInterface(dnVal string, dP DataProvider) (any, error) <span class="cov8" title="1">{
        if strings.HasPrefix(dnVal, DynamicDataPrefix) </span><span class="cov8" title="1">{
                dnVal = strings.TrimPrefix(dnVal, DynamicDataPrefix)
                return dP.FieldAsInterface(strings.Split(dnVal, NestingSep))
        }</span>
        <span class="cov8" title="1">return StringToInterface(dnVal), nil</span>
}

// DPDynamicString returns the string value of the field if the path is dynamic
func DPDynamicString(dnVal string, dP DataProvider) (string, error) <span class="cov8" title="1">{
        if strings.HasPrefix(dnVal, DynamicDataPrefix) </span><span class="cov8" title="1">{
                dnVal = strings.TrimPrefix(dnVal, DynamicDataPrefix)
                return dP.FieldAsString(strings.Split(dnVal, NestingSep))
        }</span>
        <span class="cov8" title="1">return dnVal, nil</span>
}

// NMType the type used for navigable Map
type NMType byte

// NMInterface the basic interface
type NMInterface interface {
        String() string
        Interface() any
        Field(path PathItems) (val NMInterface, err error)
        Set(path PathItems, val NMInterface) (addedNew bool, err error)
        Remove(path PathItems) (err error)
        Type() NMType
        Empty() bool
        Len() int
}

// navMap subset of function for NM interface
type navMap interface {
        Field(path PathItems) (val NMInterface, err error)
        Set(fullpath *FullPath, val NMInterface) (addedNew bool, err error)
}

// AppendNavMapVal appends value to the map
func AppendNavMapVal(nm navMap, fldPath *FullPath, val NMInterface) (err error) <span class="cov8" title="1">{
        var prevItm NMInterface
        var indx int
        if prevItm, err = nm.Field(fldPath.PathItems); err != nil </span><span class="cov0" title="0">{
                if err != ErrNotFound </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov8" title="1"> {
                indx = prevItm.Len()
        }</span>
        <span class="cov8" title="1">fldPath.PathItems[len(fldPath.PathItems)-1].Index = &amp;indx
        _, err = nm.Set(fldPath, val)
        return</span>
}

// ComposeNavMapVal compose adds value to prevision item
func ComposeNavMapVal(nm navMap, fldPath *FullPath, val NMInterface) (err error) <span class="cov8" title="1">{
        var prevItmSlice NMInterface
        var indx int
        if prevItmSlice, err = nm.Field(fldPath.PathItems); err != nil </span><span class="cov8" title="1">{
                if err != ErrNotFound </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov8" title="1"> {
                indx = prevItmSlice.Len() - 1
                var prevItm NMInterface
                if prevItm, err = prevItmSlice.Field(PathItems{{Index: &amp;indx}}); err != nil </span><span class="cov8" title="1">{
                        if err != ErrNotFound </span><span class="cov0" title="0">{
                                return
                        }</span>
                } else<span class="cov8" title="1"> if _, err = val.Set(nil, NewNMData(IfaceAsString(prevItm.Interface())+IfaceAsString(val.Interface()))); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">fldPath.PathItems[len(fldPath.PathItems)-1].Index = &amp;indx
        _, err = nm.Set(fldPath, val)
        return</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "fmt"
        "net"
        "reflect"
        "sort"
        "strconv"
        "strings"
        "time"
)

// Defines years days series
type Years []int

func (ys Years) Sort() <span class="cov8" title="1">{
        sort.Sort(ys)
}</span>

func (ys Years) Len() int <span class="cov8" title="1">{
        return len(ys)
}</span>

func (ys Years) Swap(i, j int) <span class="cov8" title="1">{
        ys[i], ys[j] = ys[j], ys[i]
}</span>

func (ys Years) Less(j, i int) bool <span class="cov8" title="1">{
        return ys[j] &lt; ys[i]
}</span>

// Return true if the specified date is inside the series
func (ys Years) Contains(year int) (result bool) <span class="cov8" title="1">{
        result = false
        for _, yss := range ys </span><span class="cov8" title="1">{
                if yss == year </span><span class="cov8" title="1">{
                        result = true
                        break</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// Parse Years elements from string separated by sep.
func (ys *Years) Parse(input, sep string) <span class="cov8" title="1">{
        switch input </span>{
        case META_ANY, EmptyString:<span class="cov8" title="1">
                *ys = []int{}</span>
        default:<span class="cov8" title="1">
                elements := strings.Split(input, sep)
                for _, yss := range elements </span><span class="cov8" title="1">{
                        if year, err := strconv.Atoi(yss); err == nil </span><span class="cov8" title="1">{
                                *ys = append(*ys, year)
                        }</span>
                }
        }
}

func (ys Years) Serialize(sep string) string <span class="cov8" title="1">{
        if len(ys) == 0 </span><span class="cov8" title="1">{
                return META_ANY
        }</span>
        <span class="cov8" title="1">var yStr string
        for idx, yr := range ys </span><span class="cov8" title="1">{
                if idx != 0 </span><span class="cov8" title="1">{
                        yStr = fmt.Sprintf("%s%s%d", yStr, sep, yr)
                }</span> else<span class="cov8" title="1"> {
                        yStr = strconv.Itoa(yr)
                }</span>
        }
        <span class="cov8" title="1">return yStr</span>
}

// Equals implies that Years are already sorted
func (ys Years) Equals(oYS Years) bool <span class="cov8" title="1">{
        if len(ys) != len(oYS) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i := range ys </span><span class="cov8" title="1">{
                if ys[i] != oYS[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Defines months series
type Months []time.Month

func (m Months) Sort() <span class="cov8" title="1">{
        sort.Sort(m)
}</span>

func (m Months) Len() int <span class="cov8" title="1">{
        return len(m)
}</span>

func (m Months) Swap(i, j int) <span class="cov8" title="1">{
        m[i], m[j] = m[j], m[i]
}</span>

func (m Months) Less(j, i int) bool <span class="cov8" title="1">{
        return m[j] &lt; m[i]
}</span>

// Return true if the specified date is inside the series
func (m Months) Contains(month time.Month) (result bool) <span class="cov8" title="1">{
        for _, ms := range m </span><span class="cov8" title="1">{
                if ms == month </span><span class="cov8" title="1">{
                        result = true
                        break</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// Loades Month elemnents from a string separated by sep.
func (m *Months) Parse(input, sep string) <span class="cov8" title="1">{
        switch input </span>{
        case META_ANY, EmptyString:<span class="cov8" title="1"> // Apier cannot receive empty string, hence using meta-tag
                *m = []time.Month{}</span>
        default:<span class="cov8" title="1">
                elements := strings.Split(input, sep)
                for _, ms := range elements </span><span class="cov8" title="1">{
                        if month, err := strconv.Atoi(ms); err == nil </span><span class="cov8" title="1">{
                                *m = append(*m, time.Month(month))
                        }</span>
                }
        }
}

// Dumps the months in a serialized string, similar to the one parsed
func (m Months) Serialize(sep string) string <span class="cov8" title="1">{
        if len(m) == 0 </span><span class="cov8" title="1">{
                return META_ANY
        }</span>
        <span class="cov8" title="1">var mStr string
        for idx, mt := range m </span><span class="cov8" title="1">{
                if idx != 0 </span><span class="cov8" title="1">{
                        mStr = fmt.Sprintf("%s%s%d", mStr, sep, mt)
                }</span> else<span class="cov8" title="1"> {
                        mStr = strconv.Itoa(int(mt))
                }</span>
        }
        <span class="cov8" title="1">return mStr</span>
}

func (m Months) IsComplete() bool <span class="cov8" title="1">{
        allMonths := Months{time.January, time.February, time.March, time.April, time.May, time.June, time.July, time.August, time.September, time.October, time.November, time.December}
        m.Sort()
        return reflect.DeepEqual(m, allMonths)
}</span>

// Equals implies that Months are already sorted
func (m Months) Equals(oM Months) bool <span class="cov8" title="1">{
        if len(m) != len(oM) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i := range m </span><span class="cov8" title="1">{
                if m[i] != oM[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Defines month days series
type MonthDays []int

func (md MonthDays) Sort() <span class="cov8" title="1">{
        sort.Sort(md)
}</span>

func (md MonthDays) Len() int <span class="cov8" title="1">{
        return len(md)
}</span>

func (md MonthDays) Swap(i, j int) <span class="cov8" title="1">{
        md[i], md[j] = md[j], md[i]
}</span>

func (md MonthDays) Less(j, i int) bool <span class="cov8" title="1">{
        return md[j] &lt; md[i]
}</span>

// Return true if the specified date is inside the series
func (md MonthDays) Contains(monthDay int) (result bool) <span class="cov8" title="1">{
        result = false
        for _, mds := range md </span><span class="cov8" title="1">{
                if mds == monthDay </span><span class="cov8" title="1">{
                        result = true
                        break</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// Parse MonthDay elements from string separated by sep.
func (md *MonthDays) Parse(input, sep string) <span class="cov8" title="1">{
        switch input </span>{
        case META_ANY, EmptyString:<span class="cov8" title="1">
                *md = []int{}</span>
        default:<span class="cov8" title="1">
                elements := strings.Split(input, sep)
                for _, mds := range elements </span><span class="cov8" title="1">{
                        if day, err := strconv.Atoi(mds); err == nil </span><span class="cov8" title="1">{
                                *md = append(*md, day)
                        }</span>
                }
        }
}

// Dumps the month days in a serialized string, similar to the one parsed
func (md MonthDays) Serialize(sep string) string <span class="cov8" title="1">{
        if len(md) == 0 </span><span class="cov8" title="1">{
                return META_ANY
        }</span>
        <span class="cov8" title="1">var mdsStr string
        for idx, mDay := range md </span><span class="cov8" title="1">{
                if idx != 0 </span><span class="cov8" title="1">{
                        mdsStr = fmt.Sprintf("%s%s%d", mdsStr, sep, mDay)
                }</span> else<span class="cov8" title="1"> {
                        mdsStr = strconv.Itoa(mDay)
                }</span>
        }
        <span class="cov8" title="1">return mdsStr</span>
}

// Equals implies that MonthDays are already sorted
func (md MonthDays) Equals(oMD MonthDays) bool <span class="cov8" title="1">{
        if len(md) != len(oMD) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i := range md </span><span class="cov8" title="1">{
                if md[i] != oMD[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Defines week days series
type WeekDays []time.Weekday

func (wd WeekDays) Sort() <span class="cov8" title="1">{
        sort.Sort(wd)
}</span>

func (wd WeekDays) Len() int <span class="cov8" title="1">{
        return len(wd)
}</span>

func (wd WeekDays) Swap(i, j int) <span class="cov8" title="1">{
        wd[i], wd[j] = wd[j], wd[i]
}</span>

func (wd WeekDays) Less(j, i int) bool <span class="cov8" title="1">{
        return wd[j] &lt; wd[i]
}</span>

// Return true if the specified date is inside the series
func (wd WeekDays) Contains(weekDay time.Weekday) (result bool) <span class="cov8" title="1">{
        result = false
        for _, wds := range wd </span><span class="cov8" title="1">{
                if wds == weekDay </span><span class="cov8" title="1">{
                        result = true
                        break</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (wd *WeekDays) Parse(input, sep string) <span class="cov8" title="1">{
        switch input </span>{
        case META_ANY, EmptyString:<span class="cov8" title="1">
                *wd = []time.Weekday{}</span>
        default:<span class="cov8" title="1">
                elements := strings.Split(input, sep)
                for _, wds := range elements </span><span class="cov8" title="1">{
                        if day, err := strconv.Atoi(wds); err == nil </span><span class="cov8" title="1">{
                                *wd = append(*wd, time.Weekday(day%7)) // %7 for sunday = 7 normalization
                        }</span>
                }
        }
}

// Dumps the week days in a serialized string, similar to the one parsed
func (wd WeekDays) Serialize(sep string) string <span class="cov8" title="1">{
        if len(wd) == 0 </span><span class="cov8" title="1">{
                return META_ANY
        }</span>
        <span class="cov8" title="1">var wdStr string
        for idx, d := range wd </span><span class="cov8" title="1">{
                if idx != 0 </span><span class="cov8" title="1">{
                        wdStr = fmt.Sprintf("%s%s%d", wdStr, sep, d)
                }</span> else<span class="cov8" title="1"> {
                        wdStr = strconv.Itoa(int(d))
                }</span>
        }
        <span class="cov8" title="1">return wdStr</span>
}

// Equals implies that WeekDays are already sorted
func (wd WeekDays) Equals(oWD WeekDays) bool <span class="cov8" title="1">{
        if len(wd) != len(oWD) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i := range wd </span><span class="cov8" title="1">{
                if wd[i] != oWD[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func DaysInMonth(year int, month time.Month) float64 <span class="cov8" title="1">{
        return float64(time.Date(year, month, 1, 0, 0, 0, 0, time.UTC).AddDate(0, 1, -1).Day())
}</span>

func DaysInYear(year int) float64 <span class="cov8" title="1">{
        first := time.Date(year, 1, 1, 0, 0, 0, 0, time.UTC)
        last := first.AddDate(1, 0, 0)
        return float64(last.Sub(first).Hours() / 24)
}</span>

func LocalAddr() *NetAddr <span class="cov8" title="1">{
        return &amp;NetAddr{network: Local, ip: Local}
}</span>

func NewNetAddr(network, host string) *NetAddr <span class="cov8" title="1">{
        ip, port, err := net.SplitHostPort(host)
        if err != nil </span><span class="cov8" title="1">{
                Logger.Warning(fmt.Sprintf("failed parsing RemoteAddr: %s, err: %s",
                        host, err.Error()))
        }</span>
        <span class="cov8" title="1">p, err := strconv.Atoi(port)
        if err != nil </span><span class="cov8" title="1">{
                Logger.Warning(fmt.Sprintf("failed converting port : %+v, err: %s",
                        port, err.Error()))
        }</span>
        <span class="cov8" title="1">return &amp;NetAddr{network: network, ip: ip, port: p}</span>
}

type NetAddr struct {
        network string
        ip      string
        port    int
}

// Network is part of net.Addr interface
func (lc *NetAddr) Network() string <span class="cov8" title="1">{
        return lc.network
}</span>

// String is part of net.Addr interface
func (lc *NetAddr) String() string <span class="cov8" title="1">{
        return lc.ip
}</span>

// Port
func (lc *NetAddr) Port() int <span class="cov8" title="1">{
        return lc.port
}</span>

// Host
func (lc *NetAddr) Host() string <span class="cov8" title="1">{
        if lc.ip == Local </span><span class="cov8" title="1">{
                return Local
        }</span>
        <span class="cov8" title="1">return ConcatenatedKey(lc.ip, strconv.Itoa(lc.port))</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "errors"
        "fmt"
        "net"
        "net/rpc"
        "strings"
)

var (
        ErrNoMoreData               = errors.New("NO_MORE_DATA")
        ErrNotImplemented           = errors.New("NOT_IMPLEMENTED")
        ErrNotFound                 = errors.New("NOT_FOUND")
        ErrTimedOut                 = errors.New("TIMED_OUT")
        ErrServerError              = errors.New("SERVER_ERROR")
        ErrMaxRecursionDepth        = errors.New("MAX_RECURSION_DEPTH")
        ErrMandatoryIeMissing       = errors.New("MANDATORY_IE_MISSING")
        ErrExists                   = errors.New("EXISTS")
        ErrBrokenReference          = errors.New("BROKEN_REFERENCE")
        ErrParserError              = errors.New("PARSER_ERROR")
        ErrInvalidPath              = errors.New("INVALID_PATH")
        ErrInvalidKey               = errors.New("INVALID_KEY")
        ErrUnauthorizedDestination  = errors.New("UNAUTHORIZED_DESTINATION")
        ErrRatingPlanNotFound       = errors.New("RATING_PLAN_NOT_FOUND")
        ErrAccountNotFound          = errors.New("ACCOUNT_NOT_FOUND")
        ErrAccountDisabled          = errors.New("ACCOUNT_DISABLED")
        ErrInsufficientCredit       = errors.New("INSUFFICIENT_CREDIT")
        ErrNotConvertible           = errors.New("NOT_CONVERTIBLE")
        ErrResourceUnavailable      = errors.New("RESOURCE_UNAVAILABLE")
        ErrResourceUnauthorized     = errors.New("RESOURCE_UNAUTHORIZED")
        ErrNoActiveSession          = errors.New("NO_ACTIVE_SESSION")
        ErrPartiallyExecuted        = errors.New("PARTIALLY_EXECUTED")
        ErrMaxUsageExceeded         = errors.New("MAX_USAGE_EXCEEDED")
        ErrFilterNotPassingNoCaps   = errors.New("filter not passing")
        ErrNotConvertibleNoCaps     = errors.New("not convertible")
        ErrMandatoryIeMissingNoCaps = errors.New("mandatory information missing")
        ErrUnauthorizedApi          = errors.New("UNAUTHORIZED_API")
        ErrUnknownApiKey            = errors.New("UNKNOWN_API_KEY")
        ErrReqUnsynchronized        = errors.New("REQ_UNSYNCHRONIZED")
        ErrUnsupporteServiceMethod  = errors.New("UNSUPPORTED_SERVICE_METHOD")
        ErrDisconnected             = errors.New("DISCONNECTED")
        ErrReplyTimeout             = errors.New("REPLY_TIMEOUT")
        ErrSessionNotFound          = errors.New("SESSION_NOT_FOUND")
        ErrJsonIncompleteComment    = errors.New("JSON_INCOMPLETE_COMMENT")
        ErrNotEnoughParameters      = errors.New("NotEnoughParameters")
        ErrNotConnected             = errors.New("NOT_CONNECTED")
        RalsErrorPrfx               = "RALS_ERROR"
        DispatcherErrorPrefix       = "DISPATCHER_ERROR"
        ErrUnsupportedFormat        = errors.New("UNSUPPORTED_FORMAT")
        ErrNoDatabaseConn           = errors.New("NO_DATA_BASE_CONNECTION")
        ErrMaxIncrementsExceeded    = errors.New("MAX_INCREMENTS_EXCEEDED")
        ErrIndexOutOfBounds         = errors.New("INDEX_OUT_OF_BOUNDS")
        ErrWrongPath                = errors.New("WRONG_PATH")
        ErrServiceAlreadyRunning    = fmt.Errorf("service already running")

        ErrMap = map[string]error{
                ErrNoMoreData.Error():              ErrNoMoreData,
                ErrNotImplemented.Error():          ErrNotImplemented,
                ErrNotFound.Error():                ErrNotFound,
                ErrTimedOut.Error():                ErrTimedOut,
                ErrServerError.Error():             ErrServerError,
                ErrMaxRecursionDepth.Error():       ErrMaxRecursionDepth,
                ErrExists.Error():                  ErrExists,
                ErrBrokenReference.Error():         ErrBrokenReference,
                ErrParserError.Error():             ErrParserError,
                ErrInvalidPath.Error():             ErrInvalidPath,
                ErrInvalidKey.Error():              ErrInvalidKey,
                ErrUnauthorizedDestination.Error(): ErrUnauthorizedDestination,
                ErrRatingPlanNotFound.Error():      ErrRatingPlanNotFound,
                ErrInsufficientCredit.Error():      ErrInsufficientCredit,
                ErrNotConvertible.Error():          ErrNotConvertible,
                ErrResourceUnavailable.Error():     ErrResourceUnavailable,
                ErrResourceUnauthorized.Error():    ErrResourceUnauthorized,
                ErrNoActiveSession.Error():         ErrNoActiveSession,
                ErrPartiallyExecuted.Error():       ErrPartiallyExecuted,
                ErrMaxUsageExceeded.Error():        ErrMaxUsageExceeded,
                ErrFilterNotPassingNoCaps.Error():  ErrFilterNotPassingNoCaps,
                ErrNotConvertibleNoCaps.Error():    ErrNotConvertibleNoCaps,
                ErrUnauthorizedApi.Error():         ErrUnauthorizedApi,
                ErrUnknownApiKey.Error():           ErrUnknownApiKey,
                ErrReqUnsynchronized.Error():       ErrReqUnsynchronized,
                ErrUnsupporteServiceMethod.Error(): ErrUnsupporteServiceMethod,
                ErrDisconnected.Error():            ErrDisconnected,
                ErrReplyTimeout.Error():            ErrReplyTimeout,
                ErrSessionNotFound.Error():         ErrSessionNotFound,
                ErrJsonIncompleteComment.Error():   ErrJsonIncompleteComment,
                ErrNotEnoughParameters.Error():     ErrNotEnoughParameters,
                ErrUnsupportedFormat.Error():       ErrUnsupportedFormat,
                ErrNoDatabaseConn.Error():          ErrNoDatabaseConn,
                ErrMaxIncrementsExceeded.Error():   ErrMaxIncrementsExceeded,
                ErrIndexOutOfBounds.Error():        ErrIndexOutOfBounds,
                ErrWrongPath.Error():               ErrWrongPath,
        }
)

// NewCGRError initialises a new CGRError
func NewCGRError(context, apiErr, shortErr, longErr string) *CGRError <span class="cov8" title="1">{
        return &amp;CGRError{context: context, apiError: apiErr,
                shortError: shortErr, longError: longErr, errorMessage: shortErr}
}</span>

// CGRError is a context based error
// returns always errorMessage but this can be switched based on methods called on it
type CGRError struct {
        context      string
        apiError     string
        shortError   string
        longError    string
        errorMessage string
}

func (err *CGRError) Context() string <span class="cov8" title="1">{
        return err.context
}</span>

func (err *CGRError) Error() string <span class="cov8" title="1">{
        return err.errorMessage
}</span>

func (err *CGRError) ActivateAPIError() <span class="cov8" title="1">{
        err.errorMessage = err.apiError
}</span>

func (err *CGRError) ActivateShortError() <span class="cov8" title="1">{
        err.errorMessage = err.shortError
}</span>

func (err *CGRError) ActivateLongError() <span class="cov8" title="1">{
        err.errorMessage = err.longError
}</span>

func NewErrMandatoryIeMissing(fields ...string) error <span class="cov8" title="1">{
        return fmt.Errorf("MANDATORY_IE_MISSING: %v", fields)
}</span>

func NewErrServerError(err error) error <span class="cov8" title="1">{
        return fmt.Errorf("SERVER_ERROR: %s", err)
}</span>

func NewErrServiceNotOperational(serv string) error <span class="cov8" title="1">{
        return fmt.Errorf("SERVICE_NOT_OPERATIONAL: %s", serv)
}</span>

func NewErrNotConnected(serv string) error <span class="cov8" title="1">{
        return fmt.Errorf("NOT_CONNECTED: %s", serv)
}</span>

func NewErrRALs(err error) error <span class="cov8" title="1">{
        return fmt.Errorf("%s:%s", RalsErrorPrfx, err)
}</span>

func NewErrResourceS(err error) error <span class="cov8" title="1">{
        return fmt.Errorf("RESOURCES_ERROR:%s", err)
}</span>

func NewErrSupplierS(err error) error <span class="cov8" title="1">{
        return fmt.Errorf("SUPPLIERS_ERROR:%s", err)
}</span>

func NewErrAttributeS(err error) error <span class="cov8" title="1">{
        return fmt.Errorf("ATTRIBUTES_ERROR:%s", err)
}</span>

func NewErrChargerS(err error) error <span class="cov0" title="0">{
        return fmt.Errorf("CHARGERS_ERROR:%s", err)
}</span>

func NewErrDispatcherS(err error) error <span class="cov8" title="1">{
        return fmt.Errorf("%s:%s", DispatcherErrorPrefix, err.Error())
}</span>

// Centralized returns for APIs
func APIErrorHandler(errIn error) (err error) <span class="cov8" title="1">{
        cgrErr, ok := errIn.(*CGRError)
        if !ok </span><span class="cov8" title="1">{
                err = errIn
                if err != ErrNotFound </span><span class="cov8" title="1">{
                        err = NewErrServerError(err)
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">cgrErr.ActivateAPIError()
        return cgrErr</span>
}

func NewErrStringCast(valIface any) error <span class="cov8" title="1">{
        return fmt.Errorf("cannot cast value: %v to string", valIface)
}</span>

func NewErrFldStringCast(fldName string, valIface any) error <span class="cov8" title="1">{
        return fmt.Errorf("cannot cast field: %s with value: %v to string", fldName, valIface)
}</span>

func ErrHasPrefix(err error, prfx string) (has bool) <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return strings.HasPrefix(err.Error(), prfx)</span>
}

func ErrPrefix(err error, reason string) error <span class="cov8" title="1">{
        return fmt.Errorf("%s:%s", err.Error(), reason)
}</span>

func ErrPrefixNotFound(reason string) error <span class="cov8" title="1">{
        return ErrPrefix(ErrNotFound, reason)
}</span>

func ErrPrefixNotErrNotImplemented(reason string) error <span class="cov8" title="1">{
        return ErrPrefix(ErrNotImplemented, reason)
}</span>

func ErrEnvNotFound(key string) error <span class="cov8" title="1">{
        return ErrPrefix(ErrNotFound, "ENV_VAR:"+key)
}</span>

// IsNetworkError will decide if an error is network generated or RPC one
// used by Dispatcher to figure out whether it should try another connection
func IsNetworkError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if _, isNetError := err.(*net.OpError); isNetError </span><span class="cov8" title="1">{ // connection reset
                return true
        }</span>
        <span class="cov8" title="1">if _, isDNSError := err.(*net.DNSError); isDNSError </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return err.Error() == rpc.ErrShutdown.Error() ||
                err.Error() == ErrReqUnsynchronized.Error() ||
                err.Error() == ErrDisconnected.Error() ||
                err.Error() == ErrReplyTimeout.Error() ||
                err.Error() == ErrSessionNotFound.Error() ||
                strings.HasPrefix(err.Error(), "rpc: can't find service")</span>
}

func ErrPathNotReachable(path string) error <span class="cov8" title="1">{
        return fmt.Errorf("path:%+q is not reachable", path)
}</span>

func ErrNotConvertibleTF(from, to string) error <span class="cov8" title="1">{
        return fmt.Errorf("%s : from: %s to:%s", ErrNotConvertibleNoCaps.Error(), from, to)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "encoding/json"
        "errors"
        "io"
        "net/rpc"
        "strings"
        "sync"
)

var errMissingParams = errors.New("jsonrpc: request body missing params")

type MethodParameters struct {
        Method     string
        Parameters any
}

type jsonServerCodec struct {
        dec *json.Decoder // for reading JSON values
        enc *json.Encoder // for writing JSON values
        c   io.Closer

        // temporary work space
        req serverRequest

        // JSON-RPC clients can use arbitrary json values as request IDs.
        // Package rpc expects uint64 request IDs.
        // We assign uint64 sequence numbers to incoming requests
        // but save the original request ID in the pending map.
        // When rpc responds, we use the sequence number in
        // the response to find the original request ID.
        mutex   sync.Mutex // protects seq, pending
        seq     uint64
        pending map[uint64]*json.RawMessage
}

// NewCustomJSONServerCodec is used only when DispatcherS is active to handle APIer methods generically
func NewCustomJSONServerCodec(conn io.ReadWriteCloser) rpc.ServerCodec <span class="cov0" title="0">{
        return &amp;jsonServerCodec{
                dec:     json.NewDecoder(conn),
                enc:     json.NewEncoder(conn),
                c:       conn,
                pending: make(map[uint64]*json.RawMessage),
        }
}</span>

type serverRequest struct {
        Method  string           `json:"method"`
        Params  *json.RawMessage `json:"params"`
        Id      *json.RawMessage `json:"id"`
        isApier bool
}

func (r *serverRequest) reset() <span class="cov0" title="0">{
        r.Method = ""
        r.Params = nil
        r.Id = nil
}</span>

type serverResponse struct {
        Id     *json.RawMessage `json:"id"`
        Result any              `json:"result"`
        Error  any              `json:"error"`
}

func (c *jsonServerCodec) ReadRequestHeader(r *rpc.Request) error <span class="cov0" title="0">{
        c.req.reset()
        if err := c.dec.Decode(&amp;c.req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // in case we get a request with APIerSv1 or APIerSv2 we redirect
        // to Dispatcher to send it according to ArgDispatcher
        <span class="cov0" title="0">if c.req.isApier = strings.HasPrefix(c.req.Method, ApierV); c.req.isApier </span><span class="cov0" title="0">{
                r.ServiceMethod = DispatcherSv1Apier
        }</span> else<span class="cov0" title="0"> {
                r.ServiceMethod = c.req.Method
        }</span>

        // JSON request id can be any JSON value;
        // RPC package expects uint64.  Translate to
        // internal uint64 and save JSON on the side.
        <span class="cov0" title="0">c.mutex.Lock()
        c.seq++
        c.pending[c.seq] = c.req.Id
        c.req.Id = nil
        r.Seq = c.seq
        c.mutex.Unlock()

        return nil</span>
}

func (c *jsonServerCodec) ReadRequestBody(x any) error <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if c.req.Params == nil </span><span class="cov0" title="0">{
                return errMissingParams
        }</span>
        // following example from ReadRequestHeader in case we get APIerSv1
        // or APIerSv2 we compose the parameters
        <span class="cov0" title="0">if c.req.isApier </span><span class="cov0" title="0">{
                cx := x.(*MethodParameters)
                cx.Method = c.req.Method
                var params [1]any
                params[0] = &amp;cx.Parameters
                return json.Unmarshal(*c.req.Params, &amp;params)
        }</span>
        // JSON params is array value.
        // RPC params is struct.
        // Unmarshal into array containing struct for now.
        // Should think about making RPC more general.
        <span class="cov0" title="0">var params [1]any
        params[0] = x
        return json.Unmarshal(*c.req.Params, &amp;params)</span>

}

var null = json.RawMessage([]byte("null"))

func (c *jsonServerCodec) WriteResponse(r *rpc.Response, x any) error <span class="cov0" title="0">{
        c.mutex.Lock()
        b, ok := c.pending[r.Seq]
        if !ok </span><span class="cov0" title="0">{
                c.mutex.Unlock()
                return errors.New("invalid sequence number in response")
        }</span>
        <span class="cov0" title="0">delete(c.pending, r.Seq)
        c.mutex.Unlock()

        if b == nil </span><span class="cov0" title="0">{
                // Invalid request so no id. Use JSON null.
                b = &amp;null
        }</span>
        <span class="cov0" title="0">resp := serverResponse{Id: b}
        if r.Error == "" </span><span class="cov0" title="0">{
                resp.Result = x
        }</span> else<span class="cov0" title="0"> {
                resp.Error = r.Error
        }</span>
        <span class="cov0" title="0">return c.enc.Encode(resp)</span>
}

func (c *jsonServerCodec) Close() error <span class="cov0" title="0">{
        return c.c.Close()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "fmt"
        "log"
        "log/syslog"
        "reflect"
        "runtime"
)

var Logger LoggerInterface
var nodeID string

func init() <span class="cov8" title="1">{
        if Logger == nil || reflect.ValueOf(Logger).IsNil() </span><span class="cov8" title="1">{
                err := Newlogger(MetaSysLog, nodeID)
                if err != nil </span><span class="cov0" title="0">{
                        Logger.Err(fmt.Sprintf("Could not connect to syslog: %v", err))
                }</span>
        }
}

// functie Newlogger (logger type)
func Newlogger(loggertype, id string) (err error) <span class="cov8" title="1">{
        Logger = new(StdLogger)
        nodeID = id
        var l *syslog.Writer
        if loggertype == MetaSysLog </span><span class="cov8" title="1">{
                if l, err = syslog.New(syslog.LOG_INFO|syslog.LOG_DAEMON, fmt.Sprintf("CGRateS &lt;%s&gt; ", nodeID)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov8" title="1"> {
                        Logger.SetSyslog(l)
                }</span>
                <span class="cov8" title="1">return nil</span>
        } else<span class="cov0" title="0"> if loggertype != MetaStdLog </span><span class="cov0" title="0">{
                return fmt.Errorf("unsuported logger: &lt;%s&gt;", loggertype)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type LoggerInterface interface {
        SetSyslog(log *syslog.Writer)
        SetLogLevel(level int)
        GetSyslog() *syslog.Writer
        Close() error
        Emerg(m string) error
        Alert(m string) error
        Crit(m string) error
        Err(m string) error
        Warning(m string) error
        Notice(m string) error
        Info(m string) error
        Debug(m string) error
        Write(p []byte) (n int, err error)
}

// log severities following rfc3164
const (
        LOGLEVEL_EMERGENCY = iota
        LOGLEVEL_ALERT
        LOGLEVEL_CRITICAL
        LOGLEVEL_ERROR
        LOGLEVEL_WARNING
        LOGLEVEL_NOTICE
        LOGLEVEL_INFO
        LOGLEVEL_DEBUG
)

// Logs to standard output
type StdLogger struct {
        logLevel int
        syslog   *syslog.Writer
}

func (sl *StdLogger) Close() (err error) <span class="cov0" title="0">{
        if sl.syslog != nil </span><span class="cov0" title="0">{
                sl.Close()
        }</span>
        <span class="cov0" title="0">return</span>
}
func (sl *StdLogger) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        s := string(p[:])
        fmt.Print(s)
        return 1, nil
}</span>

// SetSyslog sets the logger for the server
func (sl *StdLogger) SetSyslog(l *syslog.Writer) <span class="cov8" title="1">{
        sl.syslog = l
}</span>

// GetSyslog returns the logger for the server
func (sl *StdLogger) GetSyslog() *syslog.Writer <span class="cov0" title="0">{
        return sl.syslog
}</span>

// SetLogLevel changes the log level
func (sl *StdLogger) SetLogLevel(level int) <span class="cov0" title="0">{
        sl.logLevel = level
}</span>

// Alert logs to syslog with alert level
func (sl *StdLogger) Alert(m string) (err error) <span class="cov0" title="0">{
        if sl.logLevel &lt; LOGLEVEL_ALERT </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if sl.syslog != nil </span><span class="cov0" title="0">{
                sl.syslog.Alert(m)
        }</span> else<span class="cov0" title="0"> {
                log.Print("CGRateS &lt;" + nodeID + "&gt; [ALERT] " + m)
        }</span>
        <span class="cov0" title="0">return</span>
}

// Crit logs to syslog with critical level
func (sl *StdLogger) Crit(m string) (err error) <span class="cov0" title="0">{
        if sl.logLevel &lt; LOGLEVEL_CRITICAL </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if sl.syslog != nil </span><span class="cov0" title="0">{
                sl.syslog.Crit(m)
        }</span> else<span class="cov0" title="0"> {
                log.Print("CGRateS &lt;" + nodeID + "&gt; [CRITICAL] " + m)
        }</span>
        <span class="cov0" title="0">return</span>
}

// Debug logs to syslog with debug level
func (sl *StdLogger) Debug(m string) (err error) <span class="cov0" title="0">{
        if sl.logLevel &lt; LOGLEVEL_DEBUG </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if sl.syslog != nil </span><span class="cov0" title="0">{
                sl.syslog.Debug(m)
        }</span> else<span class="cov0" title="0"> {
                log.Print("CGRateS &lt;" + nodeID + "&gt; [DEBUG] " + m)
        }</span>
        <span class="cov0" title="0">return</span>
}

// Emerg logs to syslog with emergency level
func (sl *StdLogger) Emerg(m string) (err error) <span class="cov0" title="0">{
        if sl.logLevel &lt; LOGLEVEL_EMERGENCY </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if sl.syslog != nil </span><span class="cov0" title="0">{
                sl.syslog.Emerg(m)
        }</span> else<span class="cov0" title="0"> {
                log.Print("CGRateS &lt;" + nodeID + "&gt; [EMERGENCY] " + m)
        }</span>
        <span class="cov0" title="0">return</span>
}

// Err logs to syslog with error level
func (sl *StdLogger) Err(m string) (err error) <span class="cov8" title="1">{
        if sl.logLevel &lt; LOGLEVEL_ERROR </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">if sl.syslog != nil </span><span class="cov0" title="0">{
                sl.syslog.Err(m)
        }</span> else<span class="cov0" title="0"> {
                log.Print("CGRateS &lt;" + nodeID + "&gt; [ERROR] " + m)
        }</span>
        <span class="cov0" title="0">return</span>
}

// Info logs to syslog with info level
func (sl *StdLogger) Info(m string) (err error) <span class="cov0" title="0">{
        if sl.logLevel &lt; LOGLEVEL_INFO </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if sl.syslog != nil </span><span class="cov0" title="0">{
                sl.syslog.Info(m)
        }</span> else<span class="cov0" title="0"> {
                log.Print("CGRateS &lt;" + nodeID + "&gt; [INFO] " + m)
        }</span>
        <span class="cov0" title="0">return</span>
}

// Notice logs to syslog with notice level
func (sl *StdLogger) Notice(m string) (err error) <span class="cov0" title="0">{
        if sl.logLevel &lt; LOGLEVEL_NOTICE </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if sl.syslog != nil </span><span class="cov0" title="0">{
                sl.syslog.Notice(m)
        }</span> else<span class="cov0" title="0"> {
                log.Print("CGRateS &lt;" + nodeID + "&gt; [NOTICE] " + m)
        }</span>
        <span class="cov0" title="0">return</span>
}

// Warning logs to syslog with warning level
func (sl *StdLogger) Warning(m string) (err error) <span class="cov8" title="1">{
        if sl.logLevel &lt; LOGLEVEL_WARNING </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">if sl.syslog != nil </span><span class="cov0" title="0">{
                sl.syslog.Warning(m)
        }</span> else<span class="cov0" title="0"> {
                log.Print("CGRateS &lt;" + nodeID + "&gt; [WARNING] " + m)
        }</span>
        <span class="cov0" title="0">return</span>
}

// LogStack logs to syslog the stack trace using debug level
func LogStack() <span class="cov0" title="0">{
        buf := make([]byte, 300)
        runtime.Stack(buf, false)
        Logger.Debug(string(buf))
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "reflect"
        "strconv"
        "strings"
)

// Converts map[string]string into map[string]any
func ConvertMapValStrIf(inMap map[string]string) map[string]any <span class="cov8" title="1">{
        outMap := make(map[string]any)
        for field, val := range inMap </span><span class="cov8" title="1">{
                outMap[field] = val
        }</span>
        <span class="cov8" title="1">return outMap</span>
}

// Mirrors key/val
func MirrorMap(mapIn map[string]string) map[string]string <span class="cov8" title="1">{
        mapOut := make(map[string]string, len(mapIn))
        for key, val := range mapIn </span><span class="cov8" title="1">{
                mapOut[val] = key
        }</span>
        <span class="cov8" title="1">return mapOut</span>
}

// Returns mising keys in a map
func MissingMapKeys(inMap map[string]string, requiredKeys []string) []string <span class="cov8" title="1">{
        missingKeys := []string{}
        for _, reqKey := range requiredKeys </span><span class="cov8" title="1">{
                if val, hasKey := inMap[reqKey]; !hasKey || val == EmptyString </span><span class="cov8" title="1">{
                        missingKeys = append(missingKeys, reqKey)
                }</span>
        }
        <span class="cov8" title="1">return missingKeys</span>
}

// Return map keys
func MapKeys(m map[string]string) []string <span class="cov8" title="1">{
        n := make([]string, len(m))
        i := 0
        for k := range m </span><span class="cov8" title="1">{
                n[i] = k
                i++
        }</span>
        <span class="cov8" title="1">return n</span>
}

type StringMap map[string]bool

func NewStringMap(s ...string) StringMap <span class="cov8" title="1">{
        result := make(StringMap)
        for _, v := range s </span><span class="cov8" title="1">{
                v = strings.TrimSpace(v)
                if v != EmptyString </span><span class="cov8" title="1">{
                        if strings.HasPrefix(v, NegativePrefix) </span><span class="cov8" title="1">{
                                result[v[1:]] = false
                        }</span> else<span class="cov8" title="1"> {
                                result[v] = true
                        }</span>
                }
        }
        <span class="cov8" title="1">return result</span>
}

func ParseStringMap(s string) StringMap <span class="cov8" title="1">{
        if s == ZERO </span><span class="cov8" title="1">{
                return make(StringMap)
        }</span>
        <span class="cov8" title="1">return StringMapFromSlice(strings.Split(s, INFIELD_SEP))</span>
}

func (sm StringMap) Equal(om StringMap) bool <span class="cov8" title="1">{
        if sm == nil &amp;&amp; om != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if len(sm) != len(om) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for key := range sm </span><span class="cov8" title="1">{
                if !om[key] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (sm StringMap) Includes(om StringMap) bool <span class="cov8" title="1">{
        if len(sm) &lt; len(om) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for key := range om </span><span class="cov8" title="1">{
                if !sm[key] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (sm StringMap) IsEmpty() bool <span class="cov8" title="1">{
        return len(sm) == 0 || sm[ANY]
}</span>

func StringMapFromSlice(s []string) StringMap <span class="cov8" title="1">{
        result := make(StringMap, len(s))
        for _, v := range s </span><span class="cov8" title="1">{
                v = strings.TrimSpace(v)
                if v != EmptyString </span><span class="cov8" title="1">{
                        if strings.HasPrefix(v, NegativePrefix) </span><span class="cov8" title="1">{
                                result[v[1:]] = false
                        }</span> else<span class="cov8" title="1"> {
                                result[v] = true
                        }</span>
                }
        }
        <span class="cov8" title="1">return result</span>
}

func (sm StringMap) Copy(o StringMap) <span class="cov8" title="1">{
        for k, v := range o </span><span class="cov8" title="1">{
                sm[k] = v
        }</span>
}

func (sm StringMap) Clone() StringMap <span class="cov8" title="1">{
        result := make(StringMap, len(sm))
        result.Copy(sm)
        return result
}</span>

func (sm StringMap) String() string <span class="cov8" title="1">{
        return strings.Join(sm.Slice(), INFIELD_SEP)
}</span>

func (sm StringMap) GetOne() string <span class="cov8" title="1">{
        for key := range sm </span><span class="cov8" title="1">{
                return key
        }</span>
        <span class="cov8" title="1">return EmptyString</span>
}

func (sm StringMap) Join(mps ...StringMap) <span class="cov8" title="1">{
        for _, mp := range mps </span><span class="cov8" title="1">{
                for k, v := range mp </span><span class="cov8" title="1">{
                        sm[k] = v
                }</span>
        }
}

func (sm StringMap) HasKey(key string) (has bool) <span class="cov8" title="1">{
        _, has = sm[key]
        return
}</span>

func (sm StringMap) Slice() []string <span class="cov8" title="1">{
        result := make([]string, len(sm))
        i := 0
        for k := range sm </span><span class="cov8" title="1">{
                result[i] = k
                i++
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Used to merge multiple maps (eg: output of struct having ExtraFields)
func MergeMapsStringIface(mps ...map[string]any) (outMp map[string]any) <span class="cov8" title="1">{
        outMp = make(map[string]any)
        for i, mp := range mps </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        outMp = mp
                        continue</span>
                }
                <span class="cov8" title="1">for k, v := range mp </span><span class="cov8" title="1">{
                        outMp[k] = v
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// FieldMultiplyFactor defines multiply factors for different field values
// original defined for CDRE component
type FieldMultiplyFactor map[string]float64

func (fmp FieldMultiplyFactor) Clone() (cln FieldMultiplyFactor) <span class="cov8" title="1">{
        cln = make(FieldMultiplyFactor, len(fmp))
        for k, v := range fmp </span><span class="cov8" title="1">{
                cln[k] = v
        }</span>
        <span class="cov8" title="1">return</span>
}

func MapStringToInt64(in map[string]string) (out map[string]int64, err error) <span class="cov8" title="1">{
        mapout := make(map[string]int64, len(in))
        for key, val := range in </span><span class="cov8" title="1">{
                x, err := strconv.Atoi(val)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">mapout[key] = int64(x)</span>
        }
        <span class="cov8" title="1">return mapout, nil</span>
}

// FlagsWithParamsFromSlice construct a  FlagsWithParams from the given slice
func FlagsWithParamsFromSlice(s []string) (FlagsWithParams, error) <span class="cov8" title="1">{
        result := make(FlagsWithParams, len(s))
        for _, v := range s </span><span class="cov8" title="1">{
                subsystemWithIDs := strings.Split(v, InInFieldSep)
                result[subsystemWithIDs[0]] = []string{}
                if len(subsystemWithIDs) == 2 </span><span class="cov8" title="1">{
                        result[subsystemWithIDs[0]] = strings.Split(subsystemWithIDs[1], INFIELD_SEP)
                }</span> else<span class="cov8" title="1"> if len(subsystemWithIDs) &gt; 2 </span><span class="cov8" title="1">{
                        return nil, ErrUnsupportedFormat
                }</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// FlagsWithParams should store a list of profiles for each subsystem
type FlagsWithParams map[string][]string

// HasKey returns if the key was mentioned in flags
func (fWp FlagsWithParams) HasKey(key string) (has bool) <span class="cov8" title="1">{
        _, has = fWp[key]
        return
}</span>

// ParamsSlice returns the list of profiles for the subsystem
func (fWp FlagsWithParams) ParamsSlice(subs string) (ps []string) <span class="cov8" title="1">{
        if psIfc, has := fWp[subs]; has </span><span class="cov8" title="1">{
                ps = psIfc
        }</span>
        <span class="cov8" title="1">return</span>
}

// ParamValue returns the value of the flag
func (fWp FlagsWithParams) ParamValue(subs string) (ps string) <span class="cov8" title="1">{
        for _, ps = range fWp[subs] </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

// SliceFlags converts from FlagsWithParams back to []string
func (fWp FlagsWithParams) SliceFlags() (sls []string) <span class="cov8" title="1">{
        for key := range fWp </span><span class="cov8" title="1">{
                if prmSlice := fWp.ParamsSlice(key); !reflect.DeepEqual(prmSlice, []string{}) </span><span class="cov8" title="1">{
                        sls = append(sls, ConcatenatedKey(key, strings.Join(prmSlice, INFIELD_SEP)))
                }</span> else<span class="cov8" title="1"> {
                        sls = append(sls, key)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// GetBool returns the flag as boolean
func (fWp FlagsWithParams) GetBool(key string) (b bool) <span class="cov8" title="1">{
        var v []string
        if v, b = fWp[key]; !b </span><span class="cov8" title="1">{
                return // not present means false
        }</span>
        <span class="cov8" title="1">if len(v) == 0 </span><span class="cov8" title="1">{
                return true // empty slice
        }</span>
        <span class="cov8" title="1">return v[0] == "true"</span> // check only the first element
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "errors"
        "fmt"
        "net"
        "reflect"
        "strings"
        "time"
)

// dataStorage is the DataProvider that can be updated
type dataStorage interface {
        DataProvider

        Set(fldPath []string, val any) error
        Remove(fldPath []string) error
        GetKeys(nesteed bool) []string
}

// MapStorage is the basic dataStorage
type MapStorage map[string]any

// String returns the map as json string
func (ms MapStorage) String() string <span class="cov8" title="1">{ return ToJSON(ms) }</span>

// FieldAsInterface returns the value from the path
func (ms MapStorage) FieldAsInterface(fldPath []string) (val any, err error) <span class="cov8" title="1">{
        if len(fldPath) == 0 </span><span class="cov0" title="0">{
                err = errors.New("empty field path")
                return

        }</span>
        <span class="cov8" title="1">opath, indx := GetPathIndex(fldPath[0])
        var has bool
        if val, has = ms[opath]; !has </span><span class="cov8" title="1">{
                err = ErrNotFound
                return
        }</span>
        <span class="cov8" title="1">if len(fldPath) == 1 </span><span class="cov8" title="1">{
                if indx == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">switch rv := val.(type) </span>{
                case []string:<span class="cov8" title="1">
                        if len(rv) &lt;= *indx </span><span class="cov0" title="0">{
                                return nil, ErrNotFound
                        }</span>
                        <span class="cov8" title="1">val = rv[*indx]
                        return</span>
                case []any:<span class="cov8" title="1">
                        if len(rv) &lt;= *indx </span><span class="cov0" title="0">{
                                return nil, ErrNotFound
                        }</span>
                        <span class="cov8" title="1">val = rv[*indx]
                        return</span>
                default:<span class="cov0" title="0"></span>
                }
                // only if all above fails use reflect:
                <span class="cov0" title="0">vr := reflect.ValueOf(val)
                if vr.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        vr = vr.Elem()
                }</span>
                <span class="cov0" title="0">if vr.Kind() != reflect.Slice &amp;&amp; vr.Kind() != reflect.Array </span><span class="cov0" title="0">{
                        return nil, ErrNotFound

                }</span>
                <span class="cov0" title="0">if *indx &gt;= vr.Len() </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return vr.Index(*indx).Interface(), nil</span>

        }
        <span class="cov8" title="1">if indx == nil </span><span class="cov8" title="1">{
                switch dp := ms[fldPath[0]].(type) </span>{
                case DataProvider:<span class="cov0" title="0">
                        return dp.FieldAsInterface(fldPath[1:])</span>
                case map[string]any:<span class="cov8" title="1">
                        return MapStorage(dp).FieldAsInterface(fldPath[1:])</span>
                default:<span class="cov8" title="1">
                        err = ErrWrongPath

                        return</span>
                }
        }
        <span class="cov8" title="1">switch dp := ms[opath].(type) </span>{
        case []DataProvider:<span class="cov0" title="0">
                if len(dp) &lt;= *indx </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return dp[*indx].FieldAsInterface(fldPath[1:])</span>
        case []MapStorage:<span class="cov0" title="0">
                if len(dp) &lt;= *indx </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return dp[*indx].FieldAsInterface(fldPath[1:])</span>
        case []map[string]any:<span class="cov8" title="1">
                if len(dp) &lt;= *indx </span><span class="cov0" title="0">{
                        return nil, ErrNotFound

                }</span>
                <span class="cov8" title="1">return MapStorage(dp[*indx]).FieldAsInterface(fldPath[1:])</span>
        case []any:<span class="cov0" title="0">
                if len(dp) &lt;= *indx </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">switch ds := dp[*indx].(type) </span>{
                case DataProvider:<span class="cov0" title="0">
                        return ds.FieldAsInterface(fldPath[1:])</span>
                case map[string]any:<span class="cov0" title="0">
                        return MapStorage(ds).FieldAsInterface(fldPath[1:])</span>
                default:<span class="cov0" title="0"></span>
                }
        default:<span class="cov8" title="1"></span>

        }
        <span class="cov8" title="1">err = ErrNotFound // xml compatible
        val = nil
        return</span>
}

// FieldAsString returns the value from path as string
func (ms MapStorage) FieldAsString(fldPath []string) (str string, err error) <span class="cov8" title="1">{
        var val any
        if val, err = ms.FieldAsInterface(fldPath); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return IfaceAsString(val), nil</span>
}

// Set sets the value at the given path
func (ms MapStorage) Set(fldPath []string, val any) (err error) <span class="cov8" title="1">{
        if len(fldPath) == 0 </span><span class="cov0" title="0">{
                return ErrWrongPath
        }</span>
        <span class="cov8" title="1">if len(fldPath) == 1 </span><span class="cov8" title="1">{
                ms[fldPath[0]] = val

                return
        }</span>

        <span class="cov8" title="1">if _, has := ms[fldPath[0]]; !has </span><span class="cov8" title="1">{
                nMap := MapStorage{}
                ms[fldPath[0]] = nMap
                return nMap.Set(fldPath[1:], val)
        }</span>
        <span class="cov8" title="1">switch dp := ms[fldPath[0]].(type) </span>{
        case dataStorage:<span class="cov8" title="1">
                return dp.Set(fldPath[1:], val)</span>
        case map[string]any:<span class="cov0" title="0">
                return MapStorage(dp).Set(fldPath[1:], val)</span>
        default:<span class="cov0" title="0">
                return ErrWrongPath</span>
        }

}

// GetKeys returns all the keys from map
func (ms MapStorage) GetKeys(nesteed bool) (keys []string) <span class="cov8" title="1">{
        if !nesteed </span><span class="cov0" title="0">{
                keys = make([]string, len(ms))
                i := 0
                for k := range ms </span><span class="cov0" title="0">{
                        keys[i] = k
                        i++

                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov8" title="1">for k, v := range ms </span><span class="cov8" title="1">{
                // keys = append(keys, k)
                switch rv := v.(type) </span>{
                case dataStorage:<span class="cov0" title="0">
                        for _, dsKey := range rv.GetKeys(nesteed) </span><span class="cov0" title="0">{
                                keys = append(keys, k+NestingSep+dsKey)
                        }</span>
                case map[string]any:<span class="cov8" title="1">
                        for _, dsKey := range MapStorage(rv).GetKeys(nesteed) </span><span class="cov8" title="1">{
                                keys = append(keys, k+NestingSep+dsKey)
                        }</span>
                case []MapStorage:<span class="cov0" title="0">
                        for i, dp := range rv </span><span class="cov0" title="0">{
                                pref := k + fmt.Sprintf("[%v]", i)
                                // keys = append(keys, pref)
                                for _, dsKey := range dp.GetKeys(nesteed) </span><span class="cov0" title="0">{
                                        keys = append(keys, pref+NestingSep+dsKey)
                                }</span>
                        }
                case []dataStorage:<span class="cov0" title="0">
                        for i, dp := range rv </span><span class="cov0" title="0">{
                                pref := k + fmt.Sprintf("[%v]", i)
                                // keys = append(keys, pref)
                                for _, dsKey := range dp.GetKeys(nesteed) </span><span class="cov0" title="0">{
                                        keys = append(keys, pref+NestingSep+dsKey)
                                }</span>
                        }
                case []map[string]any:<span class="cov0" title="0">
                        for i, dp := range rv </span><span class="cov0" title="0">{
                                pref := k + fmt.Sprintf("[%v]", i)
                                // keys = append(keys, pref)
                                for _, dsKey := range MapStorage(dp).GetKeys(nesteed) </span><span class="cov0" title="0">{
                                        keys = append(keys, pref+NestingSep+dsKey)
                                }</span>
                        }
                case []any:<span class="cov0" title="0">
                        for i := range rv </span><span class="cov0" title="0">{
                                keys = append(keys, k+fmt.Sprintf("[%v]", i))
                        }</span>
                case []string:<span class="cov8" title="1">
                        for i := range rv </span><span class="cov8" title="1">{
                                keys = append(keys, k+fmt.Sprintf("[%v]", i))
                        }</span>
                case nil, int, int32, int64, uint32, uint64, bool, float32, float64, []uint8, time.Duration, time.Time, string:<span class="cov8" title="1"> //no path
                        keys = append(keys, k)</span>
                default:<span class="cov8" title="1">
                        // ToDo:should not be called
                        keys = append(keys, getPathFromValue(reflect.ValueOf(v), k+NestingSep)...)</span>
                }

        }
        <span class="cov8" title="1">return</span>

}

// Remove removes the item at path
func (ms MapStorage) Remove(fldPath []string) (err error) <span class="cov0" title="0">{
        if len(fldPath) == 0 </span><span class="cov0" title="0">{
                return ErrWrongPath
        }</span>
        <span class="cov0" title="0">var val any
        var has bool
        if val, has = ms[fldPath[0]]; !has </span><span class="cov0" title="0">{
                return // ignore (already removed)
        }</span>
        <span class="cov0" title="0">if len(fldPath) == 1 </span><span class="cov0" title="0">{
                delete(ms, fldPath[0])

                return
        }</span>
        <span class="cov0" title="0">switch dp := val.(type) </span>{
        case dataStorage:<span class="cov0" title="0">
                return dp.Remove(fldPath[1:])</span>
        case map[string]any:<span class="cov0" title="0">
                return MapStorage(dp).Remove(fldPath[1:])</span>
        default:<span class="cov0" title="0">
                return ErrWrongPath</span>

        }

}

// RemoteHost is part of dataStorage interface
func (ms MapStorage) RemoteHost() net.Addr <span class="cov0" title="0">{
        return LocalAddr()
}</span>

// ToDo: remove the following functions
func getPathFromValue(in reflect.Value, prefix string) (out []string) <span class="cov8" title="1">{
        switch in.Kind() </span>{
        case reflect.Ptr:<span class="cov8" title="1">
                return getPathFromValue(in.Elem(), prefix)</span>
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                prefix = strings.TrimSuffix(prefix, NestingSep)
                for i := 0; i &lt; in.Len(); i++ </span><span class="cov0" title="0">{
                        pref := fmt.Sprintf("%s[%v]", prefix, i)
                        // out = append(out, pref)
                        out = append(out, getPathFromValue(in.Index(i), pref+NestingSep)...)
                }</span>
        case reflect.Map:<span class="cov0" title="0">
                iter := reflect.ValueOf(in).MapRange()
                for iter.Next() </span><span class="cov0" title="0">{
                        pref := prefix + iter.Key().String()
                        // out = append(out, pref)
                        out = append(out, getPathFromValue(iter.Value(), pref+NestingSep)...)
                }</span>
        case reflect.Struct:<span class="cov8" title="1">
                inType := in.Type()
                for i := 0; i &lt; in.NumField(); i++ </span><span class="cov8" title="1">{
                        pref := prefix + inType.Field(i).Name
                        // out = append(out, pref)
                        out = append(out, getPathFromValue(in.Field(i), pref+NestingSep)...)
                }</span>
        case reflect.Invalid, reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr, reflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128, reflect.String, reflect.Chan, reflect.Func, reflect.UnsafePointer, reflect.Interface:<span class="cov8" title="1">
                out = append(out, strings.TrimSuffix(prefix, NestingSep))</span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "net"
)

// NavigableMap2 is the basic map of NM interface
type NavigableMap2 map[string]NMInterface

func (nm NavigableMap2) String() (out string) <span class="cov8" title="1">{
        for k, v := range nm </span><span class="cov8" title="1">{
                out += ",\"" + k + "\":" + v.String()
        }</span>
        <span class="cov8" title="1">if len(out) == 0 </span><span class="cov8" title="1">{
                return "{}"
        }</span>
        <span class="cov8" title="1">out = out[1:]
        return "{" + out + "}"</span>
}

// Interface returns itself
func (nm NavigableMap2) Interface() any <span class="cov8" title="1">{
        return nm
}</span>

// Field returns the item on the given path
func (nm NavigableMap2) Field(path PathItems) (val NMInterface, err error) <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov8" title="1">{
                return nil, ErrWrongPath
        }</span>
        <span class="cov8" title="1">el, has := nm[path[0].Field]
        if !has </span><span class="cov8" title="1">{
                return nil, ErrNotFound
        }</span>
        <span class="cov8" title="1">if len(path) == 1 &amp;&amp; path[0].Index == nil </span><span class="cov8" title="1">{
                return el, nil
        }</span>
        <span class="cov8" title="1">switch el.Type() </span>{
        default:<span class="cov8" title="1">
                return nil, ErrNotFound</span>
        case NMMapType:<span class="cov8" title="1">
                if path[0].Index != nil </span><span class="cov8" title="1">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov8" title="1">return el.Field(path[1:])</span>
        case NMSliceType:<span class="cov8" title="1">
                return el.Field(path)</span>
        }
}

// Set sets the value for the given path
func (nm NavigableMap2) Set(path PathItems, val NMInterface) (added bool, err error) <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov8" title="1">{
                return false, ErrWrongPath
        }</span>
        <span class="cov8" title="1">nmItm, has := nm[path[0].Field]

        if path[0].Index != nil </span><span class="cov8" title="1">{ // has index, should be a slice which is kinda part of our map, hence separate handling
                if !has </span><span class="cov8" title="1">{
                        nmItm = &amp;NMSlice{}
                        if _, err = nmItm.Set(path, val); err != nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">nm[path[0].Field] = nmItm
                        added = true
                        return</span>
                }
                <span class="cov8" title="1">if nmItm.Type() != NMSliceType </span><span class="cov8" title="1">{
                        return false, ErrWrongPath
                }</span>
                <span class="cov8" title="1">return nmItm.Set(path, val)</span>
        }

        // standard handling
        <span class="cov8" title="1">if len(path) == 1 </span><span class="cov8" title="1">{ // always overwrite for single path
                nm[path[0].Field] = val
                if !has </span><span class="cov8" title="1">{
                        added = true
                }</span>
                <span class="cov8" title="1">return</span>
        }
        // from here we should deal only with navmaps due to multiple path
        <span class="cov8" title="1">if !has </span><span class="cov8" title="1">{
                nmItm = NavigableMap2{}
                nm[path[0].Field] = nmItm
        }</span>
        <span class="cov8" title="1">if nmItm.Type() != NMMapType </span><span class="cov8" title="1">{ // do not try to overwrite an interface
                return false, ErrWrongPath
        }</span>
        <span class="cov8" title="1">return nmItm.Set(path[1:], val)</span>
}

// Remove removes the item for the given path
func (nm NavigableMap2) Remove(path PathItems) (err error) <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov8" title="1">{
                return ErrWrongPath
        }</span>
        <span class="cov8" title="1">el, has := nm[path[0].Field]
        if !has </span><span class="cov8" title="1">{
                return // already removed
        }</span>
        <span class="cov8" title="1">if len(path) == 1 </span><span class="cov8" title="1">{
                if path[0].Index != nil </span><span class="cov8" title="1">{
                        if el.Type() != NMSliceType </span><span class="cov8" title="1">{
                                return ErrWrongPath
                        }</span>
                        // this should not return error
                        // but in case it does we propagate it further
                        <span class="cov8" title="1">err = el.Remove(path)
                        if el.Empty() </span><span class="cov8" title="1">{
                                delete(nm, path[0].Field)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }
                <span class="cov8" title="1">delete(nm, path[0].Field)
                return</span>
        }
        <span class="cov8" title="1">if path[0].Index != nil </span><span class="cov8" title="1">{
                if el.Type() != NMSliceType </span><span class="cov8" title="1">{
                        return ErrWrongPath
                }</span>
                <span class="cov8" title="1">if err = el.Remove(path); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if el.Empty() </span><span class="cov8" title="1">{
                        delete(nm, path[0].Field)
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">if el.Type() != NMMapType </span><span class="cov8" title="1">{
                return ErrWrongPath
        }</span>
        <span class="cov8" title="1">if err = el.Remove(path[1:]); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if el.Empty() </span><span class="cov8" title="1">{
                delete(nm, path[0].Field)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Type returns the type of the NM map
func (nm NavigableMap2) Type() NMType <span class="cov8" title="1">{
        return NMMapType
}</span>

// Empty returns true if the NM is empty(no data)
func (nm NavigableMap2) Empty() bool <span class="cov8" title="1">{
        return len(nm) == 0
}</span>

// Len returns the lenght of the map
func (nm NavigableMap2) Len() int <span class="cov8" title="1">{
        return len(nm)
}</span>

// FieldAsInterface returns the interface at the path
// Is used by AgentRequest FieldAsInterface
func (nm NavigableMap2) FieldAsInterface(fldPath []string) (str any, err error) <span class="cov8" title="1">{
        var nmi NMInterface
        if nmi, err = nm.Field(NewPathItems(fldPath)); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return nmi.Interface(), nil</span>
}

// FieldAsString returns the string at the path
// Used only to implement the DataProvider interface
func (nm NavigableMap2) FieldAsString(fldPath []string) (str string, err error) <span class="cov8" title="1">{
        var val any
        val, err = nm.FieldAsInterface(fldPath)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return IfaceAsString(val), nil</span>
}

// RemoteHost is part of dataStorage interface
func (NavigableMap2) RemoteHost() net.Addr <span class="cov8" title="1">{
        return LocalAddr()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

// NewNMData returns the interface wraped in NMInterface struture
func NewNMData(val any) *NMData <span class="cov8" title="1">{ return &amp;NMData{data: val} }</span>

// NMData most basic NM structure
type NMData struct{ data any }

func (nmi *NMData) String() string <span class="cov8" title="1">{
        return IfaceAsString(nmi.data)
}</span>

// Interface returns the wraped interface
func (nmi *NMData) Interface() any <span class="cov8" title="1">{
        return nmi.data
}</span>

// Field is not implemented only used in order to implement the NM interface
func (nmi *NMData) Field(path PathItems) (val NMInterface, err error) <span class="cov8" title="1">{
        return nil, ErrNotImplemented
}</span>

// Set sets the wraped interface when the path is empty
// This behaivior is in order to modify the wraped interface
// witout aserting the type of the NMInterface
func (nmi *NMData) Set(path PathItems, val NMInterface) (addedNew bool, err error) <span class="cov8" title="1">{
        if len(path) != 0 </span><span class="cov8" title="1">{
                return false, ErrWrongPath
        }</span>
        <span class="cov8" title="1">nmi.data = val.Interface()
        return</span>
}

// Remove is not implemented only used in order to implement the NM interface
func (nmi *NMData) Remove(path PathItems) (err error) <span class="cov8" title="1">{
        return ErrNotImplemented
}</span>

// Type returns the type of the NM interface
func (nmi *NMData) Type() NMType <span class="cov8" title="1">{
        return NMDataType
}</span>

// Empty returns true if the NM is empty(no data)
func (nmi *NMData) Empty() bool <span class="cov8" title="1">{
        return nmi == nil || nmi.data == nil
}</span>

// Len is not implemented only used in order to implement the NM interface
func (nmi *NMData) Len() int <span class="cov8" title="1">{
        return 0
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

// NMSlice is the basic slice of NM interface
type NMSlice []NMInterface

func (nms *NMSlice) String() (out string) <span class="cov8" title="1">{
        for _, v := range *nms </span><span class="cov8" title="1">{
                out += "," + v.String()
        }</span>
        <span class="cov8" title="1">if len(out) == 0 </span><span class="cov8" title="1">{
                return "[]"
        }</span>
        <span class="cov8" title="1">out = out[1:]
        return "[" + out + "]"</span>
}

// Interface returns itself
func (nms *NMSlice) Interface() any <span class="cov8" title="1">{
        return nms
}</span>

// Field returns the item on the given path
// for NMSlice only the Index field is considered
func (nms *NMSlice) Field(path PathItems) (val NMInterface, err error) <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov8" title="1">{
                return nil, ErrWrongPath
        }</span>
        <span class="cov8" title="1">if nms.Empty() || path[0].Index == nil </span><span class="cov8" title="1">{
                return nil, ErrNotFound
        }</span>
        <span class="cov8" title="1">idx := *path[0].Index
        if idx &lt; 0 </span><span class="cov8" title="1">{
                idx = len(*nms) + idx
        }</span>
        <span class="cov8" title="1">if idx &lt; 0 || idx &gt;= len(*nms) </span><span class="cov8" title="1">{
                return nil, ErrNotFound
        }</span>
        <span class="cov8" title="1">if len(path) == 1 </span><span class="cov8" title="1">{
                return (*nms)[idx], nil
        }</span>
        <span class="cov8" title="1">return (*nms)[idx].Field(path[1:])</span>
}

// Set sets the value for the given index
func (nms *NMSlice) Set(path PathItems, val NMInterface) (addedNew bool, err error) <span class="cov8" title="1">{
        if len(path) == 0 || path[0].Index == nil </span><span class="cov8" title="1">{
                return false, ErrWrongPath
        }</span>
        <span class="cov8" title="1">idx := *path[0].Index
        if idx == len(*nms) </span><span class="cov8" title="1">{ // append element
                addedNew = true
                if len(path) == 1 </span><span class="cov8" title="1">{
                        *nms = append(*nms, val)
                        return
                }</span>
                <span class="cov8" title="1">nel := NavigableMap2{}
                if _, err = nel.Set(path[1:], val); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">*nms = append(*nms, nel)
                return</span>
        }
        <span class="cov8" title="1">if idx &lt; 0 </span><span class="cov8" title="1">{
                idx = len(*nms) + idx
        }</span>
        <span class="cov8" title="1">if idx &lt; 0 || idx &gt;= len(*nms) </span><span class="cov8" title="1">{
                return false, ErrWrongPath
        }</span>
        <span class="cov8" title="1">path[0].Index = &amp;idx
        if len(path) == 1 </span><span class="cov8" title="1">{
                (*nms)[idx] = val
                return
        }</span>
        <span class="cov8" title="1">if (*nms)[idx].Type() == NMSliceType </span><span class="cov8" title="1">{
                return false, ErrWrongPath
        }</span>
        <span class="cov8" title="1">return (*nms)[idx].Set(path[1:], val)</span>
}

// Remove removes the item for the given index
func (nms *NMSlice) Remove(path PathItems) (err error) <span class="cov8" title="1">{
        if len(path) == 0 || path[0].Index == nil </span><span class="cov8" title="1">{
                return ErrWrongPath
        }</span>
        <span class="cov8" title="1">idx := *path[0].Index
        if idx &lt; 0 </span><span class="cov8" title="1">{
                idx = len(*nms) + idx
        }</span>
        <span class="cov8" title="1">if idx &lt; 0 || idx &gt;= len(*nms) </span><span class="cov8" title="1">{ // already removed
                return
        }</span>
        <span class="cov8" title="1">path[0].Index = &amp;idx
        if len(path) == 1 </span><span class="cov8" title="1">{
                *nms = append((*nms)[:idx], (*nms)[idx+1:]...)
                return
        }</span>
        <span class="cov8" title="1">if (*nms)[idx].Type() != NMMapType </span><span class="cov8" title="1">{
                return ErrWrongPath
        }</span>
        <span class="cov8" title="1">if err = (*nms)[idx].Remove(path[1:]); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if (*nms)[idx].Empty() </span><span class="cov8" title="1">{
                *nms = append((*nms)[:idx], (*nms)[idx+1:]...)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Type returns the type of the NM slice
func (nms NMSlice) Type() NMType <span class="cov8" title="1">{
        return NMSliceType
}</span>

// Empty returns true if the NM is empty(no data)
func (nms NMSlice) Empty() bool <span class="cov8" title="1">{
        return len(nms) == 0
}</span>

// Len returns the lenght of the slice
func (nms *NMSlice) Len() int <span class="cov8" title="1">{
        return len(*nms)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

// OrderedMap is a map that maintains the order of its key-value pairs.
type OrderedMap[K comparable, V any] struct {
        keys   []K     // keys holds the keys in order of their insertion.
        values map[K]V // values is a map of key-value pairs.
}

// NewOrderedMap creates a new ordered map and returns a pointer to it.
func NewOrderedMap[K comparable, V any]() *OrderedMap[K, V] <span class="cov8" title="1">{
        return &amp;OrderedMap[K, V]{
                keys:   make([]K, 0),  // Initialize an empty slice for keys.
                values: make(map[K]V), // Initialize an empty map for key-value pairs.
        }
}</span>

// Set adds a new key-value pair to the ordered map. If the key already exists, it updates the value.
func (om *OrderedMap[K, V]) Set(key K, value V) <span class="cov8" title="1">{
        // If the key does not exist in the map, append it to the keys slice.
        if _, exists := om.values[key]; !exists </span><span class="cov8" title="1">{
                om.keys = append(om.keys, key)
        }</span>
        // Add or update the value for the key in the map.
        <span class="cov8" title="1">om.values[key] = value</span>
}

// Get retrieves the value associated with the given key from the ordered map.
// It returns the value and a boolean indicating whether the key exists in the map.
func (om *OrderedMap[K, V]) Get(key K) (V, bool) <span class="cov8" title="1">{
        // Retrieve the value for the key from the map.
        val, ok := om.values[key]
        return val, ok
}</span>

// Delete removes the key-value pair associated with the given key from the ordered map.
func (om *OrderedMap[K, V]) Delete(key K) <span class="cov8" title="1">{
        // Iterate over the keys slice to find the key to delete.
        for i, k := range om.keys </span><span class="cov8" title="1">{
                // When the key is found, remove it from the slice.
                if k == key </span><span class="cov8" title="1">{
                        om.keys = append(om.keys[:i], om.keys[i+1:]...)
                        break</span>
                }
        }
        // Remove the key-value pair from the map.
        <span class="cov8" title="1">delete(om.values, key)</span>
}

// Keys returns all keys of the ordered map in order of their insertion.
func (om *OrderedMap[K, V]) Keys() []K <span class="cov8" title="1">{
        return om.keys
}</span>

// Values returns all values of the ordered map in the order of their corresponding keys' insertion.
func (om *OrderedMap[K, V]) Values() []V <span class="cov8" title="1">{
        // Initialize an empty slice to hold the values.
        vals := make([]V, 0, len(om.values))

        // Iterate over the keys in order and append the corresponding value to the values slice.
        for _, key := range om.keys </span><span class="cov8" title="1">{
                vals = append(vals, om.values[key])
        }</span>
        <span class="cov8" title="1">return vals</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "net"
        "strings"
)

// NewOrderedNavigableMap initializates a structure of OrderedNavigableMap with a NavigableMap2
func NewOrderedNavigableMap() *OrderedNavigableMap <span class="cov8" title="1">{
        return &amp;OrderedNavigableMap{
                nm:       NavigableMap2{},
                orderIdx: NewPathItemList(),
                orderRef: make(map[string][]*PathItemElement),
        }
}</span>

// OrderedNavigableMap is the same as NavigableMap2 but keeps the order of fields
type OrderedNavigableMap struct {
        nm       NMInterface
        orderIdx *PathItemList
        orderRef map[string][]*PathItemElement
}

// String returns the map as json string
func (onm *OrderedNavigableMap) String() string <span class="cov8" title="1">{
        return onm.nm.String()
}</span>

// GetFirstElement returns the first element from the order
func (onm *OrderedNavigableMap) GetFirstElement() *PathItemElement <span class="cov8" title="1">{
        return onm.orderIdx.Front()
}</span>

// Interface returns navigble map that's inside
func (onm *OrderedNavigableMap) Interface() any <span class="cov8" title="1">{
        return onm.nm
}</span>

// Field returns the item on the given path
func (onm *OrderedNavigableMap) Field(fldPath PathItems) (val NMInterface, err error) <span class="cov8" title="1">{
        return onm.nm.Field(fldPath)
}</span>

// Type returns the type of the NM map
func (onm *OrderedNavigableMap) Type() NMType <span class="cov8" title="1">{
        return onm.nm.Type()
}</span>

// Empty returns true if the NM is empty(no data)
func (onm *OrderedNavigableMap) Empty() bool <span class="cov8" title="1">{
        return onm.nm.Empty()
}</span>

// Remove removes the item for the given path and updates the order
func (onm *OrderedNavigableMap) Remove(fullPath *FullPath) (err error) <span class="cov8" title="1">{
        path := stripIdxFromLastPathElm(fullPath.Path)
        if path == EmptyString || fullPath.PathItems[len(fullPath.PathItems)-1].Index != nil </span><span class="cov8" title="1">{
                return ErrWrongPath
        }</span>
        <span class="cov8" title="1">if err = onm.nm.Remove(fullPath.PathItems); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">for idxPath, slcIdx := range onm.orderRef </span><span class="cov8" title="1">{
                if !strings.HasPrefix(idxPath, path) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, el := range slcIdx </span><span class="cov8" title="1">{
                        onm.orderIdx.Remove(el)
                }</span>
                <span class="cov8" title="1">delete(onm.orderRef, idxPath)</span>
        }
        <span class="cov8" title="1">return</span>
}

// Set sets the value at the given path
// this used with full path and the processed path to not calculate them for every set
func (onm *OrderedNavigableMap) Set(fullPath *FullPath, val NMInterface) (addedNew bool, err error) <span class="cov8" title="1">{
        if fullPath == nil || len(fullPath.PathItems) == 0 </span><span class="cov8" title="1">{
                return false, ErrWrongPath
        }</span>
        <span class="cov8" title="1">if addedNew, err = onm.nm.Set(fullPath.PathItems, val); err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">var pathItmsSet []PathItems // can be multiples if we need to inflate due to missing Index in slice set
        var nonIndexedSlcPath bool
        if val.Type() == NMSliceType &amp;&amp; fullPath.PathItems[len(fullPath.PathItems)-1].Index == nil </span><span class="cov8" title="1">{ // special case when we overwrite with a slice without specifying indexes
                nonIndexedSlcPath = true
                pathItmsSet = make([]PathItems, len(*val.(*NMSlice)))
                for i := 0; i &lt; val.Len(); i++ </span><span class="cov8" title="1">{
                        pathItms := fullPath.PathItems.Clone()
                        pathItms[len(pathItms)-1].Index = IntPointer(i)
                        pathItmsSet[i] = pathItms
                }</span>
        } else<span class="cov8" title="1"> {
                pathItmsSet = []PathItems{fullPath.PathItems}
        }</span>
        <span class="cov8" title="1">path := stripIdxFromLastPathElm(fullPath.Path)
        if !addedNew &amp;&amp; nonIndexedSlcPath </span><span class="cov8" title="1">{ // cleanup old references since the value is being overwritten
                for idxPath, slcIdx := range onm.orderRef </span><span class="cov8" title="1">{
                        if !strings.HasPrefix(idxPath, path) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">for _, el := range slcIdx </span><span class="cov8" title="1">{
                                onm.orderIdx.Remove(el)
                        }</span>
                        <span class="cov8" title="1">delete(onm.orderRef, idxPath)</span>
                }
        }
        <span class="cov8" title="1">_, hasRef := onm.orderRef[path]
        for _, pathItms := range pathItmsSet </span><span class="cov8" title="1">{
                if addedNew || !hasRef </span><span class="cov8" title="1">{
                        onm.orderRef[path] = append(onm.orderRef[path], onm.orderIdx.PushBack(pathItms))
                }</span> else<span class="cov8" title="1"> {
                        onm.orderIdx.MoveToBack(onm.orderRef[path][len(onm.orderRef[path])-1])
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// Len returns the lenght of the map
func (onm OrderedNavigableMap) Len() int <span class="cov8" title="1">{
        return onm.nm.Len()
}</span>

// FieldAsString returns thevalue from path as string
func (onm *OrderedNavigableMap) FieldAsString(fldPath []string) (str string, err error) <span class="cov8" title="1">{
        var val NMInterface
        val, err = onm.nm.Field(NewPathItems(fldPath))
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return IfaceAsString(val.Interface()), nil</span>
}

// FieldAsInterface returns the interface at the path
func (onm *OrderedNavigableMap) FieldAsInterface(fldPath []string) (str any, err error) <span class="cov8" title="1">{
        var val NMInterface
        val, err = onm.nm.Field(NewPathItems(fldPath))
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return val.Interface(), nil</span>
}

// RemoteHost is part of dataStorage interface
func (OrderedNavigableMap) RemoteHost() net.Addr <span class="cov8" title="1">{
        return LocalAddr()
}</span>

// GetOrder returns the elements order as a slice
// use this only for testing
func (onm *OrderedNavigableMap) GetOrder() (order []PathItems) <span class="cov8" title="1">{
        for el := onm.GetFirstElement(); el != nil; el = el.Next() </span><span class="cov8" title="1">{
                order = append(order, el.Value)
        }</span>
        <span class="cov8" title="1">return</span>
}

// RemoveAll will clean the data and the odrder from OrderedNavigableMap
func (onm *OrderedNavigableMap) RemoveAll() <span class="cov0" title="0">{
        onm.nm = NavigableMap2{}
        onm.orderIdx = NewPathItemList()
        onm.orderRef = make(map[string][]*PathItemElement)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "strconv"
        "strings"
)

// stripIdxFromLastPathElm will remove the index from the last path element
func stripIdxFromLastPathElm(path string) string <span class="cov8" title="1">{
        lastDotIdx := strings.LastIndexByte(path, '.')
        lastIdxStart := strings.LastIndexByte(path, '[')
        if lastIdxStart == -1 ||
                (lastDotIdx != -1 &amp;&amp; lastDotIdx &gt; lastIdxStart) </span><span class="cov8" title="1">{
                return path
        }</span>
        <span class="cov8" title="1">return path[:lastIdxStart]</span>
}

// FullPath is the path to the item with all the needed fields
type FullPath struct {
        PathItems PathItems
        Path      string
}

// NewPathItems returns the computed PathItems out of slice one
func NewPathItems(path []string) (pItms PathItems) <span class="cov8" title="1">{
        pItms = make(PathItems, len(path))
        for i, v := range path </span><span class="cov8" title="1">{
                field, indx := GetPathIndex(v)
                pItms[i] = PathItem{
                        Field: field,
                        Index: indx,
                }
        }</span>
        <span class="cov8" title="1">return</span>
}

// PathItems a list of PathItem used to describe the path to an item from a NavigableMap
type PathItems []PathItem

// Clone creates a copy
func (path PathItems) Clone() (c PathItems) <span class="cov8" title="1">{
        if path == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">c = make(PathItems, len(path))
        for i, v := range path </span><span class="cov8" title="1">{
                c[i] = v.Clone()
        }</span>
        <span class="cov8" title="1">return</span>
}

func (path PathItems) String() (out string) <span class="cov8" title="1">{
        for _, v := range path </span><span class="cov8" title="1">{
                out += NestingSep + v.String()
        }</span>
        <span class="cov8" title="1">if out == "" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return out[1:]</span>

}

// PathItem used by the NM interface to store the path information
type PathItem struct {
        Field string
        Index *int
}

// Equal returns true if p==p2
func (p PathItem) Equal(p2 PathItem) bool <span class="cov8" title="1">{
        if p.Field != p2.Field </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if p.Index == nil &amp;&amp; p2.Index == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if p.Index != nil &amp;&amp; p2.Index != nil </span><span class="cov8" title="1">{
                return *p.Index == *p2.Index
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (p PathItem) String() (out string) <span class="cov8" title="1">{
        out = p.Field
        if p.Index != nil </span><span class="cov8" title="1">{
                out += IdxStart + strconv.Itoa(*p.Index) + IdxEnd
        }</span>
        <span class="cov8" title="1">return</span>
}

// Clone creates a copy
func (p PathItem) Clone() (c PathItem) <span class="cov8" title="1">{
        // if p == nil {
        //         return
        // }
        c.Field = p.Field
        if p.Index != nil </span><span class="cov8" title="1">{
                c.Index = IntPointer(*p.Index)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetPathIndex returns the path and index if index present
// path[index]=&gt;path,index
// path=&gt;path,nil
func GetPathIndex(spath string) (opath string, idx *int) <span class="cov8" title="1">{
        idxStart := strings.Index(spath, IdxStart)
        if idxStart == -1 || !strings.HasSuffix(spath, IdxEnd) </span><span class="cov8" title="1">{
                return spath, nil
        }</span>
        <span class="cov8" title="1">slctr := spath[idxStart+1 : len(spath)-1]
        opath = spath[:idxStart]
        // if strings.HasPrefix(slctr, DynamicDataPrefix) {
        //         return
        // }
        idxVal, err := strconv.Atoi(slctr)
        if err != nil </span><span class="cov0" title="0">{
                return spath, nil
        }</span>
        <span class="cov8" title="1">return opath, &amp;idxVal</span>
}

func GetPathWithoutIndex(spath string) (opath string) <span class="cov0" title="0">{
        idxStart := strings.LastIndex(spath, IdxStart)
        if idxStart == -1 || !strings.HasSuffix(spath, IdxEnd) </span><span class="cov0" title="0">{
                return spath
        }</span>
        <span class="cov0" title="0">opath = spath[:idxStart]
        return</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

// PathItemElement is an element of a linked list.
// Inspired by Go's double linked list
type PathItemElement struct {
        // Next and previous pointers in the doubly-linked list of elements.
        // To simplify the implementation, internally a list l is implemented
        // as a ring, such that &amp;l.root is both the next element of the last
        // list element (l.Back()) and the previous element of the first list
        // element (l.Front()).
        next, prev *PathItemElement

        // The list to which this element belongs.
        list *PathItemList

        // The value stored with this element.
        Value PathItems
}

// Next returns the next list element or nil.
func (e *PathItemElement) Next() *PathItemElement <span class="cov8" title="1">{
        if p := e.next; e.list != nil &amp;&amp; p != &amp;e.list.root </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Prev returns the previous list element or nil.
func (e *PathItemElement) Prev() *PathItemElement <span class="cov0" title="0">{
        if p := e.prev; e.list != nil &amp;&amp; p != &amp;e.list.root </span><span class="cov0" title="0">{
                return p
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PathItemList represents a doubly linked list.
// The zero value for PathItemList is an empty list ready to use.
type PathItemList struct {
        root PathItemElement // sentinel list element, only &amp;root, root.prev, and root.next are used
        len  int             // current list length excluding (this) sentinel element
}

// Init initializes or clears list l.
func (l *PathItemList) Init() *PathItemList <span class="cov8" title="1">{
        l.root.next = &amp;l.root
        l.root.prev = &amp;l.root
        l.len = 0
        return l
}</span>

// NewPathItemList returns an initialized list.
func NewPathItemList() *PathItemList <span class="cov8" title="1">{ return new(PathItemList).Init() }</span>

// Len returns the number of elements of list l.
// The complexity is O(1).
func (l *PathItemList) Len() int <span class="cov0" title="0">{ return l.len }</span>

// Front returns the first element of list l or nil if the list is empty.
func (l *PathItemList) Front() *PathItemElement <span class="cov8" title="1">{
        if l.len == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return l.root.next</span>
}

// Back returns the last element of list l or nil if the list is empty.
func (l *PathItemList) Back() *PathItemElement <span class="cov0" title="0">{
        if l.len == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return l.root.prev</span>
}

// lazyInit lazily initializes a zero PathItemList value.
func (l *PathItemList) lazyInit() <span class="cov8" title="1">{
        if l.root.next == nil </span><span class="cov0" title="0">{
                l.Init()
        }</span>
}

// insert inserts e after at, increments l.len, and returns e.
func (l *PathItemList) insert(e, at *PathItemElement) *PathItemElement <span class="cov8" title="1">{
        n := at.next
        at.next = e
        e.prev = at
        e.next = n
        n.prev = e
        e.list = l
        l.len++
        return e
}</span>

// insertValue is a convenience wrapper for insert(&amp;PathItemElement{Value: v}, at).
func (l *PathItemList) insertValue(v PathItems, at *PathItemElement) *PathItemElement <span class="cov8" title="1">{
        return l.insert(&amp;PathItemElement{Value: v}, at)
}</span>

// remove removes e from its list, decrements l.len, and returns e.
func (l *PathItemList) remove(e *PathItemElement) *PathItemElement <span class="cov8" title="1">{
        e.prev.next = e.next
        e.next.prev = e.prev
        e.next = nil // avoid memory leaks
        e.prev = nil // avoid memory leaks
        e.list = nil
        l.len--
        return e
}</span>

// move moves e to next to at and returns e.
func (l *PathItemList) move(e, at *PathItemElement) *PathItemElement <span class="cov8" title="1">{
        if e == at </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">e.prev.next = e.next
        e.next.prev = e.prev

        n := at.next
        at.next = e
        e.prev = at
        e.next = n
        n.prev = e

        return e</span>
}

// Remove removes e from l if e is an element of list l.
// It returns the element value e.Value.
// The element must not be nil.
func (l *PathItemList) Remove(e *PathItemElement) PathItems <span class="cov8" title="1">{
        if e.list == l </span><span class="cov8" title="1">{
                // if e.list == l, l must have been initialized when e was inserted
                // in l or l == nil (e is a zero PathItemElement) and l.remove will crash
                l.remove(e)
        }</span>
        <span class="cov8" title="1">return e.Value</span>
}

// PushFront inserts a new element e with value v at the front of list l and returns e.
func (l *PathItemList) PushFront(v PathItems) *PathItemElement <span class="cov0" title="0">{
        l.lazyInit()
        return l.insertValue(v, &amp;l.root)
}</span>

// PushBack inserts a new element e with value v at the back of list l and returns e.
func (l *PathItemList) PushBack(v PathItems) *PathItemElement <span class="cov8" title="1">{
        l.lazyInit()
        return l.insertValue(v, l.root.prev)
}</span>

// InsertBefore inserts a new element e with value v immediately before mark and returns e.
// If mark is not an element of l, the list is not modified.
// The mark must not be nil.
func (l *PathItemList) InsertBefore(v PathItems, mark *PathItemElement) *PathItemElement <span class="cov0" title="0">{
        if mark.list != l </span><span class="cov0" title="0">{
                return nil
        }</span>
        // see comment in PathItemList.Remove about initialization of l
        <span class="cov0" title="0">return l.insertValue(v, mark.prev)</span>
}

// InsertAfter inserts a new element e with value v immediately after mark and returns e.
// If mark is not an element of l, the list is not modified.
// The mark must not be nil.
func (l *PathItemList) InsertAfter(v PathItems, mark *PathItemElement) *PathItemElement <span class="cov0" title="0">{
        if mark.list != l </span><span class="cov0" title="0">{
                return nil
        }</span>
        // see comment in PathItemList.Remove about initialization of l
        <span class="cov0" title="0">return l.insertValue(v, mark)</span>
}

// MoveToFront moves element e to the front of list l.
// If e is not an element of l, the list is not modified.
// The element must not be nil.
func (l *PathItemList) MoveToFront(e *PathItemElement) <span class="cov0" title="0">{
        if e.list != l || l.root.next == e </span><span class="cov0" title="0">{
                return
        }</span>
        // see comment in PathItemList.Remove about initialization of l
        <span class="cov0" title="0">l.move(e, &amp;l.root)</span>
}

// MoveToBack moves element e to the back of list l.
// If e is not an element of l, the list is not modified.
// The element must not be nil.
func (l *PathItemList) MoveToBack(e *PathItemElement) <span class="cov8" title="1">{
        if e.list != l || l.root.prev == e </span><span class="cov8" title="1">{
                return
        }</span>
        // see comment in PathItemList.Remove about initialization of l
        <span class="cov8" title="1">l.move(e, l.root.prev)</span>
}

// MoveBefore moves element e to its new position before mark.
// If e or mark is not an element of l, or e == mark, the list is not modified.
// The element and mark must not be nil.
func (l *PathItemList) MoveBefore(e, mark *PathItemElement) <span class="cov0" title="0">{
        if e.list != l || e == mark || mark.list != l </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">l.move(e, mark.prev)</span>
}

// MoveAfter moves element e to its new position after mark.
// If e or mark is not an element of l, or e == mark, the list is not modified.
// The element and mark must not be nil.
func (l *PathItemList) MoveAfter(e, mark *PathItemElement) <span class="cov0" title="0">{
        if e.list != l || e == mark || mark.list != l </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">l.move(e, mark)</span>
}

// PushBackList inserts a copy of an other list at the back of list l.
// The lists l and other may be the same. They must not be nil.
func (l *PathItemList) PushBackList(other *PathItemList) <span class="cov0" title="0">{
        l.lazyInit()
        for i, e := other.Len(), other.Front(); i &gt; 0; i, e = i-1, e.Next() </span><span class="cov0" title="0">{
                l.insertValue(e.Value, l.root.prev)
        }</span>
}

// PushFrontList inserts a copy of an other list at the front of list l.
// The lists l and other may be the same. They must not be nil.
func (l *PathItemList) PushFrontList(other *PathItemList) <span class="cov0" title="0">{
        l.lazyInit()
        for i, e := other.Len(), other.Back(); i &gt; 0; i, e = i-1, e.Prev() </span><span class="cov0" title="0">{
                l.insertValue(e.Value, &amp;l.root)
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "errors"
        "fmt"
        "net"
        "reflect"
        "strconv"
        "time"
)

// StringToInterface will parse string into supported types
// if no other conversion possible, original string will be returned
func StringToInterface(s string) any <span class="cov8" title="1">{
        // int64
        if i, err := strconv.ParseInt(s, 10, 64); err == nil </span><span class="cov8" title="1">{
                return i
        }</span>
        // bool
        <span class="cov8" title="1">if b, err := strconv.ParseBool(s); err == nil </span><span class="cov8" title="1">{
                return b
        }</span>
        // float64
        <span class="cov8" title="1">if f, err := strconv.ParseFloat(s, 64); err == nil </span><span class="cov8" title="1">{
                return f
        }</span>
        // time.Time
        <span class="cov8" title="1">if t, err := ParseTimeDetectLayout(s, "Local"); err == nil </span><span class="cov8" title="1">{
                return t
        }</span>
        // time.Duration
        <span class="cov8" title="1">if d, err := time.ParseDuration(s); err == nil </span><span class="cov8" title="1">{
                return d
        }</span>
        // string
        <span class="cov8" title="1">return s</span>
}

// ReflectFieldInterface parses intf attepting to return the field value or error otherwise
// Supports "ExtraFields" where additional fields are dynamically inserted in map with field name: extraFieldsLabel
func ReflectFieldInterface(intf any, fldName, extraFieldsLabel string) (retIf any, err error) <span class="cov8" title="1">{
        v := reflect.ValueOf(intf)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">var field reflect.Value
        switch v.Kind() </span>{
        case reflect.Struct:<span class="cov8" title="1">
                field = v.FieldByName(fldName)</span>
        case reflect.Map:<span class="cov8" title="1">
                field = v.MapIndex(reflect.ValueOf(fldName))
                if !field.IsValid() </span><span class="cov0" title="0">{ // Not looking in extra fields anymore
                        return nil, ErrNotFound
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("Unsupported field kind: %v", v.Kind())</span>
        }

        <span class="cov8" title="1">if !field.IsValid() </span><span class="cov8" title="1">{
                if extraFieldsLabel == "" </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov8" title="1">mpVal := v.FieldByName(extraFieldsLabel)
                if !mpVal.IsValid() || mpVal.Kind() != reflect.Map </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov8" title="1">field = mpVal.MapIndex(reflect.ValueOf(fldName))
                if !field.IsValid() </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
        }
        <span class="cov8" title="1">return field.Interface(), nil</span>
}

// ReflectFieldAsString parses intf and attepting to return the field as string or error otherwise
// Supports "ExtraFields" where additional fields are dynamically inserted in map with field name: extraFieldsLabel
func ReflectFieldAsString(intf any, fldName, extraFieldsLabel string) (string, error) <span class="cov8" title="1">{
        field, err := ReflectFieldInterface(intf, fldName, extraFieldsLabel)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">vOf := reflect.ValueOf(field)
        switch vOf.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                return vOf.String(), nil</span>
        case reflect.Int, reflect.Int64:<span class="cov8" title="1">
                return strconv.FormatInt(vOf.Int(), 10), nil</span>
        case reflect.Float64:<span class="cov8" title="1">
                return strconv.FormatFloat(vOf.Float(), 'f', -1, 64), nil</span>
        case reflect.Interface:<span class="cov0" title="0">
                return IfaceAsString(field), nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("Cannot convert to string field type: %s", vOf.Kind().String())</span>
        }
}

func IfaceAsTime(itm any, timezone string) (t time.Time, err error) <span class="cov8" title="1">{
        switch val := itm.(type) </span>{
        case time.Time:<span class="cov8" title="1">
                return val, nil</span>
        case string:<span class="cov8" title="1">
                return ParseTimeDetectLayout(val, timezone)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("cannot convert field: %+v to time.Time", itm)</span>
        }
        <span class="cov0" title="0">return</span>
}

func IfaceAsDuration(itm any) (d time.Duration, err error) <span class="cov8" title="1">{
        switch it := itm.(type) </span>{
        case time.Duration:<span class="cov8" title="1">
                return it, nil</span>
        case int:<span class="cov8" title="1"> // check every int type
                return time.Duration(int64(it)), nil</span>
        case int8:<span class="cov0" title="0">
                return time.Duration(int64(it)), nil</span>
        case int16:<span class="cov0" title="0">
                return time.Duration(int64(it)), nil</span>
        case int32:<span class="cov0" title="0">
                return time.Duration(int64(it)), nil</span>
        case int64:<span class="cov8" title="1">
                return time.Duration(it), nil</span>
        case uint:<span class="cov0" title="0">
                return time.Duration(int64(it)), nil</span>
        case uint8:<span class="cov0" title="0">
                return time.Duration(int64(it)), nil</span>
        case uint16:<span class="cov0" title="0">
                return time.Duration(int64(it)), nil</span>
        case uint32:<span class="cov0" title="0">
                return time.Duration(int64(it)), nil</span>
        case uint64:<span class="cov0" title="0">
                return time.Duration(int64(it)), nil</span>
        case float32:<span class="cov0" title="0"> // automatically hitting here also ints
                return time.Duration(int64(it)), nil</span>
        case float64:<span class="cov8" title="1"> // automatically hitting here also ints
                return time.Duration(int64(it)), nil</span>
        case string:<span class="cov8" title="1">
                return ParseDurationWithNanosecs(it)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("cannot convert field: %+v to time.Duration", it)</span>
        }
        <span class="cov0" title="0">return</span>
}

func IfaceAsInt64(itm any) (i int64, err error) <span class="cov8" title="1">{
        switch it := itm.(type) </span>{
        case int:<span class="cov8" title="1">
                return int64(it), nil</span>
        case time.Duration:<span class="cov8" title="1">
                return it.Nanoseconds(), nil</span>
        case int32:<span class="cov0" title="0">
                return int64(it), nil</span>
        case int64:<span class="cov8" title="1">
                return it, nil</span>
        case string:<span class="cov8" title="1">
                return strconv.ParseInt(it, 10, 64)</span>
        default:<span class="cov8" title="1">
                err = fmt.Errorf("cannot convert field: %+v to int", it)</span>
        }
        <span class="cov8" title="1">return</span>
}

// same function as IfaceAsInt64 but if the value is float round it to int64 instead of returning error
func IfaceAsTInt64(itm any) (i int64, err error) <span class="cov8" title="1">{
        switch it := itm.(type) </span>{
        case int:<span class="cov8" title="1">
                return int64(it), nil</span>
        case time.Duration:<span class="cov8" title="1">
                return it.Nanoseconds(), nil</span>
        case int32:<span class="cov8" title="1">
                return int64(it), nil</span>
        case int64:<span class="cov8" title="1">
                return it, nil</span>
        case float32:<span class="cov8" title="1">
                return int64(it), nil</span>
        case float64:<span class="cov8" title="1">
                return int64(it), nil</span>
        case string:<span class="cov8" title="1">
                return strconv.ParseInt(it, 10, 64)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("cannot convert field&lt;%T&gt;: %+v to int", it, it)</span>
        }
        <span class="cov0" title="0">return</span>
}

func IfaceAsFloat64(itm any) (f float64, err error) <span class="cov8" title="1">{
        switch it := itm.(type) </span>{
        case float64:<span class="cov8" title="1">
                return it, nil</span>
        case time.Duration:<span class="cov8" title="1">
                return float64(it.Nanoseconds()), nil</span>
        case int:<span class="cov8" title="1">
                return float64(it), nil</span>
        case int64:<span class="cov8" title="1">
                return float64(it), nil</span>
        case string:<span class="cov8" title="1">
                return strconv.ParseFloat(it, 64)</span>
        default:<span class="cov8" title="1">
                err = fmt.Errorf("cannot convert field: %+v to float64", it)</span>
        }
        <span class="cov8" title="1">return</span>
}

func IfaceAsBool(itm any) (b bool, err error) <span class="cov8" title="1">{
        switch val := itm.(type) </span>{
        case bool:<span class="cov8" title="1">
                return val, nil</span>
        case string:<span class="cov8" title="1">
                return strconv.ParseBool(val)</span>
        case int:<span class="cov8" title="1">
                return val &gt; 0, nil</span>
        case int64:<span class="cov0" title="0">
                return val &gt; 0, nil</span>
        case float64:<span class="cov8" title="1">
                return val &gt; 0, nil</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("cannot convert field: %+v to bool", itm)</span>
        }
        <span class="cov0" title="0">return</span>
}

func IfaceAsString(fld any) (out string) <span class="cov8" title="1">{
        switch value := fld.(type) </span>{
        case nil:<span class="cov8" title="1">
                return</span>
        case int:<span class="cov8" title="1">
                return strconv.Itoa(value)</span>
        case int32:<span class="cov0" title="0">
                return strconv.FormatInt(int64(value), 10)</span>
        case int64:<span class="cov0" title="0">
                return strconv.FormatInt(value, 10)</span>
        case uint32:<span class="cov0" title="0">
                return strconv.FormatUint(uint64(value), 10)</span>
        case uint64:<span class="cov0" title="0">
                return strconv.FormatUint(value, 10)</span>
        case bool:<span class="cov8" title="1">
                return strconv.FormatBool(value)</span>
        case float32:<span class="cov0" title="0">
                return strconv.FormatFloat(float64(value), 'f', -1, 64)</span>
        case float64:<span class="cov8" title="1">
                return strconv.FormatFloat(value, 'f', -1, 64)</span>
        case []uint8:<span class="cov8" title="1">
                return string(value)</span> // byte is an alias for uint8 conversions implicit
        case time.Duration:<span class="cov8" title="1">
                return value.String()</span>
        case time.Time:<span class="cov8" title="1">
                return value.Format(time.RFC3339)</span>
        case net.IP:<span class="cov8" title="1">
                return value.String()</span>
        case string:<span class="cov8" title="1">
                return value</span>
        case NMInterface:<span class="cov0" title="0">
                return value.String()</span>
        default:<span class="cov0" title="0"> // Maybe we are lucky and the value converts to string
                return ToJSON(fld)</span>
        }
}

// IfaceAsSliceString is trying to convert the interface to a slice of strings
func IfaceAsSliceString(fld any) (out []string, err error) <span class="cov8" title="1">{
        switch value := fld.(type) </span>{
        case nil:<span class="cov8" title="1">
                return</span>
        case []int:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = strconv.Itoa(val)
                }</span>
        case []int32:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = strconv.FormatInt(int64(val), 10)
                }</span>
        case []int64:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = strconv.FormatInt(val, 10)
                }</span>
        case []uint:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = strconv.FormatUint(uint64(val), 10)
                }</span>
        case []uint32:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = strconv.FormatUint(uint64(val), 10)
                }</span>
        case []uint64:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = strconv.FormatUint(val, 10)
                }</span>
        case []bool:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = strconv.FormatBool(val)
                }</span>
        case []float32:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = strconv.FormatFloat(float64(val), 'f', -1, 64)
                }</span>
        case []float64:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = strconv.FormatFloat(val, 'f', -1, 64)
                }</span>
        case [][]uint8:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = string(val) // byte is an alias for uint8 conversions implicit
                }</span>
        case []time.Duration:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = val.String()
                }</span>
        case []time.Time:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = val.Format(time.RFC3339)
                }</span>
        case []net.IP:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = val.String()
                }</span>
        case []string:<span class="cov8" title="1">
                out = value</span>
        case []any:<span class="cov8" title="1">
                out = make([]string, len(value))
                for i, val := range value </span><span class="cov8" title="1">{
                        out[i] = IfaceAsString(val)
                }</span>
        default:<span class="cov8" title="1">
                err = fmt.Errorf("cannot convert field: %T to []string", value)</span>
        }
        <span class="cov8" title="1">return</span>
}

// AsMapStringIface converts an item (mostly struct) as map[string]any
func AsMapStringIface(item any) (map[string]any, error) <span class="cov8" title="1">{
        out := make(map[string]any)
        v := reflect.ValueOf(item)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">if v.Kind() != reflect.Struct </span><span class="cov0" title="0">{ // Only structs for now
                return nil, fmt.Errorf("AsMapStringIface only accepts structs; got %T", v)
        }</span>
        <span class="cov8" title="1">typ := v.Type()
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                out[typ.Field(i).Name] = v.Field(i).Interface()
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func GetUniformType(item any) (any, error) <span class="cov8" title="1">{
        valItm := reflect.ValueOf(item)
        switch valItm.Kind() </span>{ // convert evreting to float64
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return float64(valItm.Int()), nil</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                return float64(valItm.Uint()), nil</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return valItm.Float(), nil</span>
        case reflect.Struct:<span class="cov8" title="1"> // used only for time
                return valItm.Interface(), nil</span>
        default:<span class="cov8" title="1">
                return nil, errors.New("incomparable")</span>
        }
        <span class="cov0" title="0">return item, nil</span>
}

func GetBasicType(item any) any <span class="cov8" title="1">{
        valItm := reflect.ValueOf(item)
        switch valItm.Kind() </span>{ // convert evreting to float64
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return valItm.Int()</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return valItm.Uint()</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return valItm.Float()</span>
        default:<span class="cov8" title="1">
                return item</span>
        }
        <span class="cov0" title="0">return item</span>
}

// GreaterThan attempts to compare two items
// returns the result or error if not comparable
func GreaterThan(item, oItem any, orEqual bool) (gte bool, err error) <span class="cov8" title="1">{
        item = GetBasicType(item)
        oItem = GetBasicType(oItem)
        typItem := reflect.TypeOf(item)
        typOItem := reflect.TypeOf(oItem)
        if typItem != typOItem </span><span class="cov8" title="1">{
                if item, err = GetUniformType(item); err == nil </span><span class="cov8" title="1">{ // overwrite type only if possible
                        typItem = reflect.TypeOf(item)
                }</span>
                <span class="cov8" title="1">if oItem, err = GetUniformType(oItem); err == nil </span><span class="cov8" title="1">{
                        typOItem = reflect.TypeOf(oItem)
                }</span>
        }
        <span class="cov8" title="1">if !typItem.Comparable() ||
                !typOItem.Comparable() ||
                typItem != typOItem </span><span class="cov8" title="1">{
                return false, fmt.Errorf("incomparable: &lt;%+v&gt; with &lt;%+v&gt;", item, oItem)
        }</span>
        <span class="cov8" title="1">switch tVal := item.(type) </span>{
        case float64:<span class="cov8" title="1">
                tOVal := oItem.(float64)
                if orEqual </span><span class="cov8" title="1">{
                        gte = tVal &gt;= tOVal
                }</span> else<span class="cov8" title="1"> {
                        gte = tVal &gt; tOVal
                }</span>
        case uint64:<span class="cov0" title="0">
                tOVal := oItem.(uint64)
                if orEqual </span><span class="cov0" title="0">{
                        gte = tVal &gt;= tOVal
                }</span> else<span class="cov0" title="0"> {
                        gte = tVal &gt; tOVal
                }</span>
        case int64:<span class="cov8" title="1">
                tOVal := oItem.(int64)
                if orEqual </span><span class="cov8" title="1">{
                        gte = tVal &gt;= tOVal
                }</span> else<span class="cov8" title="1"> {
                        gte = tVal &gt; tOVal
                }</span>
        case time.Time:<span class="cov8" title="1">
                tOVal := oItem.(time.Time)
                if orEqual </span><span class="cov8" title="1">{
                        gte = tVal == tOVal
                }</span>
                <span class="cov8" title="1">if !gte </span><span class="cov8" title="1">{
                        gte = tVal.After(tOVal)
                }</span>
        default:<span class="cov0" title="0"> // unsupported comparison
                err = fmt.Errorf("unsupported comparison type: %v, kind: %v", typItem, typItem.Kind())</span>
        }
        <span class="cov8" title="1">return</span>
}

func EqualTo(item, oItem any) (eq bool, err error) <span class="cov8" title="1">{
        item = GetBasicType(item)
        oItem = GetBasicType(oItem)
        typItem := reflect.TypeOf(item)
        typOItem := reflect.TypeOf(oItem)
        if typItem != typOItem </span><span class="cov8" title="1">{
                if item, err = GetUniformType(item); err == nil </span><span class="cov8" title="1">{ // overwrite type only if possible
                        typItem = reflect.TypeOf(item)
                }</span>
                <span class="cov8" title="1">if oItem, err = GetUniformType(oItem); err == nil </span><span class="cov8" title="1">{
                        typOItem = reflect.TypeOf(oItem)
                }</span>
        }
        <span class="cov8" title="1">if !typItem.Comparable() ||
                !typOItem.Comparable() ||
                typItem != typOItem </span><span class="cov8" title="1">{
                return false, fmt.Errorf("incomparable: &lt;%+v&gt; with &lt;%+v&gt;", item, oItem)
        }</span>
        <span class="cov8" title="1">switch tVal := item.(type) </span>{
        case float64:<span class="cov8" title="1">
                tOVal := oItem.(float64)
                eq = tVal == tOVal</span>
        case uint64:<span class="cov0" title="0">
                tOVal := oItem.(uint64)
                eq = tVal == tOVal</span>
        case int64:<span class="cov8" title="1">
                tOVal := oItem.(int64)
                eq = tVal == tOVal</span>
        case time.Time:<span class="cov8" title="1">
                tOVal := oItem.(time.Time)
                eq = tVal == tOVal</span>
        case string:<span class="cov0" title="0">
                tOVal := oItem.(string)
                eq = tVal == tOVal</span>
        default:<span class="cov0" title="0"> // unsupported comparison
                err = fmt.Errorf("unsupported comparison type: %v, kind: %v", typItem, typItem.Kind())</span>
        }
        <span class="cov8" title="1">return</span>
}

// Sum attempts to sum multiple items
// returns the result or error if not comparable
func Sum(items ...any) (sum any, err error) <span class="cov8" title="1">{
        //we need at least 2 items to sum them
        if len(items) &lt; 2 </span><span class="cov8" title="1">{
                return nil, ErrNotEnoughParameters
        }</span>

        <span class="cov8" title="1">switch dt := items[0].(type) </span>{
        case time.Duration:<span class="cov8" title="1">
                sum = dt
                for _, item := range items[1:] </span><span class="cov8" title="1">{
                        if itmVal, err := IfaceAsDuration(item); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                sum = sum.(time.Duration) + itmVal
                        }</span>
                }
        case time.Time:<span class="cov0" title="0">
                sum = dt
                for _, item := range items[1:] </span><span class="cov0" title="0">{
                        if itmVal, err := IfaceAsDuration(item); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                sum = sum.(time.Time).Add(itmVal)
                        }</span>
                }
        case float64:<span class="cov8" title="1">
                sum = dt
                for _, item := range items[1:] </span><span class="cov8" title="1">{
                        if itmVal, err := IfaceAsFloat64(item); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                sum = sum.(float64) + itmVal
                        }</span>
                }
        case int64:<span class="cov0" title="0">
                sum = dt
                for _, item := range items[1:] </span><span class="cov0" title="0">{
                        if itmVal, err := IfaceAsInt64(item); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                sum = sum.(int64) + itmVal
                        }</span>
                }
        case int:<span class="cov8" title="1">
                // need explicit conversion for int
                if firstItmVal, err := IfaceAsInt64(dt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        sum = firstItmVal
                }</span>
                <span class="cov8" title="1">for _, item := range items[1:] </span><span class="cov8" title="1">{
                        if itmVal, err := IfaceAsInt64(item); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                sum = sum.(int64) + itmVal
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// Difference attempts to sum multiple items
// returns the result or error if not comparable
func Difference(items ...any) (diff any, err error) <span class="cov8" title="1">{
        //we need at least 2 items to diff them
        if len(items) &lt; 2 </span><span class="cov8" title="1">{
                return nil, ErrNotEnoughParameters
        }</span>
        <span class="cov8" title="1">switch dt := items[0].(type) </span>{
        case time.Duration:<span class="cov8" title="1">
                diff = dt
                for _, item := range items[1:] </span><span class="cov8" title="1">{
                        if itmVal, err := IfaceAsDuration(item); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                diff = diff.(time.Duration) - itmVal
                        }</span>
                }
        case time.Time:<span class="cov8" title="1">
                diff = dt
                for _, item := range items[1:] </span><span class="cov8" title="1">{
                        if itmVal, err := IfaceAsDuration(item); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                diff = diff.(time.Time).Add(-itmVal)
                        }</span>
                }
        case float64:<span class="cov8" title="1">
                diff = dt
                for _, item := range items[1:] </span><span class="cov8" title="1">{
                        if itmVal, err := IfaceAsFloat64(item); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                diff = diff.(float64) - itmVal
                        }</span>
                }
        case int64:<span class="cov0" title="0">
                diff = dt
                for _, item := range items[1:] </span><span class="cov0" title="0">{
                        if itmVal, err := IfaceAsInt64(item); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov0" title="0"> {
                                diff = diff.(int64) - itmVal
                        }</span>
                }
        case int:<span class="cov8" title="1">
                // need explicit conversion for int
                if firstItmVal, err := IfaceAsInt64(dt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> {
                        diff = firstItmVal
                }</span>
                <span class="cov8" title="1">for _, item := range items[1:] </span><span class="cov8" title="1">{
                        if itmVal, err := IfaceAsInt64(item); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                diff = diff.(int64) - itmVal
                        }</span>
                }
        default:<span class="cov0" title="0"> // unsupported comparison
                return nil, fmt.Errorf("unsupported type")</span>
        }
        <span class="cov8" title="1">return</span>
}

// ReflectFieldMethodInterface parses intf attepting to return the field value or error otherwise
// Supports "ExtraFields" where additional fields are dynamically inserted in map with field name: extraFieldsLabel
func ReflectFieldMethodInterface(obj any, fldName string) (retIf any, err error) <span class="cov8" title="1">{
        v := reflect.ValueOf(obj)
        if v.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">var field reflect.Value
        switch v.Kind() </span>{
        case reflect.Struct:<span class="cov8" title="1">
                field = v.FieldByName(fldName)</span>
        case reflect.Map:<span class="cov0" title="0">
                field = v.MapIndex(reflect.ValueOf(fldName))</span>
        case reflect.Slice, reflect.Array:<span class="cov0" title="0">
                //convert fldName to int
                idx, err := strconv.Atoi(fldName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if idx &gt;= v.Len() </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("index out of range")
                }</span>
                <span class="cov0" title="0">field = v.Index(idx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported field kind: %v", v.Kind())</span>
        }
        <span class="cov8" title="1">if !field.IsValid() </span><span class="cov8" title="1">{
                // handle function with pointer
                v = reflect.ValueOf(obj)
                field = v.MethodByName(fldName)
                if !field.IsValid() </span><span class="cov8" title="1">{
                        return nil, ErrNotFound
                }</span> else<span class="cov8" title="1"> {
                        if field.Type().NumIn() != 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid function called")
                        }</span>
                        <span class="cov8" title="1">if field.Type().NumOut() &gt; 2 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid function called")
                        }</span>
                        // the function have two parameters in return and check if the second is of type error
                        <span class="cov8" title="1">if field.Type().NumOut() == 2 </span><span class="cov8" title="1">{
                                errorInterface := reflect.TypeOf((*error)(nil)).Elem()
                                if !field.Type().Out(1).Implements(errorInterface) </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("invalid function called")
                                }</span>
                        }
                        <span class="cov8" title="1">fields := field.Call([]reflect.Value{})
                        if len(fields) == 2 &amp;&amp; !fields[1].IsNil() </span><span class="cov8" title="1">{
                                return fields[0].Interface(), fields[1].Interface().(error)
                        }</span>
                        <span class="cov8" title="1">return fields[0].Interface(), nil</span>
                }
        }
        <span class="cov8" title="1">return field.Interface(), nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "regexp"
)

// Regexp Search/Replace, used for example for field formatting
type ReSearchReplace struct {
        SearchRegexp    *regexp.Regexp
        ReplaceTemplate string
        Matched         bool
}

func (rsr *ReSearchReplace) Process(source string) string <span class="cov8" title="1">{
        if rsr.SearchRegexp == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">res := []byte{}
        match := rsr.SearchRegexp.FindStringSubmatchIndex(source)
        if match == nil </span><span class="cov8" title="1">{
                return source // No match returns unaltered source, so we can play with national vs international dialing
        }</span> else<span class="cov8" title="1"> {
                rsr.Matched = true
        }</span>
        <span class="cov8" title="1">res = rsr.SearchRegexp.ExpandString(res, rsr.ReplaceTemplate, source, match)
        return string(res)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "reflect"
        "sync"
)

var (
        rpcParamsMap  = make(map[string]*RpcParams)
        rpcParamsLock sync.RWMutex
)

type RpcParams struct {
        Object   any
        InParam  any
        OutParam any
}

func RegisterRpcParams(name string, obj any) <span class="cov8" title="1">{
        objType := reflect.TypeOf(obj)
        if name == "" </span><span class="cov8" title="1">{
                val := reflect.ValueOf(obj)
                name = objType.Name()
                if val.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                        name = objType.Elem().Name()
                }</span>
        }
        <span class="cov8" title="1">for i := 0; i &lt; objType.NumMethod(); i++ </span><span class="cov8" title="1">{
                method := objType.Method(i)
                methodType := method.Type
                if methodType.NumIn() == 3 </span><span class="cov8" title="1">{ // if it has three parameters (one is self and two are rpc params)
                        out := methodType.In(2)
                        if out.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                out = out.Elem()
                        }</span>
                        <span class="cov8" title="1">rpcParamsLock.Lock()
                        rpcParamsMap[name+"."+method.Name] = &amp;RpcParams{
                                Object:   obj,
                                InParam:  reflect.New(methodType.In(1)).Interface(),
                                OutParam: reflect.New(out).Interface(),
                        }
                        rpcParamsLock.Unlock()</span>
                }
        }
}

func GetRpcParams(method string) (*RpcParams, error) <span class="cov0" title="0">{
        rpcParamsLock.Lock()
        x, found := rpcParamsMap[method]
        rpcParamsLock.Unlock()
        if !found </span><span class="cov0" title="0">{
                return nil, ErrNotFound
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "fmt"
        "regexp"
        "strings"
)

var (
        spltRgxp  = regexp.MustCompile(`:s\/`)
        rulesRgxp = regexp.MustCompile(`(?:(.+[^\\])\/(.*[^\\])*\/){1,}`)
)

func NewRSRField(fldStr string) (fld *RSRField, err error) <span class="cov8" title="1">{
        if len(fldStr) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">rsrField := &amp;RSRField{Rules: fldStr}
        var filters []*RSRFilter
        if strings.HasSuffix(fldStr, FILTER_VAL_END) </span><span class="cov8" title="1">{ // Has filter, populate the var
                fltrStart := strings.LastIndex(fldStr, FILTER_VAL_START)
                if fltrStart &lt; 1 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("Invalid FilterStartValue in string: %s", fldStr)
                }</span>
                <span class="cov8" title="1">fltrVal := fldStr[fltrStart+1 : len(fldStr)-1]
                filters, err = ParseRSRFilters(fltrVal, MetaPipe)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Invalid FilterValue in string: %s, err: %s", fltrVal, err.Error())
                }</span>
                <span class="cov8" title="1">fldStr = fldStr[:fltrStart]</span> // Take the filter part out before compiling further

        }
        <span class="cov8" title="1">if idxConverters := strings.Index(fldStr, "{*"); idxConverters != -1 </span><span class="cov8" title="1">{ // converters in the string
                if !strings.HasSuffix(fldStr, "}") </span><span class="cov8" title="1">{
                        return nil,
                                fmt.Errorf("Invalid converter value in string: %s, err: invalid converter terminator",
                                        fldStr)
                }</span>
                <span class="cov8" title="1">convertersStr := fldStr[idxConverters+1 : len(fldStr)-1] // strip also {}
                convsSplt := strings.Split(convertersStr, INFIELD_SEP)
                rsrField.converters = make([]DataConverter, len(convsSplt))
                for i, convStr := range convsSplt </span><span class="cov8" title="1">{
                        if conv, err := NewDataConverter(convStr); err != nil </span><span class="cov0" title="0">{
                                return nil,
                                        fmt.Errorf("Invalid converter value in string: %s, err: %s",
                                                convStr, err.Error())
                        }</span> else<span class="cov8" title="1"> {
                                rsrField.converters[i] = conv
                        }</span>
                }
                <span class="cov8" title="1">fldStr = fldStr[:idxConverters]</span>
        }
        <span class="cov8" title="1">if strings.HasPrefix(fldStr, STATIC_VALUE_PREFIX) </span><span class="cov8" title="1">{ // Special case when RSR is defined as static header/value
                var staticHdr, staticVal string
                if splt := strings.Split(fldStr, STATIC_HDRVAL_SEP); len(splt) == 2 </span><span class="cov8" title="1">{ // Using / as separator since ':' is often use in date/time fields
                        staticHdr, staticVal = splt[0][1:], splt[1]    // Strip the / suffix
                        staticVal = strings.TrimSuffix(staticVal, "/") // If value ends with /, strip it since it is a part of the definition syntax
                }</span> else<span class="cov8" title="1"> if len(splt) &gt; 2 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("Invalid RSRField string: %s", fldStr)
                }</span> else<span class="cov8" title="1"> {
                        staticHdr, staticVal = splt[0][1:], splt[0][1:] // If no split, header will remain as original, value as header without the prefix
                }</span>
                <span class="cov8" title="1">rsrField.Id = staticHdr
                rsrField.staticValue = staticVal
                rsrField.filters = filters
                return rsrField, nil</span>
        }
        <span class="cov8" title="1">if !strings.HasPrefix(fldStr, REGEXP_PREFIX) </span><span class="cov8" title="1">{
                rsrField.Id = fldStr
                rsrField.filters = filters
                return rsrField, nil
        }</span>
        <span class="cov8" title="1">spltRules := spltRgxp.Split(fldStr, -1)
        if len(spltRules) &lt; 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Invalid Split of Search&amp;Replace field rule. %s", fldStr)
        }</span>
        <span class="cov8" title="1">rsrField.Id = spltRules[0][1:]
        rsrField.filters = filters              // Original id in form ~hdr_name
        for _, ruleStr := range spltRules[1:] </span><span class="cov8" title="1">{ // :s/ already removed through split
                allMatches := rulesRgxp.FindStringSubmatch(ruleStr)
                if len(allMatches) != 3 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Not enough members in Search&amp;Replace, ruleStr: %s, matches: %v, ", ruleStr, allMatches)
                }</span>
                <span class="cov8" title="1">if srRegexp, err := regexp.Compile(allMatches[1]); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Invalid Search&amp;Replace subfield rule: %s", allMatches[1])
                }</span> else<span class="cov8" title="1"> {
                        rsrField.RSRules = append(rsrField.RSRules, &amp;ReSearchReplace{SearchRegexp: srRegexp, ReplaceTemplate: allMatches[2]})
                }</span>
        }
        <span class="cov8" title="1">return rsrField, nil</span>
}

func NewRSRFieldMustCompile(fldStr string) (rsrFld *RSRField) <span class="cov0" title="0">{
        var err error
        if rsrFld, err = NewRSRField(fldStr); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return</span>
}

type RSRField struct {
        Id          string             // Identifier
        Rules       string             // Rules container holding the string rules to be able to restore it after DB
        staticValue string             // If defined, enforces parsing always to this value
        RSRules     []*ReSearchReplace // Rules to use when processing field value
        filters     []*RSRFilter       // The value to compare when used as filter
        converters  DataConverters     // set of converters to apply on output
}

// IsCompiled finds out whether this RSRField was already parsed or RAW state
func (rsrf *RSRField) IsCompiled() bool <span class="cov8" title="1">{
        return rsrf.staticValue != "" ||
                rsrf.RSRules != nil ||
                rsrf.filters != nil ||
                rsrf.converters != nil
}</span>

// Compile parses Rules string and repopulates other fields
func (rsrf *RSRField) Compile() error <span class="cov8" title="1">{
        if newRSRFld, err := NewRSRField(rsrf.Rules); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> if newRSRFld != nil </span><span class="cov8" title="1">{
                rsrf.staticValue = newRSRFld.staticValue
                rsrf.RSRules = newRSRFld.RSRules
                rsrf.filters = newRSRFld.filters
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsStatic detects if a RSRField is a static value
func (rsrf *RSRField) IsStatic() bool <span class="cov8" title="1">{
        return len(rsrf.staticValue) != 0
}</span>

// RegexpMatched will investigate whether we had a regexp match through the rules
func (rsrf *RSRField) RegexpMatched() bool <span class="cov0" title="0">{
        for _, rsrule := range rsrf.RSRules </span><span class="cov0" title="0">{
                if rsrule.Matched </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// parseValue the field value from a string
func (rsrf *RSRField) parseValue(value string) string <span class="cov8" title="1">{
        if len(rsrf.staticValue) != 0 </span><span class="cov8" title="1">{ // Enforce parsing of static values
                return rsrf.staticValue
        }</span>
        <span class="cov8" title="1">for _, rsRule := range rsrf.RSRules </span><span class="cov8" title="1">{
                if rsRule != nil </span><span class="cov8" title="1">{
                        value = rsRule.Process(value)
                }</span>
        }
        <span class="cov8" title="1">return value</span>
}

func (rsrf *RSRField) filtersPassing(value string) bool <span class="cov8" title="1">{
        for _, fltr := range rsrf.filters </span><span class="cov8" title="1">{
                if !fltr.Pass(value) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Parse will parse the value out considering converters and filters
func (rsrf *RSRField) Parse(value any) (out string, err error) <span class="cov8" title="1">{
        out = rsrf.parseValue(IfaceAsString(value))
        if out, err = rsrf.converters.ConvertString(out); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !rsrf.filtersPassing(out) </span><span class="cov8" title="1">{
                return "", ErrFilterNotPassingNoCaps
        }</span>
        <span class="cov8" title="1">return</span>
}

// NewRSRFilter instantiates a new RSRFilter, setting it's properties
func NewRSRFilter(fltrVal string) (rsrFltr *RSRFilter, err error) <span class="cov8" title="1">{
        rsrFltr = new(RSRFilter)
        if fltrVal == "" </span><span class="cov8" title="1">{
                return rsrFltr, nil
        }</span>
        <span class="cov8" title="1">if fltrVal[:1] == NegativePrefix </span><span class="cov8" title="1">{
                rsrFltr.negative = true
                fltrVal = fltrVal[1:]
                if fltrVal == "" </span><span class="cov8" title="1">{
                        return rsrFltr, nil
                }</span>
        }
        <span class="cov8" title="1">rsrFltr.filterRule = fltrVal
        if fltrVal[:1] == REGEXP_PREFIX </span><span class="cov8" title="1">{
                if rsrFltr.fltrRgxp, err = regexp.Compile(fltrVal[1:]); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return rsrFltr, nil</span>
}

// NewRSRFilterMustCompile is used mostly in tests
func NewRSRFilterMustCompile(fltrVal string) (rsrFltr *RSRFilter) <span class="cov0" title="0">{
        var err error
        if rsrFltr, err = NewRSRFilter(fltrVal); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("parsing &lt;%s&gt;, err: %s", fltrVal, err.Error()))</span>
        }
        <span class="cov0" title="0">return</span>
}

// One filter rule
type RSRFilter struct {
        filterRule string // Value in raw format
        fltrRgxp   *regexp.Regexp
        negative   bool // Rule should not match
}

func (rsrFltr *RSRFilter) FilterRule() string <span class="cov0" title="0">{
        return rsrFltr.filterRule
}</span>

func (rsrFltr *RSRFilter) Pass(val string) bool <span class="cov8" title="1">{
        if rsrFltr.filterRule == "" </span><span class="cov8" title="1">{
                return !rsrFltr.negative
        }</span>
        <span class="cov8" title="1">if rsrFltr.filterRule[:1] == REGEXP_PREFIX </span><span class="cov8" title="1">{
                return rsrFltr.fltrRgxp.MatchString(val) != rsrFltr.negative
        }</span>
        <span class="cov8" title="1">if rsrFltr.filterRule == "^$" </span><span class="cov8" title="1">{ // Special case to test empty value
                return len(val) == 0 != rsrFltr.negative
        }</span>
        <span class="cov8" title="1">if rsrFltr.filterRule[:1] == MatchStartPrefix </span><span class="cov8" title="1">{
                if rsrFltr.filterRule[len(rsrFltr.filterRule)-1:] == MatchEndPrefix </span><span class="cov8" title="1">{ // starts with ^ and ends with $, exact match
                        return val == rsrFltr.filterRule[1:len(rsrFltr.filterRule)-1] != rsrFltr.negative
                }</span>
                <span class="cov8" title="1">return strings.HasPrefix(val, rsrFltr.filterRule[1:]) != rsrFltr.negative</span>
        }
        <span class="cov8" title="1">lastIdx := len(rsrFltr.filterRule) - 1
        if rsrFltr.filterRule[lastIdx:] == MatchEndPrefix </span><span class="cov8" title="1">{
                return strings.HasSuffix(val, rsrFltr.filterRule[:lastIdx]) != rsrFltr.negative
        }</span>
        <span class="cov8" title="1">if len(rsrFltr.filterRule) &gt; 2 &amp;&amp; rsrFltr.filterRule[:2] == MatchGreaterThanOrEqual </span><span class="cov8" title="1">{
                gt, err := GreaterThan(StringToInterface(val),
                        StringToInterface(rsrFltr.filterRule[2:]), true)
                if err != nil </span><span class="cov0" title="0">{
                        Logger.Warning(fmt.Sprintf("&lt;RSRFilter&gt; rule: &lt;%s&gt;, err: &lt;%s&gt;", rsrFltr.filterRule, err.Error()))
                        return false
                }</span>
                <span class="cov8" title="1">return gt != rsrFltr.negative</span>
        }

        <span class="cov8" title="1">if len(rsrFltr.filterRule) &gt; 2 &amp;&amp; rsrFltr.filterRule[:2] == MatchLessThanOrEqual </span><span class="cov8" title="1">{
                gt, err := GreaterThan(StringToInterface(rsrFltr.filterRule[2:]), // compare the rule with the val
                        StringToInterface(val),
                        true)
                if err != nil </span><span class="cov0" title="0">{
                        Logger.Warning(fmt.Sprintf("&lt;RSRFilter&gt; rule: &lt;%s&gt;, err: &lt;%s&gt;", rsrFltr.filterRule, err.Error()))
                        return false
                }</span>
                <span class="cov8" title="1">return gt != rsrFltr.negative</span>
        }

        <span class="cov8" title="1">if rsrFltr.filterRule[:1] == MatchGreaterThan </span><span class="cov8" title="1">{
                gt, err := GreaterThan(StringToInterface(val),
                        StringToInterface(rsrFltr.filterRule[1:]), false)
                if err != nil </span><span class="cov0" title="0">{
                        Logger.Warning(fmt.Sprintf("&lt;RSRFilter&gt; rule: &lt;%s&gt;, err: &lt;%s&gt;", rsrFltr.filterRule, err.Error()))
                        return false
                }</span>
                <span class="cov8" title="1">return gt != rsrFltr.negative</span>
        }

        <span class="cov8" title="1">if rsrFltr.filterRule[:1] == MatchLessThan </span><span class="cov8" title="1">{
                gt, err := GreaterThan(StringToInterface(rsrFltr.filterRule[1:]), // compare the rule with the val
                        StringToInterface(val),
                        false)
                if err != nil </span><span class="cov0" title="0">{
                        Logger.Warning(fmt.Sprintf("&lt;RSRFilter&gt; rule: &lt;%s&gt;, err: &lt;%s&gt;", rsrFltr.filterRule, err.Error()))
                        return false
                }</span>
                <span class="cov8" title="1">return gt != rsrFltr.negative</span>
        }
        <span class="cov8" title="1">return strings.Contains(val, rsrFltr.filterRule) != rsrFltr.negative</span> // default is string index
}

func ParseRSRFilters(fldsStr, sep string) (RSRFilters, error) <span class="cov8" title="1">{
        if fldsStr == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">fltrSplt := strings.Split(fldsStr, sep)
        return ParseRSRFiltersFromSlice(fltrSplt)</span>
}

func ParseRSRFiltersFromSlice(fltrStrs []string) (RSRFilters, error) <span class="cov8" title="1">{
        rsrFltrs := make(RSRFilters, len(fltrStrs))
        for i, rlStr := range fltrStrs </span><span class="cov8" title="1">{
                if rsrFltr, err := NewRSRFilter(rlStr); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> if rsrFltr == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Empty RSRFilter in rule: %s", rlStr)
                }</span> else<span class="cov8" title="1"> {
                        rsrFltrs[i] = rsrFltr
                }</span>
        }
        <span class="cov8" title="1">return rsrFltrs, nil</span>
}

type RSRFilters []*RSRFilter

func (fltrs RSRFilters) FilterRules() (rls string) <span class="cov0" title="0">{
        for _, fltr := range fltrs </span><span class="cov0" title="0">{
                rls += fltr.FilterRule()
        }</span>
        <span class="cov0" title="0">return</span>
}

// @all: specifies whether all filters should match or at least one
func (fltrs RSRFilters) Pass(val string, allMustMatch bool) (matched bool) <span class="cov8" title="1">{
        if len(fltrs) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">for _, fltr := range fltrs </span><span class="cov8" title="1">{
                matched = fltr.Pass(val)
                if allMustMatch </span><span class="cov8" title="1">{
                        if !matched </span><span class="cov8" title="1">{
                                return
                        }</span>
                } else<span class="cov8" title="1"> if matched </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func ParseRSRFieldsFromSlice(flds []string) (RSRFields, error) <span class="cov8" title="1">{
        if len(flds) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">rsrFields := make(RSRFields, len(flds))
        for idx, ruleStr := range flds </span><span class="cov8" title="1">{
                if rsrField, err := NewRSRField(ruleStr); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> if rsrField == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Empty RSRField in rule: %s", ruleStr)
                }</span> else<span class="cov8" title="1"> {
                        rsrFields[idx] = rsrField
                }</span>
        }
        <span class="cov8" title="1">return rsrFields, nil</span>

}

// Parses list of RSRFields, used for example as multiple filters in derived charging
func ParseRSRFields(fldsStr, sep string) (RSRFields, error) <span class="cov8" title="1">{
        //rsrRlsPattern := regexp.MustCompile(`^(~\w+:s/.+/.*/)|(\^.+(/.+/)?)(;(~\w+:s/.+/.*/)|(\^.+(/.+/)?))*$`) //ToDo:Fix here rule able to confirm the content
        if len(fldsStr) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">rulesSplt := strings.Split(fldsStr, sep)
        return ParseRSRFieldsFromSlice(rulesSplt)</span>

}

func ParseRSRFieldsMustCompile(fldsStr, sep string) RSRFields <span class="cov0" title="0">{
        if flds, err := ParseRSRFields(fldsStr, sep); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> {
                return flds
        }</span>
}

type RSRFields []*RSRField

// Return first Id of the rsrFields, used in cdre
func (flds RSRFields) Id() string <span class="cov8" title="1">{
        if len(flds) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return flds[0].Id</span>
}

func (flds RSRFields) Compile() (err error) <span class="cov0" title="0">{
        for _, rsrFld := range flds </span><span class="cov0" title="0">{
                if err = rsrFld.Compile(); err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "bytes"
        "crypto/tls"
        "crypto/x509"
        "encoding/gob"
        "fmt"
        "io"
        "log"
        "net"
        "net/http"
        "net/http/pprof"
        "net/rpc"
        "net/url"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/cgrates/birpc"
        "github.com/cgrates/birpc/jsonrpc"
        "golang.org/x/net/websocket"
)

func init() <span class="cov8" title="1">{
        gob.Register(map[string]any{})
        gob.Register([]any{})
        gob.Register(time.Duration(0))
        gob.Register(time.Time{})
        gob.Register(url.Values{})
}</span>
func NewServer() (s *Server) <span class="cov0" title="0">{
        s = new(Server)
        s.birpcSrv = birpc.NewBirpcServer()
        s.httpMux = http.NewServeMux()
        s.httpsMux = http.NewServeMux()
        s.stopbiRPCServer = make(chan struct{}, 1)
        return s
}</span>

type Server struct {
        sync.RWMutex
        rpcEnabled      bool
        httpEnabled     bool
        birpcSrv        *birpc.BirpcServer
        stopbiRPCServer chan struct{} // used in order to fully stop the biRPC
        httpsMux        *http.ServeMux
        httpMux         *http.ServeMux
        isDispatched    bool
}

func (s *Server) SetDispatched() <span class="cov0" title="0">{
        s.isDispatched = true
}</span>

func (s *Server) RpcRegister(rcvr any) <span class="cov0" title="0">{
        rpc.Register(rcvr)
        s.Lock()
        s.rpcEnabled = true
        s.Unlock()
}</span>

func (s *Server) RpcRegisterName(name string, rcvr any) <span class="cov0" title="0">{
        rpc.RegisterName(name, rcvr)
        s.Lock()
        s.rpcEnabled = true
        s.Unlock()
}</span>

func (s *Server) RegisterHttpFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) <span class="cov0" title="0">{
        if s.httpMux != nil </span><span class="cov0" title="0">{
                s.httpMux.HandleFunc(pattern, handler)
        }</span>
        <span class="cov0" title="0">if s.httpsMux != nil </span><span class="cov0" title="0">{
                s.httpsMux.HandleFunc(pattern, handler)
        }</span>
        <span class="cov0" title="0">s.Lock()
        s.httpEnabled = true
        s.Unlock()</span>
}

func (s *Server) RegisterHttpHandler(pattern string, handler http.Handler) <span class="cov0" title="0">{
        if s.httpMux != nil </span><span class="cov0" title="0">{
                s.httpMux.Handle(pattern, handler)
        }</span>
        <span class="cov0" title="0">if s.httpsMux != nil </span><span class="cov0" title="0">{
                s.httpsMux.Handle(pattern, handler)
        }</span>
        <span class="cov0" title="0">s.Lock()
        s.httpEnabled = true
        s.Unlock()</span>
}

// Registers a new BiJsonRpc name
func (s *Server) BiRPCRegisterName(name string, rcv any) <span class="cov0" title="0">{
        s.birpcSrv.RegisterName(name, rcv)
}</span>

func (s *Server) BiRPCUnregisterName(name string) <span class="cov0" title="0">{
        s.birpcSrv.UnregisterName(name)
}</span>

func (s *Server) ServeJSON(addr string, exitChan chan bool) <span class="cov0" title="0">{
        s.RLock()
        enabled := s.rpcEnabled
        s.RUnlock()
        if !enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">lJSON, e := net.Listen(TCP, addr)
        if e != nil </span><span class="cov0" title="0">{
                log.Println("ServeJSON listen error:", e)
                exitChan &lt;- true
                return
        }</span>
        <span class="cov0" title="0">Logger.Info(fmt.Sprintf("Starting CGRateS JSON server at &lt;%s&gt;.", addr))
        errCnt := 0
        var lastErrorTime time.Time
        for </span><span class="cov0" title="0">{
                conn, err := lJSON.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        Logger.Err(fmt.Sprintf("&lt;CGRServer&gt; JSON accept error: &lt;%s&gt;", err.Error()))
                        now := time.Now()
                        if now.Sub(lastErrorTime) &gt; time.Duration(5*time.Second) </span><span class="cov0" title="0">{
                                errCnt = 0 // reset error count if last error was more than 5 seconds ago
                        }</span>
                        <span class="cov0" title="0">lastErrorTime = time.Now()
                        errCnt++
                        if errCnt &gt; 50 </span><span class="cov0" title="0">{ // Too many errors in short interval, network buffer failure most probably
                                break</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                //utils.Logger.Info(fmt.Sprintf("&lt;CGRServer&gt; New incoming connection: %v", conn.RemoteAddr()))
                <span class="cov0" title="0">if s.isDispatched </span><span class="cov0" title="0">{
                        go rpc.ServeCodec(NewCustomJSONServerCodec(conn))
                }</span> else<span class="cov0" title="0"> {
                        go rpc.ServeCodec(NewConcReqsServerCodec(conn))
                }</span>

        }

}

func (s *Server) ServeGOB(addr string, exitChan chan bool) <span class="cov0" title="0">{
        s.RLock()
        enabled := s.rpcEnabled
        s.RUnlock()
        if !enabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lGOB, e := net.Listen(TCP, addr)
        if e != nil </span><span class="cov0" title="0">{
                log.Println("ServeGOB listen error:", e)
                exitChan &lt;- true
                return
        }</span>
        <span class="cov0" title="0">Logger.Info(fmt.Sprintf("Starting CGRateS GOB server at &lt;%s&gt;.", addr))
        errCnt := 0
        var lastErrorTime time.Time
        for </span><span class="cov0" title="0">{
                conn, err := lGOB.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        Logger.Err(fmt.Sprintf("&lt;CGRServer&gt; GOB accept error: &lt;%s&gt;", err.Error()))
                        now := time.Now()
                        if now.Sub(lastErrorTime) &gt; time.Duration(5*time.Second) </span><span class="cov0" title="0">{
                                errCnt = 0 // reset error count if last error was more than 5 seconds ago
                        }</span>
                        <span class="cov0" title="0">lastErrorTime = time.Now()
                        errCnt += 1
                        if errCnt &gt; 50 </span><span class="cov0" title="0">{ // Too many errors in short interval, network buffer failure most probably
                                break</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">go rpc.ServeCodec(NewConcReqsGobServerCodec(conn))</span>
        }
}

func handleRequest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()
        w.Header().Set("Content-Type", "application/json")
        res := NewRPCRequest(r.Body).Call()
        io.Copy(w, res)
}</span>

func registerProfiler(addr string, mux *http.ServeMux) <span class="cov0" title="0">{
        mux.HandleFunc(addr, pprof.Index)
        mux.HandleFunc(addr+"cmdline", pprof.Cmdline)
        mux.HandleFunc(addr+"profile", pprof.Profile)
        mux.HandleFunc(addr+"symbol", pprof.Symbol)
        mux.HandleFunc(addr+"trace", pprof.Trace)
        mux.Handle(addr+"goroutine", pprof.Handler("goroutine"))
        mux.Handle(addr+"heap", pprof.Handler("heap"))
        mux.Handle(addr+"threadcreate", pprof.Handler("threadcreate"))
        mux.Handle(addr+"block", pprof.Handler("block"))
        mux.Handle(addr+"allocs", pprof.Handler("allocs"))
        mux.Handle(addr+"mutex", pprof.Handler("mutex"))
}</span>

func (s *Server) RegisterProfiler(addr string) <span class="cov0" title="0">{
        if addr[len(addr)-1] != '/' </span><span class="cov0" title="0">{
                addr = addr + "/"
        }</span>
        <span class="cov0" title="0">registerProfiler(addr, s.httpMux)
        registerProfiler(addr, s.httpsMux)</span>
}

func (s *Server) ServeHTTP(addr string, jsonRPCURL string, wsRPCURL string,
        useBasicAuth bool, userList map[string]string, exitChan chan bool) <span class="cov0" title="0">{
        s.RLock()
        enabled := s.rpcEnabled
        s.RUnlock()
        if !enabled </span><span class="cov0" title="0">{
                return
        }</span>
        // s.httpMux = http.NewServeMux()
        <span class="cov0" title="0">if enabled &amp;&amp; jsonRPCURL != "" </span><span class="cov0" title="0">{
                s.Lock()
                s.httpEnabled = true
                s.Unlock()

                Logger.Info("&lt;HTTP&gt; enabling handler for JSON-RPC")
                if useBasicAuth </span><span class="cov0" title="0">{
                        s.httpMux.HandleFunc(jsonRPCURL, use(handleRequest, basicAuth(userList)))
                }</span> else<span class="cov0" title="0"> {
                        s.httpMux.HandleFunc(jsonRPCURL, handleRequest)
                }</span>
        }
        <span class="cov0" title="0">if enabled &amp;&amp; wsRPCURL != "" </span><span class="cov0" title="0">{
                s.Lock()
                s.httpEnabled = true
                s.Unlock()
                Logger.Info("&lt;HTTP&gt; enabling handler for WebSocket connections")
                wsHandler := websocket.Handler(func(ws *websocket.Conn) </span><span class="cov0" title="0">{
                        if s.isDispatched </span><span class="cov0" title="0">{
                                rpc.ServeCodec(NewCustomJSONServerCodec(ws))
                        }</span> else<span class="cov0" title="0"> {
                                rpc.ServeCodec(NewConcReqsServerCodec(ws))
                        }</span>
                })
                <span class="cov0" title="0">if useBasicAuth </span><span class="cov0" title="0">{
                        s.httpMux.HandleFunc(wsRPCURL, use(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                wsHandler.ServeHTTP(w, r)
                        }</span>, basicAuth(userList)))
                } else<span class="cov0" title="0"> {
                        s.httpMux.Handle(wsRPCURL, wsHandler)
                }</span>
        }
        <span class="cov0" title="0">if !s.httpEnabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if useBasicAuth </span><span class="cov0" title="0">{
                Logger.Info("&lt;HTTP&gt; enabling basic auth")
        }</span>
        <span class="cov0" title="0">Logger.Info(fmt.Sprintf("&lt;HTTP&gt; start listening at &lt;%s&gt;", addr))
        if err := http.ListenAndServe(addr, s.httpMux); err != nil </span><span class="cov0" title="0">{
                log.Printf("&lt;HTTP&gt;Error: %s when listening ", err)
        }</span>
        <span class="cov0" title="0">exitChan &lt;- true</span>
}

// ServeBiJSON create a gorutine to listen and serve as BiRPC server
func (s *Server) ServeBiJSON(addr string, onConn, onDis func(birpc.ClientConnector)) (err error) <span class="cov0" title="0">{
        s.RLock()
        isNil := s.birpcSrv == nil
        s.RUnlock()
        if isNil </span><span class="cov0" title="0">{
                return fmt.Errorf("BiRPCServer should not be nil")
        }</span>
        <span class="cov0" title="0">var lBiJSON net.Listener
        lBiJSON, err = net.Listen(TCP, addr)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("ServeBiJSON listen error:", err)
                return
        }</span>
        <span class="cov0" title="0">s.birpcSrv.OnConnect(onConn)
        s.birpcSrv.OnDisconnect(onDis)
        Logger.Info(fmt.Sprintf("Starting CGRateS BiJSON server at &lt;%s&gt;", addr))
        go func(l net.Listener) </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        conn, err := l.Accept()
                        if err != nil </span><span class="cov0" title="0">{
                                if strings.Contains(err.Error(), "use of closed network connection") </span><span class="cov0" title="0">{ // if closed by us do not log
                                        return
                                }</span>
                                <span class="cov0" title="0">s.stopbiRPCServer &lt;- struct{}{}
                                log.Fatal(err)
                                return</span> // stop if we get Accept error
                        }
                        <span class="cov0" title="0">go s.birpcSrv.ServeCodec(jsonrpc.NewJSONBirpcCodec(conn))</span>
                }
        }(lBiJSON)
        <span class="cov0" title="0">&lt;-s.stopbiRPCServer // wait until server is stoped to close the listener
        lBiJSON.Close()
        return</span>
}

// StopBiRPC stops the go rutine create with ServeBiJSON
func (s *Server) StopBiRPC() <span class="cov0" title="0">{
        s.stopbiRPCServer &lt;- struct{}{}
}</span>

// rpcRequest represents a RPC request.
// rpcRequest implements the io.ReadWriteCloser interface.
type rpcRequest struct {
        r    io.Reader     // holds the JSON formated RPC request
        rw   io.ReadWriter // holds the JSON formated RPC response
        done chan bool     // signals then end of the RPC request
}

// NewRPCRequest returns a new rpcRequest.
func NewRPCRequest(r io.Reader) *rpcRequest <span class="cov0" title="0">{
        var buf bytes.Buffer
        done := make(chan bool)
        return &amp;rpcRequest{r, &amp;buf, done}
}</span>

func (r *rpcRequest) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        return r.r.Read(p)
}</span>

func (r *rpcRequest) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        n, err = r.rw.Write(p)
        r.done &lt;- true
        return
}</span>

func (r *rpcRequest) Close() error <span class="cov0" title="0">{
        //r.done &lt;- true // seem to be called sometimes before the write command finishes!
        return nil
}</span>

// Call invokes the RPC request, waits for it to complete, and returns the results.
func (r *rpcRequest) Call() io.Reader <span class="cov0" title="0">{
        go rpc.ServeCodec(NewConcReqsServerCodec(r))
        &lt;-r.done
        return r.rw
}</span>

func loadTLSConfig(serverCrt, serverKey, caCert string, serverPolicy int,
        serverName string) (config tls.Config, err error) <span class="cov0" title="0">{
        cert, err := tls.LoadX509KeyPair(serverCrt, serverKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error: %s when load server keys", err)
        }</span>
        <span class="cov0" title="0">rootCAs, err := x509.SystemCertPool()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error: %s when load SystemCertPool", err)
                return
        }</span>
        <span class="cov0" title="0">if rootCAs == nil </span><span class="cov0" title="0">{
                rootCAs = x509.NewCertPool()
        }</span>

        <span class="cov0" title="0">if caCert != "" </span><span class="cov0" title="0">{
                ca, err := os.ReadFile(caCert)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error: %s when read CA", err)
                        return config, err
                }</span>

                <span class="cov0" title="0">if ok := rootCAs.AppendCertsFromPEM(ca); !ok </span><span class="cov0" title="0">{
                        log.Fatalf("Cannot append certificate authority")
                        return config, err
                }</span>
        }

        <span class="cov0" title="0">config = tls.Config{
                Certificates: []tls.Certificate{cert},
                ClientAuth:   tls.ClientAuthType(serverPolicy),
                ClientCAs:    rootCAs,
        }
        if serverName != "" </span><span class="cov0" title="0">{
                config.ServerName = serverName
        }</span>
        <span class="cov0" title="0">return</span>
}

func (s *Server) ServeGOBTLS(addr, serverCrt, serverKey, caCert string,
        serverPolicy int, serverName string, exitChan chan bool) <span class="cov0" title="0">{
        s.RLock()
        enabled := s.rpcEnabled
        s.RUnlock()
        if !enabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">config, err := loadTLSConfig(serverCrt, serverKey, caCert, serverPolicy, serverName)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">listener, err := tls.Listen(TCP, addr, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: %s when listening", err)
                exitChan &lt;- true
                return
        }</span>

        <span class="cov0" title="0">Logger.Info(fmt.Sprintf("Starting CGRateS GOB TLS server at &lt;%s&gt;.", addr))
        errCnt := 0
        var lastErrorTime time.Time
        for </span><span class="cov0" title="0">{
                conn, err := listener.Accept()
                defer conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        Logger.Err(fmt.Sprintf("&lt;CGRServer&gt; TLS accept error: &lt;%s&gt;", err.Error()))
                        now := time.Now()
                        if now.Sub(lastErrorTime) &gt; time.Duration(5*time.Second) </span><span class="cov0" title="0">{
                                errCnt = 0 // reset error count if last error was more than 5 seconds ago
                        }</span>
                        <span class="cov0" title="0">lastErrorTime = time.Now()
                        errCnt++
                        if errCnt &gt; 50 </span><span class="cov0" title="0">{ // Too many errors in short interval, network buffer failure most probably
                                break</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                //utils.Logger.Info(fmt.Sprintf("&lt;CGRServer&gt; New incoming connection: %v", conn.RemoteAddr()))
                <span class="cov0" title="0">go rpc.ServeCodec(NewConcReqsGobServerCodec(conn))</span>
        }
}

func (s *Server) ServeJSONTLS(addr, serverCrt, serverKey, caCert string,
        serverPolicy int, serverName string, exitChan chan bool) <span class="cov0" title="0">{
        s.RLock()
        enabled := s.rpcEnabled
        s.RUnlock()
        if !enabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">config, err := loadTLSConfig(serverCrt, serverKey, caCert, serverPolicy, serverName)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">listener, err := tls.Listen(TCP, addr, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error: %s when listening", err)
                exitChan &lt;- true
                return
        }</span>
        <span class="cov0" title="0">Logger.Info(fmt.Sprintf("Starting CGRateS JSON TLS server at &lt;%s&gt;.", addr))
        errCnt := 0
        var lastErrorTime time.Time
        for </span><span class="cov0" title="0">{
                conn, err := listener.Accept()
                defer conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        Logger.Err(fmt.Sprintf("&lt;CGRServer&gt; TLS accept error: &lt;%s&gt;", err.Error()))
                        now := time.Now()
                        if now.Sub(lastErrorTime) &gt; time.Duration(5*time.Second) </span><span class="cov0" title="0">{
                                errCnt = 0 // reset error count if last error was more than 5 seconds ago
                        }</span>
                        <span class="cov0" title="0">lastErrorTime = time.Now()
                        errCnt++
                        if errCnt &gt; 50 </span><span class="cov0" title="0">{ // Too many errors in short interval, network buffer failure most probably
                                break</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if s.isDispatched </span><span class="cov0" title="0">{
                        go rpc.ServeCodec(NewCustomJSONServerCodec(conn))
                }</span> else<span class="cov0" title="0"> {
                        go rpc.ServeCodec(NewConcReqsServerCodec(conn))
                }</span>
        }
}

func (s *Server) ServeHTTPTLS(addr, serverCrt, serverKey, caCert string, serverPolicy int,
        serverName string, jsonRPCURL string, wsRPCURL string,
        useBasicAuth bool, userList map[string]string, exitChan chan bool) <span class="cov0" title="0">{
        s.RLock()
        enabled := s.rpcEnabled
        s.RUnlock()
        if !enabled </span><span class="cov0" title="0">{
                return
        }</span>
        // s.httpsMux = http.NewServeMux()
        <span class="cov0" title="0">if enabled &amp;&amp; jsonRPCURL != "" </span><span class="cov0" title="0">{
                s.Lock()
                s.httpEnabled = true
                s.Unlock()
                Logger.Info("&lt;HTTPS&gt; enabling handler for JSON-RPC")
                if useBasicAuth </span><span class="cov0" title="0">{
                        s.httpsMux.HandleFunc(jsonRPCURL, use(handleRequest, basicAuth(userList)))
                }</span> else<span class="cov0" title="0"> {
                        s.httpsMux.HandleFunc(jsonRPCURL, handleRequest)
                }</span>
        }
        <span class="cov0" title="0">if enabled &amp;&amp; wsRPCURL != "" </span><span class="cov0" title="0">{
                s.Lock()
                s.httpEnabled = true
                s.Unlock()
                Logger.Info("&lt;HTTPS&gt; enabling handler for WebSocket connections")
                wsHandler := websocket.Handler(func(ws *websocket.Conn) </span><span class="cov0" title="0">{
                        if s.isDispatched </span><span class="cov0" title="0">{
                                rpc.ServeCodec(NewCustomJSONServerCodec(ws))
                        }</span> else<span class="cov0" title="0"> {
                                rpc.ServeCodec(NewConcReqsServerCodec(ws))
                        }</span>
                })
                <span class="cov0" title="0">if useBasicAuth </span><span class="cov0" title="0">{
                        s.httpsMux.HandleFunc(wsRPCURL, use(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                wsHandler.ServeHTTP(w, r)
                        }</span>, basicAuth(userList)))
                } else<span class="cov0" title="0"> {
                        s.httpsMux.Handle(wsRPCURL, wsHandler)
                }</span>
        }
        <span class="cov0" title="0">if !s.httpEnabled </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if useBasicAuth </span><span class="cov0" title="0">{
                Logger.Info("&lt;HTTPS&gt; enabling basic auth")
        }</span>
        <span class="cov0" title="0">config, err := loadTLSConfig(serverCrt, serverKey, caCert, serverPolicy, serverName)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">httpSrv := http.Server{
                Addr:      addr,
                Handler:   s.httpsMux,
                TLSConfig: &amp;config,
        }
        Logger.Info(fmt.Sprintf("&lt;HTTPS&gt; start listening at &lt;%s&gt;", addr))
        if err := httpSrv.ListenAndServeTLS(serverCrt, serverKey); err != nil </span><span class="cov0" title="0">{
                log.Printf("&lt;HTTPS&gt;Error: %s when listening ", err)
        }</span>
        <span class="cov0" title="0">exitChan &lt;- true</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import "sort"

// NewStringSet returns a new StringSet
func NewStringSet(dataSlice []string) (s StringSet) <span class="cov8" title="1">{
        s = make(StringSet)
        s.AddSlice(dataSlice)
        return s
}</span>

// StringSet will manage data within a set
type StringSet map[string]struct{}

// Add adds a key in set
func (s StringSet) Add(val string) <span class="cov8" title="1">{
        s[val] = struct{}{}
}</span>

// Remove removes a key from set
func (s StringSet) Remove(val string) <span class="cov8" title="1">{
        delete(s, val)
}</span>

// Has returns if the key is in set
func (s StringSet) Has(val string) bool <span class="cov8" title="1">{
        _, has := s[val]
        return has
}</span>

// AddSlice adds all the element of a slice
func (s StringSet) AddSlice(dataSlice []string) <span class="cov8" title="1">{
        for _, val := range dataSlice </span><span class="cov8" title="1">{
                s.Add(val)
        }</span>
}

// AsSlice returns the keys as string slice
func (s StringSet) AsSlice() []string <span class="cov8" title="1">{
        result := make([]string, len(s))
        i := 0
        for k := range s </span><span class="cov8" title="1">{
                result[i] = k
                i++
        }</span>
        <span class="cov8" title="1">return result</span>
}

// AsOrderedSlice returns the keys as ordered string slice
func (s StringSet) AsOrderedSlice() (ss []string) <span class="cov8" title="1">{
        ss = s.AsSlice()
        sort.Strings(ss)
        return
}</span>

// Sha1 returns the Sha1 on top of ordered slice
func (s StringSet) Sha1() string <span class="cov8" title="1">{
        return Sha1(s.AsOrderedSlice()...)
}</span>

// Size returns the size of the set
func (s StringSet) Size() int <span class="cov8" title="1">{
        return len(s)
}</span>

// Intersect removes all key s2 do not have
func (s StringSet) Intersect(s2 StringSet) <span class="cov8" title="1">{
        for k := range s </span><span class="cov8" title="1">{
                if !s2.Has(k) </span><span class="cov8" title="1">{
                        s.Remove(k)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "sort"
        "strings"
)

// Binary string search in slice
func IsSliceMember(ss []string, s string) bool <span class="cov8" title="1">{
        sort.Strings(ss)
        return SliceHasMember(ss, s)
}</span>

// SliceHasMember searches within a *sorted* slice
// useful to search in shared vars (no slice sort)
func SliceHasMember(ss []string, s string) bool <span class="cov8" title="1">{
        i := sort.SearchStrings(ss, s)
        return i &lt; len(ss) &amp;&amp; ss[i] == s
}</span>

func SliceWithoutMember(ss []string, s string) []string <span class="cov8" title="1">{
        sort.Strings(ss)
        if i := sort.SearchStrings(ss, s); i &lt; len(ss) &amp;&amp; ss[i] == s </span><span class="cov8" title="1">{
                ss[i], ss = ss[len(ss)-1], ss[:len(ss)-1]
        }</span>
        <span class="cov8" title="1">return ss</span>
}

// Iterates over slice members and returns true if one starts with prefix
func SliceMemberHasPrefix(ss []string, prfx string) bool <span class="cov8" title="1">{
        for _, mbr := range ss </span><span class="cov8" title="1">{
                if strings.HasPrefix(mbr, prfx) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func Avg(values []float64) float64 <span class="cov8" title="1">{
        if len(values) == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">var sum float64
        for _, val := range values </span><span class="cov8" title="1">{
                sum += val
        }</span>
        <span class="cov8" title="1">return sum / float64(len(values))</span>
}

func AvgNegative(values []float64) float64 <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return -1 // return -1 if no data
        }</span>
        <span class="cov0" title="0">return Avg(values)</span>
}

func PrefixSliceItems(slc []string, prfx string) (out []string) <span class="cov0" title="0">{
        out = make([]string, len(slc))
        for i, itm := range slc </span><span class="cov0" title="0">{
                out[i] = prfx + itm
        }</span>
        <span class="cov0" title="0">return</span>
}

// StripSlicePrefix will strip a number of items from the beginning of the slice
func StripSlicePrefix(slc []string, nrItems int) []string <span class="cov8" title="1">{
        if len(slc) &lt; nrItems </span><span class="cov8" title="1">{
                return []string{}
        }</span>
        <span class="cov8" title="1">return slc[nrItems:]</span>
}

// SliceStringToIface converts slice of strings into a slice of interfaces
func SliceStringToIface(slc []string) (ifc []any) <span class="cov8" title="1">{
        ifc = make([]any, len(slc))
        for i, itm := range slc </span><span class="cov8" title="1">{
                ifc[i] = itm
        }</span>
        <span class="cov8" title="1">return</span>
}

// Float64SliceHasMember searches within a *sorted* slice
// useful to search in shared vars (no slice sort)
func Float64SliceHasMember(ss []float64, s float64) bool <span class="cov8" title="1">{
        i := sort.SearchFloat64s(ss, s)
        return i &lt; len(ss) &amp;&amp; ss[i] == s
}</span>

// HasPrefixSlice iterates over slice members and returns true if one the element has that prefix
func HasPrefixSlice(prfxs []string, el string) bool <span class="cov8" title="1">{
        for _, prfx := range prfxs </span><span class="cov8" title="1">{
                if strings.HasPrefix(el, prfx) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"
)

func fieldByIndexIsEmpty(v reflect.Value, index []int) bool <span class="cov8" title="1">{
        if len(index) == 1 </span><span class="cov8" title="1">{
                return valueIsEmpty(v.Field(index[0]))
        }</span>
        <span class="cov8" title="1">for i, x := range index </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        if v.Kind() == reflect.Ptr &amp;&amp; v.Type().Elem().Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                if v.IsNil() </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                                <span class="cov0" title="0">v = v.Elem()</span>
                        }
                }
                <span class="cov8" title="1">v = v.Field(x)</span>
        }
        <span class="cov8" title="1">return valueIsEmpty(v)</span>
}

func valueIsEmpty(fld reflect.Value) bool <span class="cov8" title="1">{
        if fld.Kind() == reflect.String &amp;&amp; fld.CanSet() </span><span class="cov8" title="1">{
                fld.SetString(strings.TrimSpace(fld.String()))
        }</span>
        <span class="cov8" title="1">return (fld.Kind() == reflect.String &amp;&amp; fld.String() == EmptyString) ||
                ((fld.Kind() == reflect.Slice || fld.Kind() == reflect.Map) &amp;&amp; fld.Len() == 0) ||
                (fld.Kind() == reflect.Int &amp;&amp; fld.Int() == 0)</span>
}

// Detects missing field values based on mandatory field names, s should be a pointer to a struct
func MissingStructFields(s any, mandatories []string) []string <span class="cov8" title="1">{
        missing := []string{}
        sValue := reflect.ValueOf(s).Elem()
        sType := sValue.Type()
        for _, fieldName := range mandatories </span><span class="cov8" title="1">{
                fldStr, ok := sType.FieldByName(fieldName)
                if !ok || fieldByIndexIsEmpty(sValue, fldStr.Index) </span><span class="cov8" title="1">{
                        missing = append(missing, fieldName)
                }</span>
        }
        <span class="cov8" title="1">return missing</span>
}

// Detects nonempty struct fields, s should be a pointer to a struct
// Useful to not overwrite db fields with non defined params in api
func NonemptyStructFields(s any) map[string]any <span class="cov8" title="1">{
        fields := make(map[string]any)
        for i := 0; i &lt; reflect.ValueOf(s).Elem().NumField(); i++ </span><span class="cov8" title="1">{
                fld := reflect.ValueOf(s).Elem().Field(i)
                switch fld.Kind() </span>{
                case reflect.Bool:<span class="cov8" title="1">
                        fields[reflect.TypeOf(s).Elem().Field(i).Name] = fld.Bool()</span>
                case reflect.Int:<span class="cov0" title="0">
                        fieldVal := fld.Int()
                        if fieldVal != 0 </span><span class="cov0" title="0">{
                                fields[reflect.TypeOf(s).Elem().Field(i).Name] = fieldVal
                        }</span>
                case reflect.String:<span class="cov8" title="1">
                        fieldVal := fld.String()
                        if fieldVal != "" </span><span class="cov8" title="1">{
                                fields[reflect.TypeOf(s).Elem().Field(i).Name] = fieldVal
                        }</span>
                }
        }
        <span class="cov8" title="1">return fields</span>
}

// MissingMapFields detects missing field values based on mandatory field names from a map[string]any
func MissingMapFields(s map[string]any, mandatories []string) []string <span class="cov8" title="1">{
        missing := []string{}
        for _, fieldName := range mandatories </span><span class="cov8" title="1">{
                if fldval, has := s[fieldName]; !has </span><span class="cov8" title="1">{
                        missing = append(missing, fieldName)
                }</span> else<span class="cov8" title="1"> {
                        fld := reflect.ValueOf(fldval)
                        // sanitize the string fields before checking
                        if fld.Kind() == reflect.String &amp;&amp; fld.CanSet() </span><span class="cov0" title="0">{
                                fld.SetString(strings.TrimSpace(fld.String()))
                        }</span>
                        <span class="cov8" title="1">if (fld.Kind() == reflect.String &amp;&amp; fld.String() == "") ||
                                ((fld.Kind() == reflect.Slice || fld.Kind() == reflect.Map) &amp;&amp; fld.Len() == 0) ||
                                (fld.Kind() == reflect.Int &amp;&amp; fld.Int() == 0) </span><span class="cov8" title="1">{
                                missing = append(missing, fieldName)
                        }</span>
                }
        }
        <span class="cov8" title="1">return missing</span>
}

// Converts a struct to map
/*func StrucToMap(s any) map[string]any {
        mp := make(map[string]any)
        for i := 0; i &lt; reflect.ValueOf(s).Elem().NumField(); i++ {
                fld := reflect.ValueOf(s).Elem().Field(i)
                switch fld.Kind() {
                case reflect.Bool:
                        mp[reflect.TypeOf(s).Elem().Field(i).Name] = fld.Bool()
                case reflect.Int:
                        mp[reflect.TypeOf(s).Elem().Field(i).Name] = fld.Int()
                case reflect.String:
                        mp[reflect.TypeOf(s).Elem().Field(i).Name] = fld.String()
                }
        }
        return mp
}*/

// Converts a struct to map[string]any
func ToMapMapStringInterface(in any) map[string]any <span class="cov0" title="0">{ // Got error and it is not used anywhere
        out := make(map[string]any)

        v := reflect.ValueOf(in)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov0" title="0">typ := reflect.TypeOf(in)
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                out[typ.Field(i).Name] = v.Field(i).Interface()
        }</span>
        <span class="cov0" title="0">return out</span>
}

// Converts a struct to map[string]string
func ToMapStringString(in any) map[string]string <span class="cov0" title="0">{
        out := make(map[string]string)

        v := reflect.ValueOf(in)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
                in = v.Interface()
        }</span>
        <span class="cov0" title="0">typ := reflect.TypeOf(in)
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                // gets us a StructField
                typField := typ.Field(i)
                field := v.Field(i)
                if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                        out[typField.Name] = field.String()
                }</span>
        }
        <span class="cov0" title="0">return out</span>
}

func GetMapExtraFields(in any, extraFields string) map[string]string <span class="cov0" title="0">{
        out := make(map[string]string)
        v := reflect.ValueOf(in)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov0" title="0">field := v.FieldByName(extraFields)
        if field.Kind() == reflect.Map </span><span class="cov0" title="0">{
                keys := field.MapKeys()
                for _, key := range keys </span><span class="cov0" title="0">{
                        out[key.String()] = field.MapIndex(key).String()
                }</span>
        }
        <span class="cov0" title="0">return out</span>
}

func SetMapExtraFields(in any, values map[string]string, extraFields string) <span class="cov0" title="0">{
        v := reflect.ValueOf(in)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov0" title="0">efField := v.FieldByName(extraFields)
        if efField.IsValid() &amp;&amp; efField.Kind() == reflect.Map </span><span class="cov0" title="0">{
                keys := efField.MapKeys()
                for _, key := range keys </span><span class="cov0" title="0">{
                        if efField.MapIndex(key).String() != "" </span><span class="cov0" title="0">{
                                if val, found := values[key.String()]; found </span><span class="cov0" title="0">{
                                        efField.SetMapIndex(key, reflect.ValueOf(val))
                                }</span>
                        }
                }
        }
}

func FromMapStringString(m map[string]string, in any) <span class="cov0" title="0">{
        v := reflect.ValueOf(in)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov0" title="0">for fieldName, fieldValue := range m </span><span class="cov0" title="0">{
                field := v.FieldByName(fieldName)
                if field.IsValid() </span><span class="cov0" title="0">{
                        if field.Kind() == reflect.String </span><span class="cov0" title="0">{
                                if field.String() != "" &amp;&amp; field.CanSet() </span><span class="cov0" title="0">{
                                        field.SetString(fieldValue)
                                }</span>
                        }
                }
        }
}

func FromMapStringInterface(m map[string]any, in any) error <span class="cov0" title="0">{
        v := reflect.ValueOf(in)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov0" title="0">for fieldName, fieldValue := range m </span><span class="cov0" title="0">{
                field := v.FieldByName(fieldName)
                if field.IsValid() </span><span class="cov0" title="0">{
                        if !field.IsValid() || !field.CanSet() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">structFieldType := field.Type()
                        val := reflect.ValueOf(fieldValue)
                        if structFieldType != val.Type() </span><span class="cov0" title="0">{
                                return errors.New("Provided value type didn't match obj field type")
                        }</span>
                        <span class="cov0" title="0">field.Set(val)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// initial intent was to use it with *cgr_rpc but does not handle slice and structure fields
func FromMapStringInterfaceValue(m map[string]any, v reflect.Value) (any, error) <span class="cov8" title="1">{
        if v.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">for fieldName, fieldValue := range m </span><span class="cov8" title="1">{
                field := v.FieldByName(fieldName)
                if field.IsValid() </span><span class="cov8" title="1">{
                        if !field.IsValid() || !field.CanSet() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">val := reflect.ValueOf(fieldValue)
                        structFieldType := field.Type()
                        if structFieldType.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                field.Set(reflect.New(field.Type().Elem()))
                                field = field.Elem()
                        }</span>
                        <span class="cov8" title="1">structFieldType = field.Type()
                        if structFieldType != val.Type() </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("provided value type didn't match obj field type: %v vs %v (%v vs %v)", structFieldType, val.Type(), structFieldType.Kind(), val.Type().Kind())
                        }</span>
                        <span class="cov8" title="1">field.Set(val)</span>
                }
        }
        <span class="cov8" title="1">return v.Interface(), nil</span>
}

// Update struct with map fields, returns not matching map keys, s is a struct to be updated
func UpdateStructWithStrMap(s any, m map[string]string) []string <span class="cov0" title="0">{ // Not tested and declared and used only here
        notMatched := []string{}
        for key, val := range m </span><span class="cov0" title="0">{
                fld := reflect.ValueOf(s).Elem().FieldByName(key)
                if fld.IsValid() </span><span class="cov0" title="0">{
                        switch fld.Kind() </span>{
                        case reflect.Bool:<span class="cov0" title="0">
                                if valBool, err := strconv.ParseBool(val); err != nil </span><span class="cov0" title="0">{
                                        notMatched = append(notMatched, key)
                                }</span> else<span class="cov0" title="0"> {
                                        fld.SetBool(valBool)
                                }</span>
                        case reflect.Int:<span class="cov0" title="0">
                                if valInt, err := strconv.ParseInt(val, 10, 64); err != nil </span><span class="cov0" title="0">{
                                        notMatched = append(notMatched, key)
                                }</span> else<span class="cov0" title="0"> {
                                        fld.SetInt(valInt)
                                }</span>
                        case reflect.String:<span class="cov0" title="0">
                                fld.SetString(val)</span>
                        }
                } else<span class="cov0" title="0"> {
                        notMatched = append(notMatched, key)
                }</span>
        }
        <span class="cov0" title="0">return notMatched</span>
}

// UpdateStructWithIfaceMap will update struct fields with values coming from map
// if map values are not matching the ones in struct convertion is being attempted
// ToDo: add here more fields
func UpdateStructWithIfaceMap(s any, mp map[string]any) (err error) <span class="cov8" title="1">{
        for key, val := range mp </span><span class="cov8" title="1">{
                fld := reflect.ValueOf(s).Elem().FieldByName(key)
                if fld.IsValid() </span><span class="cov8" title="1">{
                        switch fld.Kind() </span>{
                        case reflect.Bool:<span class="cov8" title="1">
                                if val == "" </span><span class="cov0" title="0">{ // auto-populate defaults so we can parse empty strings
                                        val = false
                                }</span>
                                <span class="cov8" title="1">if valBool, err := IfaceAsBool(val); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span> else<span class="cov8" title="1"> {
                                        fld.SetBool(valBool)
                                }</span>
                        case reflect.Int, reflect.Int64:<span class="cov8" title="1">
                                if val == "" </span><span class="cov0" title="0">{
                                        val = 0
                                }</span>
                                <span class="cov8" title="1">if valInt, err := IfaceAsInt64(val); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span> else<span class="cov8" title="1"> {
                                        fld.SetInt(valInt)
                                }</span>
                        case reflect.Float64:<span class="cov8" title="1">
                                if val == "" </span><span class="cov0" title="0">{
                                        val = 0.0
                                }</span>
                                <span class="cov8" title="1">if valFlt, err := IfaceAsFloat64(val); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span> else<span class="cov8" title="1"> {
                                        fld.SetFloat(valFlt)
                                }</span>
                        case reflect.String:<span class="cov8" title="1">
                                fld.SetString(IfaceAsString(val))</span>
                        default:<span class="cov0" title="0"> // improper use of function
                                return fmt.Errorf("cannot update unsupported struct field: %+v", fld)</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
Real-time Online/Offline Charging System (OCS) for Telecom &amp; ISP environments
Copyright (C) ITsysCOM GmbH

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
*/

package utils

import (
        "encoding/json"
        "errors"
        "log"
        "strconv"
        "time"
)

// for computing a dynamic value for Value field
type ValueFormula struct {
        Method string
        Params map[string]any
        Static float64
}

func ParseBalanceFilterValue(tor string, val string) (*ValueFormula, error) <span class="cov8" title="1">{
        if tor == VOICE </span><span class="cov8" title="1">{ // VOICE balance is parsed as nanoseconds with support for time duration strings
                if d, err := ParseDurationWithNanosecs(val); err == nil </span><span class="cov8" title="1">{
                        return &amp;ValueFormula{Static: float64(d.Nanoseconds())}, err
                }</span>
        } else<span class="cov8" title="1"> if u, err := strconv.ParseFloat(val, 64); err == nil </span><span class="cov8" title="1">{
                return &amp;ValueFormula{Static: u}, err
        }</span>
        <span class="cov0" title="0">var vf ValueFormula
        if err := json.Unmarshal([]byte(val), &amp;vf); err == nil </span><span class="cov0" title="0">{
                return &amp;vf, err
        }</span>
        <span class="cov0" title="0">return nil, errors.New("Invalid value: " + val)</span>
}

type valueFormula func(map[string]any) float64

const (
        INCREMENTAL = "*incremental"
)

var ValueFormulas = map[string]valueFormula{
        INCREMENTAL: incrementalFormula,
}

func (vf *ValueFormula) String() string <span class="cov0" title="0">{
        return ToJSON(vf)
}</span>

func incrementalFormula(params map[string]any) float64 <span class="cov8" title="1">{
        // check parameters
        unitsInterface, unitsFound := params["Units"]
        intervalInterface, intervalFound := params["Interval"]
        incrementInterface, incrementFound := params["Increment"]

        if !unitsFound || !intervalFound || !incrementFound </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        <span class="cov8" title="1">units, ok := unitsInterface.(float64)
        if !ok </span><span class="cov0" title="0">{
                log.Print("units")
                return 0.0
        }</span>
        <span class="cov8" title="1">var interval string
        switch intr := intervalInterface.(type) </span>{
        case string:<span class="cov8" title="1">
                interval = intr</span>
        case []byte:<span class="cov0" title="0">
                interval = string(intr)</span>
        default:<span class="cov0" title="0">
                return 0.0</span>
        }
        <span class="cov8" title="1">var increment string
        switch incr := incrementInterface.(type) </span>{
        case string:<span class="cov8" title="1">
                increment = incr</span>
        case []byte:<span class="cov0" title="0">
                increment = string(incr)</span>
        default:<span class="cov0" title="0">
                return 0.0</span>
        }
        <span class="cov8" title="1">now := time.Now()
        if increment == "day" </span><span class="cov8" title="1">{
                if interval == "week" </span><span class="cov8" title="1">{
                        return units / 7
                }</span>
                <span class="cov8" title="1">if interval == "month" </span><span class="cov8" title="1">{
                        return units / DaysInMonth(now.Year(), now.Month())
                }</span>
                <span class="cov8" title="1">if interval == "year" </span><span class="cov8" title="1">{
                        return units / DaysInYear(now.Year())
                }</span>
        }
        <span class="cov0" title="0">if increment == "hour" </span><span class="cov0" title="0">{
                if interval == "day" </span><span class="cov0" title="0">{
                        return units / 24
                }</span>
                <span class="cov0" title="0">if interval == "month" </span><span class="cov0" title="0">{
                        return units / (DaysInMonth(now.Year(), now.Month()) * 24)
                }</span>
                <span class="cov0" title="0">if interval == "year" </span><span class="cov0" title="0">{
                        return units / (DaysInYear(now.Year()) * 24)
                }</span>
        }
        <span class="cov0" title="0">if increment == "minute" </span><span class="cov0" title="0">{
                if interval == "hour" </span><span class="cov0" title="0">{
                        return units / 60
                }</span>
        }
        <span class="cov0" title="0">return 0.0</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
